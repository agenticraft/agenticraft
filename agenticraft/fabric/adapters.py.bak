"""
Adapter implementations with SDK support for AgentiCraft Fabric.

This module provides adapters that can use official SDKs, custom implementations,
or hybrid approaches for each protocol.
"""

import logging
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union

from agenticraft.core.exceptions import ToolError

from .protocol_types import (
    IProtocolAdapter,
    ProtocolType,
    ProtocolCapability,
    UnifiedTool
)
from .protocol_adapters import (
    MCPAdapter,
    A2AAdapter,
    ACPAdapter,
    ANPAdapter
)

logger = logging.getLogger(__name__)


class SDKPreference(Enum):
    """SDK preference for protocol adapters."""
    AUTO = "auto"           # Automatically choose best available
    OFFICIAL = "official"   # Use official SDK if available
    CUSTOM = "custom"       # Use AgentiCraft custom implementation
    HYBRID = "hybrid"       # Use official SDK with custom fallback


class SDKAdapter(IProtocolAdapter):
    """Base adapter with SDK support."""
    
    def __init__(self, sdk_preference: SDKPreference = SDKPreference.AUTO):
        self.sdk_preference = sdk_preference
        self._official_available = False
        self._check_sdk_availability()
    
    def _check_sdk_availability(self):
        """Check if official SDK is available."""
        # Override in subclasses
        pass
    
    def supports_feature(self, feature: str) -> bool:
        """Check if adapter supports a feature."""
        # Default implementation
        return feature in self.get_supported_features()
    
    def get_supported_features(self) -> List[str]:
        """Get list of supported features."""
        # Override in subclasses
        return ["tools"]


class MCPOfficialAdapter(SDKAdapter):
    """MCP adapter using official SDK."""
    
    def __init__(self):
        super().__init__(SDKPreference.OFFICIAL)
        self.protocol_type = ProtocolType.MCP
    
    def _check_sdk_availability(self):
        """Check if MCP SDK is available."""
        try:
            import mcp  # type: ignore
            self._official_available = True
        except ImportError:
            self._official_available = False
    
    async def connect(self, config: Dict[str, Any]) -> None:
        """Connect using official MCP SDK."""
        if not self._official_available:
            raise ImportError("MCP SDK not available. Install with: pip install mcp")
        
        # Placeholder for actual SDK usage
        logger.info("Connected with MCP official SDK")
    
    async def disconnect(self) -> None:
        """Disconnect from MCP."""
        logger.info("Disconnected from MCP official SDK")
    
    async def discover_tools(self) -> List[UnifiedTool]:
        """Discover tools using official SDK."""
        return []
    
    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute tool using official SDK."""
        raise ToolError(f"Tool execution not implemented: {tool_name}")
    
    async def get_capabilities(self) -> List[ProtocolCapability]:
        """Get MCP capabilities."""
        return [
            ProtocolCapability.TOOLS,
            ProtocolCapability.RESOURCES,
            ProtocolCapability.PROMPTS
        ]
    
    def supports_feature(self, feature: str) -> bool:
        """Check if MCP supports feature."""
        features = ["tools", "resources", "prompts", "contexts"]
        return feature in features


class A2AOfficialAdapter(SDKAdapter):
    """A2A adapter using official SDK."""
    
    def __init__(self):
        super().__init__(SDKPreference.OFFICIAL)
        self.protocol_type = ProtocolType.A2A
    
    def _check_sdk_availability(self):
        """Check if A2A SDK is available."""
        try:
            import a2a  # type: ignore
            self._official_available = True
        except ImportError:
            self._official_available = False
    
    async def connect(self, config: Dict[str, Any]) -> None:
        """Connect using official A2A SDK."""
        if not self._official_available:
            raise ImportError("A2A SDK not available")
        
        logger.info("Connected with A2A official SDK")
    
    async def disconnect(self) -> None:
        """Disconnect from A2A."""
        logger.info("Disconnected from A2A official SDK")
    
    async def discover_tools(self) -> List[UnifiedTool]:
        """Discover tools using official SDK."""
        return []
    
    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute tool using official SDK."""
        raise ToolError(f"Tool execution not implemented: {tool_name}")
    
    async def get_capabilities(self) -> List[ProtocolCapability]:
        """Get A2A capabilities."""
        return [
            ProtocolCapability.TOOLS,
            ProtocolCapability.DISCOVERY,
            ProtocolCapability.TRUST
        ]
    
    def supports_feature(self, feature: str) -> bool:
        """Check if A2A supports feature."""
        features = ["tools", "discovery", "trust", "authentication"]
        return feature in features


class ACPBeeAdapter(SDKAdapter):
    """ACP adapter using Bee framework."""
    
    def __init__(self):
        super().__init__(SDKPreference.OFFICIAL)
        self.protocol_type = ProtocolType.ACP
    
    def _check_sdk_availability(self):
        """Check if Bee framework is available."""
        try:
            import bee_agent_framework  # type: ignore
            self._official_available = True
        except ImportError:
            self._official_available = False
    
    async def connect(self, config: Dict[str, Any]) -> None:
        """Connect using Bee framework."""
        if not self._official_available:
            # Bee framework is optional, use custom adapter
            logger.info("Bee framework not available, using custom ACP adapter")
        else:
            logger.info("Connected with Bee framework")
    
    async def disconnect(self) -> None:
        """Disconnect from ACP."""
        logger.info("Disconnected from ACP/Bee")
    
    async def discover_tools(self) -> List[UnifiedTool]:
        """Discover tools."""
        return []
    
    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute tool."""
        raise ToolError(f"Tool execution not implemented: {tool_name}")
    
    async def get_capabilities(self) -> List[ProtocolCapability]:
        """Get ACP capabilities."""
        return [
            ProtocolCapability.TOOLS,
            ProtocolCapability.WORKFLOWS,
            ProtocolCapability.SESSIONS
        ]
    
    def supports_feature(self, feature: str) -> bool:
        """Check if ACP supports feature."""
        features = ["tools", "workflows", "sessions", "persistence"]
        return feature in features


class AdapterFactory:
    """Factory for creating protocol adapters with SDK preferences."""
    
    @staticmethod
    def create_adapter(
        protocol: ProtocolType,
        sdk_preference: SDKPreference = SDKPreference.AUTO
    ) -> IProtocolAdapter:
        """Create an adapter based on protocol and SDK preference."""
        
        if sdk_preference == SDKPreference.AUTO:
            # Check if official SDK is available
            if AdapterFactory._is_sdk_available(protocol):
                sdk_preference = SDKPreference.OFFICIAL
            else:
                sdk_preference = SDKPreference.CUSTOM
        
        # Create appropriate adapter
        if sdk_preference == SDKPreference.OFFICIAL:
            if protocol == ProtocolType.MCP:
                return MCPOfficialAdapter()
            elif protocol == ProtocolType.A2A:
                return A2AOfficialAdapter()
            elif protocol == ProtocolType.ACP:
                return ACPBeeAdapter()
            else:
                # Fall back to custom for unsupported protocols
                sdk_preference = SDKPreference.CUSTOM
        
        if sdk_preference == SDKPreference.CUSTOM:
            # Use AgentiCraft custom adapters
            if protocol == ProtocolType.MCP:
                return MCPAdapter()
            elif protocol == ProtocolType.A2A:
                return A2AAdapter()
            elif protocol == ProtocolType.ACP:
                return ACPAdapter()
            elif protocol == ProtocolType.ANP:
                return ANPAdapter()
        
        if sdk_preference == SDKPreference.HYBRID:
            # TODO: Implement hybrid adapters that can fall back
            # For now, just use custom
            return AdapterFactory.create_adapter(protocol, SDKPreference.CUSTOM)
        
        raise ValueError(f"Unsupported combination: {protocol} with {sdk_preference}")
    
    @staticmethod
    def _is_sdk_available(protocol: ProtocolType) -> bool:
        """Check if official SDK is available for a protocol."""
        if protocol == ProtocolType.MCP:
            try:
                import mcp  # type: ignore
                return True
            except ImportError:
                return False
        elif protocol == ProtocolType.A2A:
            try:
                import a2a  # type: ignore
                return True
            except ImportError:
                return False
        elif protocol == ProtocolType.ACP:
            try:
                import bee_agent_framework  # type: ignore
                return True
            except ImportError:
                return False
        
        return False
    
    @staticmethod
    def get_available_adapters() -> Dict[str, Dict[str, bool]]:
        """Get availability status for all adapters."""
        protocols = [ProtocolType.MCP, ProtocolType.A2A, ProtocolType.ACP, ProtocolType.ANP]
        status = {}
        
        for protocol in protocols:
            status[protocol.value] = {
                "official": AdapterFactory._is_sdk_available(protocol),
                "custom": True,  # Custom adapters are always available
                "hybrid": True   # Hybrid can always fall back to custom
            }
        
        return status
    
    @staticmethod
    def get_best_adapter(
        protocol: ProtocolType,
        features: Optional[List[str]] = None
    ) -> str:
        """Get recommendation for best adapter based on features."""
        # For now, simple logic
        if AdapterFactory._is_sdk_available(protocol):
            return "official"
        return "custom"


class AdapterRegistry:
    """Registry for managing protocol adapters."""
    
    def __init__(self):
        self._adapters: Dict[str, Type[IProtocolAdapter]] = {}
        self._instances: Dict[str, IProtocolAdapter] = {}
    
    def register(self, name: str, adapter_class: Type[IProtocolAdapter]):
        """Register an adapter class."""
        self._adapters[name] = adapter_class
    
    def get(self, name: str) -> Optional[IProtocolAdapter]:
        """Get an adapter instance."""
        if name not in self._instances and name in self._adapters:
            self._instances[name] = self._adapters[name]()
        return self._instances.get(name)
    
    def list(self) -> List[str]:
        """List registered adapters."""
        return list(self._adapters.keys())


# Global registry
_adapter_registry = AdapterRegistry()

def get_adapter_registry() -> AdapterRegistry:
    """Get the global adapter registry."""
    return _adapter_registry

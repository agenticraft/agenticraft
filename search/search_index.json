{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd16 Welcome to AgentiCraft","text":"<p>Build AI agents as simple as writing Python</p> <p> </p>"},{"location":"#why-agenticraft","title":"Why AgentiCraft?","text":"<p>Building AI agents should be as simple as writing Python. No complex abstractions, no graph theory, no 500-page documentation. Just clean, simple code that works.</p> <p>5-Minute Quickstart</p> <p>Get your first agent running faster than making coffee. Start here \u2192</p>"},{"location":"#core-principles","title":"Core Principles","text":"<ul> <li> <p>\ud83d\ude80 Simple First   If it's not simple, it's not in core. Every API designed for developer joy.</p> </li> <li> <p>\ud83e\udde0 Transparent Reasoning   See how your agents think, not just what they output. No black boxes.</p> </li> <li> <p>\ud83d\udd0c MCP-Native   First-class Model Context Protocol support. Use any MCP tool seamlessly.</p> </li> <li> <p>\ud83d\udcc8 Production Ready   Built-in observability, templates, and best practices from day one.</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from agenticraft import Agent, tool\n\n@tool\ndef calculate(expression: str) -&gt; float:\n    \"\"\"Evaluate a mathematical expression.\"\"\"\n    return eval(expression, {\"__builtins__\": {}}, {})\n\nagent = Agent(\n    name=\"MathAssistant\",\n    instructions=\"You are a helpful math assistant.\",\n    tools=[calculate]\n)\n\nresponse = agent.run(\"What's 42 * 17 + 238?\")\nprint(response.content)\n# Output: \"Let me calculate that for you: 42 * 17 + 238 = 952\"\n\n# See the reasoning process\nprint(response.reasoning)\n# Output: \"I need to calculate the expression 42 * 17 + 238...\"\n</code></pre>"},{"location":"#what-makes-agenticraft-different","title":"What Makes AgentiCraft Different?","text":"Feature AgentiCraft Others Setup Time 1 minute 5-30 minutes Core Size &lt;2,000 lines 50,000+ lines Time to First Agent 5 minutes 30+ minutes Documentation 100% coverage Variable Reasoning Visibility Built-in Often hidden Production Templates Included DIY"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":""},{"location":"#simple-agent-creation","title":"\ud83c\udfaf Simple Agent Creation","text":"<p><pre><code>agent = Agent(name=\"assistant\")\n</code></pre> That's it. No configuration files, no complex setup.</p>"},{"location":"#transparent-reasoning","title":"\ud83e\udde0 Transparent Reasoning","text":"<pre><code>response = agent.run(\"Complex question\")\nprint(response.reasoning)  # See the thought process\n</code></pre>"},{"location":"#easy-tool-integration","title":"\ud83d\udd27 Easy Tool Integration","text":"<pre><code>@tool\ndef my_tool(param: str) -&gt; str:\n    return f\"Processed: {param}\"\n\nagent = Agent(tools=[my_tool])\n</code></pre>"},{"location":"#simple-workflows","title":"\ud83d\udd04 Simple Workflows","text":"<pre><code>workflow = Workflow(name=\"pipeline\")\nworkflow.add_steps([\n    Step(\"research\", agent=researcher),\n    Step(\"write\", agent=writer, depends_on=[\"research\"])\n])\n</code></pre>"},{"location":"#built-in-observability","title":"\ud83d\udcca Built-in Observability","text":"<pre><code>from agenticraft import Telemetry\n\ntelemetry = Telemetry(export_to=\"http://localhost:4317\")\nagent = Agent(telemetry=telemetry)\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p>5-Minute Quickstart   Build your first agent faster than making coffee</p> </li> <li> <p>Core Concepts   Understand the fundamentals</p> </li> <li> <p>API Reference   Detailed documentation for every feature</p> </li> <li> <p>Examples   Learn from real-world implementations</p> </li> </ul>"},{"location":"#community","title":"Community","text":"<p>Join our growing community of developers building with AgentiCraft:</p> <ul> <li>Discord - Get help and share ideas</li> <li>GitHub - Contribute and star the project</li> <li>Blog - Latest updates and tutorials</li> </ul>"},{"location":"#ready-to-build","title":"Ready to Build?","text":"<p>Get Started \u2192 | View Examples \u2192</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to AgentiCraft will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2025-01-xx","title":"[0.1.0] - 2025-01-XX","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of AgentiCraft</li> <li>Core Agent functionality with transparent reasoning</li> <li>Tool system with decorator-based interface</li> <li>Simple step-based workflows</li> <li>Two-tier memory system (Conversation and Knowledge)</li> <li>Support for multiple LLM providers (OpenAI, Anthropic, Google, Ollama)</li> <li>Model Context Protocol (MCP) integration</li> <li>Built-in observability with OpenTelemetry</li> <li>Plugin architecture</li> <li>Comprehensive documentation</li> <li>Production-ready templates</li> <li>CLI tool for project scaffolding</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Safe tool execution with validation</li> <li>Configurable security settings</li> <li>Domain allowlist for web requests</li> </ul>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#planned","title":"Planned","text":"<ul> <li>Additional provider integrations</li> <li>Enhanced MCP capabilities</li> <li>More production templates</li> <li>Performance optimizations</li> </ul>"},{"location":"philosophy/","title":"Philosophy","text":"<p>AgentiCraft is built on strong principles that guide every design decision. Understanding our philosophy helps you get the most out of the framework.</p>"},{"location":"philosophy/#core-principles","title":"Core Principles","text":""},{"location":"philosophy/#1-simplicity-first","title":"1. Simplicity First \ud83c\udfaf","text":"<p>\"Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.\" - Antoine de Saint-Exup\u00e9ry</p> <p>Every feature in AgentiCraft must pass the simplicity test: - Can it be explained in one sentence? - Can a developer use it without reading docs? - Does it solve a real problem?</p> <p>If the answer to any of these is \"no\", it doesn't belong in core.</p> <p>Example: Creating an agent <pre><code># This is all you need\nagent = Agent(name=\"assistant\")\n</code></pre></p>"},{"location":"philosophy/#2-transparent-by-default","title":"2. Transparent by Default \ud83e\udde0","text":"<p>AI agents shouldn't be black boxes. Developers need to understand: - What the agent is thinking - Why it made certain decisions - How it arrived at its response</p> <p>Example: Reasoning visibility <pre><code>response = agent.run(\"Complex question\")\nprint(response.reasoning)  # Always available\n</code></pre></p>"},{"location":"philosophy/#3-production-ready-from-day-one","title":"3. Production-Ready from Day One \ud83d\udcca","text":"<p>Demos are easy. Production is hard. AgentiCraft bridges this gap: - Built-in observability - Error handling that makes sense - Templates for common use cases - Performance considerations baked in</p>"},{"location":"philosophy/#4-developer-joy","title":"4. Developer Joy \ud83d\udc9c","text":"<p>Writing agent code should be enjoyable: - Intuitive APIs that feel natural - Clear error messages that help, not frustrate - Excellent documentation with real examples - Fast feedback loops</p>"},{"location":"philosophy/#5-extensible-not-bloated","title":"5. Extensible, Not Bloated \ud83d\udd27","text":"<p>The core stays small (&lt;2000 lines), but the possibilities are endless: - Plugin architecture for custom needs - Standard interfaces for interoperability - Community-driven ecosystem</p>"},{"location":"philosophy/#design-decisions","title":"Design Decisions","text":""},{"location":"philosophy/#why-not-graph-based-workflows","title":"Why Not Graph-Based Workflows?","text":"<p>Many frameworks use complex graph structures for workflows. We chose simplicity:</p> <pre><code># AgentiCraft way - simple and clear\nworkflow.add_steps([\n    Step(\"research\", agent=researcher),\n    Step(\"write\", agent=writer, depends_on=[\"research\"])\n])\n\n# Not the AgentiCraft way - unnecessary complexity\nworkflow.add_node(\"research\", ResearchNode())\nworkflow.add_edge(\"research\", \"write\", condition=lambda x: x.success)\n</code></pre> <p>Graphs are powerful but rarely necessary. Our step-based approach handles 95% of use cases with 10% of the complexity.</p>"},{"location":"philosophy/#why-only-two-memory-types","title":"Why Only Two Memory Types?","text":"<p>Other frameworks offer 5+ memory types: - Short-term memory - Long-term memory - Episodic memory - Semantic memory - Procedural memory</p> <p>We provide just two: 1. ConversationMemory - Recent interactions 2. KnowledgeMemory - Persistent facts</p> <p>Why? Because that's all you need in practice. Additional complexity doesn't improve outcomes.</p>"},{"location":"philosophy/#why-reasoning-patterns-matter","title":"Why Reasoning Patterns Matter","text":"<p>LLMs can reason, but they need structure. We provide patterns, not prompts:</p> <pre><code>from agenticraft import Agent, ChainOfThought\n\nagent = Agent(\n    name=\"Analyst\",\n    reasoning_pattern=ChainOfThought()  # Structured thinking\n)\n</code></pre> <p>This ensures consistent, high-quality reasoning across all agents.</p>"},{"location":"philosophy/#what-were-not-building","title":"What We're NOT Building","text":"<p>Being clear about what we won't build is as important as what we will:</p>"},{"location":"philosophy/#not-another-langchain","title":"\u274c NOT Another LangChain","text":"<p>LangChain is powerful but complex. We're building something different: - Simpler APIs - Smaller core - Clearer abstractions - Better developer experience</p>"},{"location":"philosophy/#not-a-kitchen-sink","title":"\u274c NOT a Kitchen Sink","text":"<p>We resist the temptation to add every possible feature: - No 20 different memory types - No complex graph visualizations - No unnecessary abstractions - No features \"just in case\"</p>"},{"location":"philosophy/#not-a-research-project","title":"\u274c NOT a Research Project","text":"<p>This is production software: - Stability over novelty - Reliability over impressiveness - Documentation over demos - Real use cases over paper citations</p>"},{"location":"philosophy/#community-values","title":"Community Values","text":""},{"location":"philosophy/#open-source-open-community","title":"Open Source, Open Community","text":"<ul> <li>Contributions welcome - But simplicity is non-negotiable</li> <li>Feedback valued - Users shape the roadmap</li> <li>Transparency default - Development happens in the open</li> </ul>"},{"location":"philosophy/#quality-over-quantity","title":"Quality Over Quantity","text":"<ul> <li>Better 10 excellent tools than 100 mediocre ones</li> <li>Better clear docs than extensive ones</li> <li>Better stable API than feature-rich</li> </ul>"},{"location":"philosophy/#pragmatism-wins","title":"Pragmatism Wins","text":"<ul> <li>Real-world usage drives decisions</li> <li>Production experience matters</li> <li>Developer time is valuable</li> </ul>"},{"location":"philosophy/#the-agenticraft-way","title":"The AgentiCraft Way","text":"<p>When building with AgentiCraft, ask yourself:</p> <ol> <li>Is this the simplest solution?</li> <li>Can I understand what's happening?</li> <li>Will this work in production?</li> <li>Am I enjoying this?</li> </ol> <p>If you answer \"yes\" to all four, you're doing it the AgentiCraft way.</p>"},{"location":"philosophy/#future-vision","title":"Future Vision","text":"<p>As AgentiCraft grows, these principles remain constant:</p> <ul> <li>Core stays small - Complexity lives in plugins</li> <li>APIs stay simple - Power through composition</li> <li>Reasoning stays transparent - No black boxes</li> <li>Production stays first - Real-world focus</li> </ul>"},{"location":"philosophy/#join-us","title":"Join Us","text":"<p>If these principles resonate with you:</p> <ul> <li>\u2b50 Star the project</li> <li>\ud83d\udcac Join the discussion</li> <li>\ud83d\udee0\ufe0f Contribute code</li> <li>\ud83d\udcdd Share your story</li> </ul> <p>Together, we're making AI agent development accessible to every developer.</p> <p>\"Make it simple. Make it transparent. Make it work.\" - The AgentiCraft Motto</p>"},{"location":"plugin-development/","title":"Plugin Development Guide","text":"<p>This guide explains how to create custom plugins for AgentiCraft to extend its functionality with new tools, agents, providers, and capabilities.</p>"},{"location":"plugin-development/#overview","title":"Overview","text":"<p>AgentiCraft's plugin system allows you to:</p> <ul> <li>Add custom tools and capabilities</li> <li>Create specialized agents</li> <li>Integrate new LLM providers</li> <li>Enhance existing agents with new features</li> <li>Hook into the agent lifecycle</li> <li>Add telemetry and monitoring</li> </ul>"},{"location":"plugin-development/#quick-start","title":"Quick Start","text":"<p>Here's a minimal plugin example:</p> <pre><code>from agenticraft.plugins import BasePlugin, PluginInfo\n\nclass HelloPlugin(BasePlugin):\n    name = \"hello\"\n    version = \"1.0.0\"\n    description = \"A simple greeting plugin\"\n\n    def get_info(self) -&gt; PluginInfo:\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description\n        )\n</code></pre>"},{"location":"plugin-development/#plugin-structure","title":"Plugin Structure","text":""},{"location":"plugin-development/#basic-plugin-class","title":"Basic Plugin Class","text":"<p>Every plugin must inherit from <code>BasePlugin</code> and implement required methods:</p> <pre><code>from agenticraft.plugins import BasePlugin, PluginInfo, PluginConfig\nfrom typing import List, Dict, Any\n\nclass MyPlugin(BasePlugin):\n    # Required metadata\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n    description = \"Does amazing things\"\n    author = \"Your Name\"\n\n    def __init__(self, config: PluginConfig = None):\n        super().__init__(config)\n        # Initialize your plugin\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Return plugin metadata and capabilities.\"\"\"\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description,\n            author=self.author,\n            provides_tools=[\"tool1\", \"tool2\"],\n            provides_agents=[\"CustomAgent\"],\n            provides_providers=[\"custom_llm\"]\n        )\n\n    def initialize(self):\n        \"\"\"Set up resources, connections, etc.\"\"\"\n        super().initialize()\n        # Your initialization code\n\n    def cleanup(self):\n        \"\"\"Clean up resources.\"\"\"\n        # Your cleanup code\n        super().cleanup()\n</code></pre>"},{"location":"plugin-development/#providing-tools","title":"Providing Tools","text":"<p>Plugins can provide tools that agents can use:</p> <pre><code>from agenticraft.core.tool import Tool\n\nclass CalculatorTool(Tool):\n    name = \"calculator\"\n    description = \"Performs mathematical calculations\"\n\n    async def execute(self, expression: str) -&gt; float:\n        # Safely evaluate math expression\n        return eval(expression, {\"__builtins__\": {}})\n\nclass MathPlugin(BasePlugin):\n    name = \"math\"\n    version = \"1.0.0\"\n\n    def get_tools(self) -&gt; List[Tool]:\n        return [CalculatorTool()]\n</code></pre>"},{"location":"plugin-development/#providing-agents","title":"Providing Agents","text":"<p>Plugins can provide complete agent implementations:</p> <pre><code>from agenticraft.core.agent import Agent\n\nclass ResearchAgent(Agent):\n    \"\"\"Specialized agent for research tasks.\"\"\"\n\n    async def process(self, query: str) -&gt; str:\n        # Research implementation\n        return f\"Research results for: {query}\"\n\nclass ResearchPlugin(BasePlugin):\n    name = \"research\"\n    version = \"1.0.0\"\n\n    def get_agents(self) -&gt; List[type]:\n        return [ResearchAgent]\n</code></pre>"},{"location":"plugin-development/#enhancing-existing-agents","title":"Enhancing Existing Agents","text":"<p>Plugins can modify or enhance agents:</p> <pre><code>class EnhancerPlugin(BasePlugin):\n    name = \"enhancer\"\n    version = \"1.0.0\"\n\n    def enhance_agent(self, agent):\n        \"\"\"Add capabilities to any agent.\"\"\"\n        # Add tools\n        for tool in self.get_tools():\n            agent.add_tool(tool)\n\n        # Add context\n        agent.add_context(\"You are enhanced with special abilities...\")\n\n        # Add capabilities\n        agent.add_capability(\"enhanced_reasoning\")\n\n        return agent\n</code></pre>"},{"location":"plugin-development/#configuration","title":"Configuration","text":""},{"location":"plugin-development/#plugin-configuration-schema","title":"Plugin Configuration Schema","text":"<p>Define configuration options for your plugin:</p> <pre><code>def get_config_schema(self) -&gt; Dict[str, Any]:\n    return {\n        \"type\": \"object\",\n        \"properties\": {\n            \"api_key\": {\n                \"type\": \"string\",\n                \"description\": \"API key for service\"\n            },\n            \"timeout\": {\n                \"type\": \"integer\",\n                \"default\": 30,\n                \"description\": \"Request timeout in seconds\"\n            },\n            \"retry_count\": {\n                \"type\": \"integer\",\n                \"default\": 3,\n                \"minimum\": 0,\n                \"maximum\": 10\n            }\n        },\n        \"required\": [\"api_key\"]\n    }\n</code></pre>"},{"location":"plugin-development/#using-configuration","title":"Using Configuration","text":"<p>Access configuration in your plugin:</p> <pre><code>def initialize(self):\n    super().initialize()\n\n    # Get config values\n    api_key = self.config.config.get(\"api_key\")\n    timeout = self.config.config.get(\"timeout\", 30)\n\n    # Validate required config\n    if not api_key:\n        raise ValueError(\"API key is required\")\n\n    # Initialize with config\n    self.client = APIClient(api_key=api_key, timeout=timeout)\n</code></pre>"},{"location":"plugin-development/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Plugins can hook into various lifecycle events:</p> <pre><code>from agenticraft.core.plugin import Plugin\n\nclass LifecyclePlugin(Plugin):\n    \"\"\"Example using core Plugin interface for lifecycle hooks.\"\"\"\n\n    def on_agent_created(self, agent):\n        \"\"\"Called when any agent is created.\"\"\"\n        print(f\"Agent created: {agent.name}\")\n\n    def on_agent_run_start(self, agent, prompt, context):\n        \"\"\"Called before agent processes input.\"\"\"\n        print(f\"Processing: {prompt[:50]}...\")\n\n    def on_agent_run_complete(self, agent, response):\n        \"\"\"Called after agent completes.\"\"\"\n        print(f\"Completed with {len(response.content)} chars\")\n\n    def on_tool_execution_start(self, tool_name, arguments):\n        \"\"\"Called before tool execution.\"\"\"\n        print(f\"Executing tool: {tool_name}\")\n\n    def on_response_generated(self, response):\n        \"\"\"Called to potentially modify responses.\"\"\"\n        # Add metadata\n        response.metadata[\"plugin_processed\"] = True\n        return response\n</code></pre>"},{"location":"plugin-development/#best-practices","title":"Best Practices","text":""},{"location":"plugin-development/#1-error-handling","title":"1. Error Handling","text":"<p>Always handle errors gracefully:</p> <pre><code>async def execute(self, **kwargs):\n    try:\n        result = await self.api_call(**kwargs)\n        return result\n    except APIError as e:\n        logger.error(f\"API error: {e}\")\n        return {\"error\": str(e)}\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        raise\n</code></pre>"},{"location":"plugin-development/#2-resource-management","title":"2. Resource Management","text":"<p>Use proper initialization and cleanup:</p> <pre><code>def initialize(self):\n    super().initialize()\n    self.connection = self._connect()\n    self.cache = {}\n\ndef cleanup(self):\n    if hasattr(self, 'connection'):\n        self.connection.close()\n    self.cache.clear()\n    super().cleanup()\n</code></pre>"},{"location":"plugin-development/#3-async-support","title":"3. Async Support","text":"<p>Make tools and methods async when possible:</p> <pre><code>async def execute(self, query: str) -&gt; Dict[str, Any]:\n    # Async operations\n    async with httpx.AsyncClient() as client:\n        response = await client.get(f\"{self.api_url}?q={query}\")\n        return response.json()\n</code></pre>"},{"location":"plugin-development/#4-telemetry-integration","title":"4. Telemetry Integration","text":"<p>Add telemetry to track plugin usage:</p> <pre><code>from agenticraft.telemetry import track_metrics\n\nclass TelemetryPlugin(BasePlugin):\n    @track_metrics(\n        name=\"plugin.api_calls\",\n        labels=[\"endpoint\", \"status\"]\n    )\n    async def call_api(self, endpoint: str):\n        # Your API call\n        return result\n</code></pre>"},{"location":"plugin-development/#5-documentation","title":"5. Documentation","text":"<p>Document your plugin thoroughly:</p> <pre><code>class WellDocumentedPlugin(BasePlugin):\n    \"\"\"\n    My Amazing Plugin\n\n    This plugin provides X, Y, and Z capabilities for AgentiCraft.\n\n    Configuration:\n        api_key (str): Required. Your API key\n        region (str): Optional. API region (default: \"us\")\n\n    Provides:\n        Tools: search, analyze, summarize\n        Agents: ResearchAgent, AnalysisAgent\n\n    Example:\n        plugin = WellDocumentedPlugin(PluginConfig(\n            config={\"api_key\": \"xxx\", \"region\": \"eu\"}\n        ))\n    \"\"\"\n</code></pre>"},{"location":"plugin-development/#plugin-types","title":"Plugin Types","text":""},{"location":"plugin-development/#tool-plugin","title":"Tool Plugin","text":"<p>For plugins that only provide tools:</p> <pre><code>from agenticraft.plugins import ToolPlugin\n\nclass UtilityPlugin(ToolPlugin):\n    name = \"utilities\"\n    version = \"1.0.0\"\n\n    def create_tools(self) -&gt; List[Tool]:\n        return [\n            DateTool(),\n            RandomTool(),\n            HashTool()\n        ]\n</code></pre>"},{"location":"plugin-development/#agent-plugin","title":"Agent Plugin","text":"<p>For plugins that provide agents:</p> <pre><code>from agenticraft.plugins import AgentPlugin\n\nclass SpecialistPlugin(AgentPlugin):\n    name = \"specialists\"\n    version = \"1.0.0\"\n\n    def create_agents(self) -&gt; List[type]:\n        return [\n            CodeReviewAgent,\n            DocumentationAgent,\n            TestingAgent\n        ]\n</code></pre>"},{"location":"plugin-development/#composite-plugin","title":"Composite Plugin","text":"<p>For comprehensive plugins:</p> <pre><code>from agenticraft.plugins import CompositePlugin\n\nclass FullFeaturePlugin(CompositePlugin):\n    name = \"full_feature\"\n    version = \"1.0.0\"\n\n    def get_tools(self) -&gt; List[Tool]:\n        return [Tool1(), Tool2()]\n\n    def get_agents(self) -&gt; List[type]:\n        return [Agent1, Agent2]\n\n    def get_providers(self) -&gt; Dict[str, type]:\n        return {\"custom\": CustomProvider}\n</code></pre>"},{"location":"plugin-development/#testing-your-plugin","title":"Testing Your Plugin","text":""},{"location":"plugin-development/#unit-tests","title":"Unit Tests","text":"<pre><code>import pytest\nfrom agenticraft.plugins import PluginConfig\n\n@pytest.fixture\ndef plugin():\n    config = PluginConfig(config={\"api_key\": \"test\"})\n    return MyPlugin(config)\n\ndef test_plugin_info(plugin):\n    info = plugin.get_info()\n    assert info.name == \"my_plugin\"\n    assert \"tool1\" in info.provides_tools\n\nasync def test_tool_execution(plugin):\n    tools = plugin.get_tools()\n    result = await tools[0].execute(\"test input\")\n    assert result is not None\n</code></pre>"},{"location":"plugin-development/#integration-tests","title":"Integration Tests","text":"<pre><code>async def test_plugin_with_agent():\n    # Load plugin\n    plugin = MyPlugin()\n    plugin.initialize()\n\n    # Create agent and enhance\n    agent = Agent(\"Test\")\n    enhanced = plugin.enhance_agent(agent)\n\n    # Test enhanced agent\n    response = await enhanced.run(\"test query\")\n    assert response.success\n\n    # Cleanup\n    plugin.cleanup()\n</code></pre>"},{"location":"plugin-development/#distribution","title":"Distribution","text":""},{"location":"plugin-development/#package-structure","title":"Package Structure","text":"<pre><code>my-plugin/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 my_plugin/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 plugin.py\n\u2502   \u251c\u2500\u2500 tools.py\n\u2502   \u2514\u2500\u2500 agents.py\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_plugin.py\n</code></pre>"},{"location":"plugin-development/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[project]\nname = \"agenticraft-my-plugin\"\nversion = \"1.0.0\"\ndescription = \"My plugin for AgentiCraft\"\ndependencies = [\n    \"agenticraft&gt;=0.1.0\",\n    \"httpx&gt;=0.25.0\"\n]\n\n[project.entry-points.\"agenticraft.plugins\"]\nmy_plugin = \"my_plugin:MyPlugin\"\n</code></pre>"},{"location":"plugin-development/#installation","title":"Installation","text":"<p>Users can install your plugin with:</p> <pre><code>pip install agenticraft-my-plugin\n</code></pre> <p>Or from a directory:</p> <pre><code>agenticraft plugin install ./my-plugin\n</code></pre>"},{"location":"plugin-development/#examples","title":"Examples","text":"<p>See the <code>examples/plugins/</code> directory for complete examples:</p> <ul> <li><code>weather_plugin.py</code> - Basic tool plugin</li> <li><code>research_plugin.py</code> - Agent plugin</li> <li><code>telemetry_plugin.py</code> - Monitoring integration</li> <li><code>composite_plugin.py</code> - Full-featured plugin</li> </ul>"},{"location":"plugin-development/#plugin-discovery","title":"Plugin Discovery","text":"<p>Plugins are discovered from:</p> <ol> <li>Built-in plugins directory</li> <li><code>~/.agenticraft/plugins/</code></li> <li>Directories in <code>AGENTICRAFT_PLUGIN_PATH</code></li> <li>Installed Python packages with entry points</li> </ol>"},{"location":"plugin-development/#debugging","title":"Debugging","text":"<p>Enable debug logging to troubleshoot plugins:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"agenticraft.plugins\")\n\n# In your plugin\nlogger.debug(f\"Loading plugin: {self.name}\")\n</code></pre>"},{"location":"plugin-development/#security-considerations","title":"Security Considerations","text":"<ol> <li>Validate all inputs from configuration and users</li> <li>Sanitize outputs before returning to agents</li> <li>Use minimal permissions for external services</li> <li>Don't store secrets in code or configs</li> <li>Follow secure coding practices</li> </ol>"},{"location":"plugin-development/#faq","title":"FAQ","text":""},{"location":"plugin-development/#q-can-plugins-depend-on-other-plugins","title":"Q: Can plugins depend on other plugins?","text":"<p>Yes, use the <code>depends_on</code> field in PluginInfo:</p> <pre><code>def get_info(self):\n    return PluginInfo(\n        name=\"my_plugin\",\n        depends_on=[\"base_plugin\", \"auth_plugin\"]\n    )\n</code></pre>"},{"location":"plugin-development/#q-how-do-i-version-my-plugin","title":"Q: How do I version my plugin?","text":"<p>Use semantic versioning (MAJOR.MINOR.PATCH): - MAJOR: Breaking changes - MINOR: New features, backwards compatible - PATCH: Bug fixes</p>"},{"location":"plugin-development/#q-can-i-use-external-libraries","title":"Q: Can I use external libraries?","text":"<p>Yes, declare them in your plugin's dependencies. Users will need to install them.</p>"},{"location":"plugin-development/#q-how-do-i-handle-async-vs-sync-tools","title":"Q: How do I handle async vs sync tools?","text":"<p>AgentiCraft supports both. Use async when possible for better performance.</p>"},{"location":"plugin-development/#getting-help","title":"Getting Help","text":"<ul> <li>Check the examples</li> <li>Join our Discord</li> <li>Open an issue</li> <li>Read the API docs</li> </ul>"},{"location":"pypi-publishing/","title":"\ud83d\udce6 AgentiCraft PyPI Publishing Guide","text":"<p>This guide walks through publishing AgentiCraft to PyPI.</p>"},{"location":"pypi-publishing/#prerequisites","title":"Prerequisites","text":"<ol> <li>PyPI Accounts</li> <li>Create account at https://pypi.org</li> <li>Create account at https://test.pypi.org</li> <li> <p>Enable 2FA (recommended)</p> </li> <li> <p>API Tokens</p> </li> <li>Go to Account Settings \u2192 API tokens</li> <li>Create tokens with \"Upload packages\" scope</li> <li> <p>Save tokens securely</p> </li> <li> <p>Configure ~/.pypirc <pre><code>[distutils]\nindex-servers =\n    pypi\n    testpypi\n\n[pypi]\nusername = __token__\npassword = pypi-YOUR-TOKEN-HERE\n\n[testpypi]\nusername = __token__\npassword = pypi-YOUR-TEST-TOKEN-HERE\n</code></pre></p> </li> </ol> <p>Then secure it: <code>chmod 600 ~/.pypirc</code></p>"},{"location":"pypi-publishing/#publishing-steps","title":"Publishing Steps","text":""},{"location":"pypi-publishing/#1-pre-publish-check","title":"1. Pre-publish Check","text":"<pre><code>cd ~/Desktop/TLV/agenticraft\npython scripts/pre_publish_check.py\n</code></pre>"},{"location":"pypi-publishing/#2-build-package","title":"2. Build Package","text":"<pre><code>chmod +x scripts/build_package.sh\n./scripts/build_package.sh\n</code></pre> <p>This will: - Clean previous builds - Install build tools - Build the package - Verify the build - Test local installation</p>"},{"location":"pypi-publishing/#3-upload-to-testpypi","title":"3. Upload to TestPyPI","text":"<pre><code># Upload to TestPyPI\ntwine upload --repository testpypi dist/*\n\n# You'll see output like:\n# Uploading distributions to https://test.pypi.org/legacy/\n# Uploading agenticraft-0.1.1-py3-none-any.whl\n# Uploading agenticraft-0.1.1.tar.gz\n</code></pre>"},{"location":"pypi-publishing/#4-test-from-testpypi","title":"4. Test from TestPyPI","text":"<pre><code># Create a test environment\npython -m venv test_pypi_env\nsource test_pypi_env/bin/activate\n\n# Install from TestPyPI\npip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ agenticraft==0.1.1\n\n# Test the installation\npython scripts/test_installation.py\n\n# Clean up\ndeactivate\nrm -rf test_pypi_env\n</code></pre>"},{"location":"pypi-publishing/#5-upload-to-pypi-production","title":"5. Upload to PyPI (Production)","text":"<pre><code># Only after TestPyPI verification!\ntwine upload dist/*\n\n# You'll see:\n# Uploading distributions to https://upload.pypi.org/legacy/\n# Uploading agenticraft-0.1.1-py3-none-any.whl\n# Uploading agenticraft-0.1.1.tar.gz\n</code></pre>"},{"location":"pypi-publishing/#6-verify-on-pypi","title":"6. Verify on PyPI","text":"<ol> <li>Visit https://pypi.org/project/agenticraft/</li> <li>Check that all metadata looks correct</li> <li>Test installation: <code>pip install agenticraft==0.1.1</code></li> </ol>"},{"location":"pypi-publishing/#post-publish-tasks","title":"Post-publish Tasks","text":"<ol> <li> <p>Update GitHub Release <pre><code>git tag -a v0.1.1 -m \"Release v0.1.1: Anthropic/Ollama providers\"\ngit push origin v0.1.1\n</code></pre></p> </li> <li> <p>Create GitHub Release</p> </li> <li>Go to https://github.com/agenticraft/agenticraft/releases</li> <li>Click \"Create a new release\"</li> <li>Select the v0.1.1 tag</li> <li> <p>Add release notes from CHANGELOG.md</p> </li> <li> <p>Announce the Release</p> </li> <li>Update project website</li> <li>Post on social media</li> <li>Notify early users</li> </ol>"},{"location":"pypi-publishing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"pypi-publishing/#invalid-distribution-file","title":"\"Invalid distribution file\"","text":"<ul> <li>Check that version numbers match everywhere</li> <li>Ensure no pycache in package</li> <li>Rebuild with clean directory</li> </ul>"},{"location":"pypi-publishing/#package-already-exists","title":"\"Package already exists\"","text":"<ul> <li>You can't overwrite PyPI packages</li> <li>Bump version number and rebuild</li> <li>Delete from TestPyPI (allowed there)</li> </ul>"},{"location":"pypi-publishing/#authentication-failed","title":"\"Authentication failed\"","text":"<ul> <li>Check ~/.pypirc formatting</li> <li>Ensure token starts with \"pypi-\"</li> <li>Try with --username token --password pypi-xxx</li> </ul>"},{"location":"pypi-publishing/#version-management","title":"Version Management","text":"<p>After publishing 0.1.1: 1. Update version to 0.1.2-dev in:    - agenticraft/init.py    - pyproject.toml 2. Add new section in CHANGELOG.md 3. Continue development</p>"},{"location":"pypi-publishing/#quick-commands-reference","title":"Quick Commands Reference","text":"<pre><code># Full publish flow\n./scripts/build_package.sh\ntwine upload --repository testpypi dist/*\ntwine upload dist/*\n\n# Check package on PyPI\npip index versions agenticraft\npip show agenticraft\n\n# Install specific version\npip install agenticraft==0.1.1\npip install agenticraft[all]  # With all extras\npip install agenticraft[openai,anthropic]  # Specific providers\n</code></pre>"},{"location":"pypi-publishing/#security-notes","title":"Security Notes","text":"<ul> <li>Never commit .pypirc to git</li> <li>Use API tokens, not passwords</li> <li>Enable 2FA on PyPI account</li> <li>Review package contents before upload</li> <li>Test on TestPyPI first</li> </ul> <p>Remember: You can't unpublish from PyPI, so test thoroughly on TestPyPI first!</p>"},{"location":"quickstart/","title":"5-Minute Quickstart","text":"<p>Get your first AI agent running in less than 5 minutes. No complex setup, no configuration files, just Python.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install agenticraft\n</code></pre> <p>That's it. No additional dependencies to manually install.</p>"},{"location":"quickstart/#your-first-agent","title":"Your First Agent","text":""},{"location":"quickstart/#step-1-set-your-api-key","title":"Step 1: Set Your API Key","text":"<pre><code>export OPENAI_API_KEY=\"your-key-here\"\n</code></pre> <p>Or create a <code>.env</code> file: <pre><code>OPENAI_API_KEY=your-key-here\n</code></pre></p>"},{"location":"quickstart/#step-2-create-your-agent","title":"Step 2: Create Your Agent","text":"<p>Create a file called <code>hello_agent.py</code>:</p> <pre><code>from agenticraft import Agent\n\n# Create a simple agent\nagent = Agent(\n    name=\"Assistant\",\n    instructions=\"You are a helpful AI assistant.\"\n)\n\n# Run the agent\nresponse = agent.run(\"Tell me a fun fact about Python\")\nprint(response.content)\n</code></pre>"},{"location":"quickstart/#step-3-run-it","title":"Step 3: Run It","text":"<pre><code>python hello_agent.py\n</code></pre> <p>Congratulations! \ud83c\udf89 You've just created your first AI agent.</p>"},{"location":"quickstart/#adding-tools","title":"Adding Tools","text":"<p>Let's make your agent more capable by adding tools:</p> <pre><code>from agenticraft import Agent, tool\n\n# Define a simple tool\n@tool\ndef calculate(expression: str) -&gt; float:\n    \"\"\"Safely evaluate a mathematical expression.\"\"\"\n    return eval(expression, {\"__builtins__\": {}}, {})\n\n@tool\ndef get_time() -&gt; str:\n    \"\"\"Get the current time.\"\"\"\n    from datetime import datetime\n    return datetime.now().strftime(\"%I:%M %p\")\n\n# Create an agent with tools\nagent = Agent(\n    name=\"SmartAssistant\",\n    instructions=\"You are a helpful assistant with calculation and time abilities.\",\n    tools=[calculate, get_time]\n)\n\n# The agent will automatically use tools when needed\nresponse = agent.run(\"What's 15% of 847? Also, what time is it?\")\nprint(response.content)\n</code></pre>"},{"location":"quickstart/#understanding-agent-reasoning","title":"Understanding Agent Reasoning","text":"<p>One of AgentiCraft's core features is transparent reasoning:</p> <pre><code>response = agent.run(\"Help me plan a birthday party for 20 people\")\n\n# See what the agent is thinking\nprint(\"=== Agent's Reasoning ===\")\nprint(response.reasoning)\n\nprint(\"\\n=== Final Response ===\")\nprint(response.content)\n</code></pre>"},{"location":"quickstart/#creating-a-simple-workflow","title":"Creating a Simple Workflow","text":"<p>Chain multiple agents together:</p> <pre><code>from agenticraft import Agent, Workflow, Step\n\n# Create specialized agents\nresearcher = Agent(\n    name=\"Researcher\",\n    instructions=\"You research topics thoroughly and provide detailed information.\"\n)\n\nwriter = Agent(\n    name=\"Writer\", \n    instructions=\"You write engaging content based on research.\"\n)\n\n# Create a workflow\nworkflow = Workflow(name=\"content_creation\")\n\n# Add steps - no complex graphs needed!\nworkflow.add_steps([\n    Step(\"research\", agent=researcher, inputs=[\"topic\"]),\n    Step(\"write\", agent=writer, depends_on=[\"research\"])\n])\n\n# Run the workflow\nresult = await workflow.run(topic=\"The future of AI agents\")\nprint(result[\"write\"])\n</code></pre>"},{"location":"quickstart/#memory-for-conversational-agents","title":"Memory for Conversational Agents","text":"<p>Make your agents remember context:</p> <pre><code>from agenticraft import Agent, ConversationMemory\n\nagent = Agent(\n    name=\"ChatBot\",\n    instructions=\"You are a friendly conversational AI.\",\n    memory=[ConversationMemory(max_turns=10)]\n)\n\n# First interaction\nresponse1 = agent.run(\"My name is Alice\")\nprint(response1.content)\n\n# The agent remembers!\nresponse2 = agent.run(\"What's my name?\")\nprint(response2.content)  # Will correctly recall \"Alice\"\n</code></pre>"},{"location":"quickstart/#using-different-llm-providers","title":"Using Different LLM Providers","text":"<p>AgentiCraft supports multiple providers:</p> <pre><code># OpenAI (default)\nagent = Agent(name=\"GPT4\", model=\"gpt-4\")\n\n# Anthropic Claude\nagent = Agent(name=\"Claude\", model=\"claude-3-opus\", api_key=\"anthropic-key\")\n\n# Google Gemini\nagent = Agent(name=\"Gemini\", model=\"gemini-pro\", api_key=\"google-key\")\n\n# Local Ollama\nagent = Agent(name=\"Local\", model=\"ollama/llama2\", base_url=\"http://localhost:11434\")\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>You've learned the basics! Here's what to explore next:</p>"},{"location":"quickstart/#learn-more","title":"Learn More","text":"<ul> <li>Core Concepts - Understand how agents work</li> <li>Building Tools - Create powerful agent capabilities</li> <li>Designing Workflows - Build complex systems</li> </ul>"},{"location":"quickstart/#see-examples","title":"See Examples","text":"<ul> <li>Chatbot Example - Build a full conversational agent</li> <li>Data Pipeline - Process data with agent workflows</li> <li>MCP Integration - Use Model Context Protocol tools</li> </ul>"},{"location":"quickstart/#production-ready","title":"Production Ready","text":"<ul> <li>Observability Guide - Monitor your agents</li> <li>Production Templates - Start from proven patterns</li> <li>Best Practices - Deploy with confidence</li> </ul>"},{"location":"quickstart/#quick-tips","title":"Quick Tips","text":"<p>Environment Variables</p> <p>Create a <code>.env</code> file in your project root to manage API keys: <pre><code>OPENAI_API_KEY=sk-...\nANTHROPIC_API_KEY=sk-ant-...\n</code></pre></p> <p>Async Support</p> <p>All agent operations support async/await: <pre><code>response = await agent.arun(\"Your prompt\")\n</code></pre></p> <p>Error Handling</p> <p>AgentiCraft provides clear error messages: <pre><code>try:\n    response = agent.run(\"Do something\")\nexcept AgentError as e:\n    print(f\"Agent error: {e}\")\n</code></pre></p>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcac Join our Discord</li> <li>\ud83d\udc1b Report issues on GitHub</li> <li>\ud83d\udcda Read the full documentation</li> </ul> <p>Ready for more? Check out our comprehensive examples or dive into the API reference.</p>"},{"location":"workflow/","title":"Workflow Module Documentation","text":""},{"location":"workflow/#overview","title":"Overview","text":"<p>The AgentiCraft workflow module provides a simple, step-based approach to chaining agents and tools together. Unlike complex graph-based workflow engines, AgentiCraft uses a straightforward dependency system that's easy to understand and debug.</p>"},{"location":"workflow/#key-concepts","title":"Key Concepts","text":""},{"location":"workflow/#steps","title":"Steps","text":"<p>Steps are the building blocks of workflows. Each step: - Has a unique name - Executes with either an Agent or a Tool (not both) - Can depend on other steps - Supports retry logic and timeouts - Passes outputs to dependent steps</p>"},{"location":"workflow/#workflows","title":"Workflows","text":"<p>Workflows orchestrate the execution of steps: - Execute steps in dependency order (topological sort) - Handle data passing between steps - Provide error handling and retry logic - Return comprehensive results</p>"},{"location":"workflow/#basic-usage","title":"Basic Usage","text":"<pre><code>from agenticraft import Workflow, Step, Agent, tool\n\n# Create agents\nresearcher = Agent(name=\"Researcher\", model=\"gpt-4\")\nwriter = Agent(name=\"Writer\", model=\"gpt-4\")\n\n# Create workflow\nworkflow = Workflow(\"content_pipeline\")\n\n# Add steps\nworkflow.add_steps([\n    Step(\"research\", agent=researcher, inputs={\"topic\": \"AI safety\"}),\n    Step(\"outline\", agent=writer, depends_on=[\"research\"]),\n    Step(\"write\", agent=writer, depends_on=[\"outline\"])\n])\n\n# Run workflow\nresult = await workflow.run()\n\n# Access results\nresearch_output = result[\"research\"]\nfinal_article = result[\"write\"]\n</code></pre>"},{"location":"workflow/#advanced-features","title":"Advanced Features","text":""},{"location":"workflow/#input-references","title":"Input References","text":"<p>Use <code>$</code> syntax to reference values from context:</p> <pre><code>workflow.add_steps([\n    Step(\"load\", tool=load_data, inputs={\"path\": \"$input_file\"}),\n    Step(\"process\", agent=processor, inputs={\"data\": \"$load\"})\n])\n\nresult = await workflow.run(input_file=\"data.csv\")\n</code></pre>"},{"location":"workflow/#error-handling-retries","title":"Error Handling &amp; Retries","text":"<pre><code>Step(\n    \"api_call\",\n    tool=external_api,\n    retry_count=3,      # Retry up to 3 times\n    timeout=30          # 30 second timeout\n)\n</code></pre>"},{"location":"workflow/#workflow-visualization","title":"Workflow Visualization","text":"<pre><code>print(workflow.visualize())\n# Output:\n# Workflow: content_pipeline\n# ========================\n# 1. research (agent)\n# 2. outline (agent) &lt;- research\n# 3. write (agent) &lt;- outline\n</code></pre>"},{"location":"workflow/#workflow-patterns","title":"Workflow Patterns","text":""},{"location":"workflow/#sequential-pipeline","title":"Sequential Pipeline","text":"<pre><code>workflow.add_steps([\n    Step(\"extract\", tool=extract_data),\n    Step(\"transform\", agent=transformer, depends_on=[\"extract\"]),\n    Step(\"load\", tool=save_data, depends_on=[\"transform\"])\n])\n</code></pre>"},{"location":"workflow/#parallel-processing","title":"Parallel Processing","text":"<pre><code>workflow.add_steps([\n    Step(\"fetch_data\", tool=fetch),\n    Step(\"analyze_1\", agent=analyst1, depends_on=[\"fetch_data\"]),\n    Step(\"analyze_2\", agent=analyst2, depends_on=[\"fetch_data\"]),\n    Step(\"combine\", agent=aggregator, depends_on=[\"analyze_1\", \"analyze_2\"])\n])\n</code></pre>"},{"location":"workflow/#conditional-execution","title":"Conditional Execution","text":"<pre><code># Use agent logic to conditionally process\n@tool\nasync def check_condition(data: dict) -&gt; bool:\n    return data.get(\"requires_processing\", False)\n\nworkflow.add_steps([\n    Step(\"check\", tool=check_condition, inputs={\"data\": \"$input\"}),\n    Step(\"process\", agent=processor, depends_on=[\"check\"])\n])\n</code></pre>"},{"location":"workflow/#api-reference","title":"API Reference","text":""},{"location":"workflow/#workflow-class","title":"Workflow Class","text":""},{"location":"workflow/#constructor","title":"Constructor","text":"<pre><code>Workflow(name: str, description: Optional[str] = None)\n</code></pre>"},{"location":"workflow/#methods","title":"Methods","text":"<ul> <li><code>add_step(step: Step)</code> - Add a single step</li> <li><code>add_steps(steps: List[Step])</code> - Add multiple steps</li> <li><code>run(**inputs) -&gt; WorkflowResult</code> - Execute the workflow</li> <li><code>visualize() -&gt; str</code> - Get text visualization</li> </ul>"},{"location":"workflow/#step-class","title":"Step Class","text":""},{"location":"workflow/#constructor_1","title":"Constructor","text":"<pre><code>Step(\n    name: str,\n    agent: Optional[Agent] = None,\n    tool: Optional[BaseTool] = None,\n    inputs: Dict[str, Any] = {},\n    depends_on: List[str] = [],\n    retry_count: int = 0,\n    timeout: Optional[int] = None\n)\n</code></pre>"},{"location":"workflow/#workflowresult-class","title":"WorkflowResult Class","text":""},{"location":"workflow/#attributes","title":"Attributes","text":"<ul> <li><code>workflow_id: str</code> - Unique workflow execution ID</li> <li><code>workflow_name: str</code> - Name of the workflow</li> <li><code>success: bool</code> - Overall success status</li> <li><code>steps: Dict[str, StepResult]</code> - Results from each step</li> <li><code>started_at: datetime</code> - Workflow start time</li> <li><code>completed_at: datetime</code> - Workflow completion time</li> </ul>"},{"location":"workflow/#methods_1","title":"Methods","text":"<ul> <li><code>result[\"step_name\"]</code> - Get output from specific step</li> </ul>"},{"location":"workflow/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Steps Focused: Each step should do one thing well</li> <li>Use Clear Naming: Step names should describe what they do</li> <li>Handle Errors Gracefully: Use retry_count for unreliable operations</li> <li>Pass Minimal Data: Large data should be referenced, not passed</li> <li>Document Dependencies: Make it clear why steps depend on each other</li> </ol>"},{"location":"workflow/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Circular Dependencies: The workflow engine will detect and report these</li> <li>Missing Dependencies: Referencing non-existent steps will fail validation</li> <li>Type Mismatches: Ensure tool/agent inputs match expected types</li> <li>Timeout Issues: Set appropriate timeouts for long-running operations</li> </ol>"},{"location":"workflow/#integration-with-other-components","title":"Integration with Other Components","text":""},{"location":"workflow/#with-tools","title":"With Tools","text":"<pre><code>@tool\ndef process_data(data: str) -&gt; dict:\n    return {\"processed\": data.upper()}\n\nStep(\"process\", tool=process_data)\n</code></pre>"},{"location":"workflow/#with-memory","title":"With Memory","text":"<pre><code># Agents in workflows maintain their memory\nagent = Agent(name=\"Assistant\", memory=ConversationMemory())\nStep(\"chat\", agent=agent)\n</code></pre>"},{"location":"workflow/#with-plugins","title":"With Plugins","text":"<pre><code># Plugins enhance agents before workflow execution\nregistry.register(LoggingPlugin())\nStep(\"logged_step\", agent=enhanced_agent)\n</code></pre>"},{"location":"workflow/#examples","title":"Examples","text":"<p>See the <code>examples/workflows/</code> directory for complete examples: - <code>simple_workflow.py</code> - Basic sequential workflow - <code>research_workflow.py</code> - Multi-agent research pipeline - <code>data_pipeline.py</code> - ETL workflow with tools - <code>retry_workflow.py</code> - Error handling and retries</p>"},{"location":"concepts/agents/","title":"Agents","text":"<p>Agents are the core building blocks of AgentiCraft. An agent is an AI-powered entity that can reason, use tools, and maintain memory.</p>"},{"location":"concepts/agents/#what-is-an-agent","title":"What is an Agent?","text":"<p>An agent in AgentiCraft consists of:</p> <ul> <li>Identity: Name and instructions that define its purpose</li> <li>Reasoning: Transparent thought processes</li> <li>Tools: Capabilities it can use</li> <li>Memory: Context it maintains</li> <li>Provider: The LLM that powers it</li> </ul>"},{"location":"concepts/agents/#creating-agents","title":"Creating Agents","text":""},{"location":"concepts/agents/#basic-agent","title":"Basic Agent","text":"<pre><code>from agenticraft import Agent\n\nagent = Agent(\n    name=\"Assistant\",\n    instructions=\"You are a helpful AI assistant.\"\n)\n</code></pre>"},{"location":"concepts/agents/#agent-with-tools","title":"Agent with Tools","text":"<pre><code>from agenticraft import Agent, tool\n\n@tool\ndef search(query: str) -&gt; str:\n    \"\"\"Search for information.\"\"\"\n    # Implementation here\n    return f\"Results for: {query}\"\n\nagent = Agent(\n    name=\"Researcher\",\n    instructions=\"You help with research tasks.\",\n    tools=[search]\n)\n</code></pre>"},{"location":"concepts/agents/#agent-with-memory","title":"Agent with Memory","text":"<pre><code>from agenticraft import Agent, ConversationMemory\n\nagent = Agent(\n    name=\"ChatBot\",\n    instructions=\"You are a conversational assistant.\",\n    memory=[ConversationMemory(max_turns=10)]\n)\n</code></pre>"},{"location":"concepts/agents/#agent-configuration","title":"Agent Configuration","text":"<pre><code>agent = Agent(\n    name=\"Advanced\",\n    model=\"gpt-4\",\n    temperature=0.7,\n    max_tokens=2000,\n    timeout=30,\n    max_retries=3\n)\n</code></pre>"},{"location":"concepts/agents/#using-agents","title":"Using Agents","text":""},{"location":"concepts/agents/#synchronous-usage","title":"Synchronous Usage","text":"<pre><code>response = agent.run(\"Your prompt here\")\nprint(response.content)\nprint(response.reasoning)\n</code></pre>"},{"location":"concepts/agents/#asynchronous-usage","title":"Asynchronous Usage","text":"<pre><code>response = await agent.arun(\"Your prompt here\")\n</code></pre>"},{"location":"concepts/agents/#understanding-agent-responses","title":"Understanding Agent Responses","text":"<p>Every agent response includes:</p> <ul> <li><code>content</code>: The final response</li> <li><code>reasoning</code>: The thought process</li> <li><code>tool_calls</code>: Any tools used</li> <li><code>usage</code>: Token usage information</li> </ul>"},{"location":"concepts/agents/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Instructions: Be specific about the agent's role</li> <li>Appropriate Tools: Only include necessary tools</li> <li>Memory Management: Use memory judiciously</li> <li>Error Handling: Always handle potential errors</li> </ol>"},{"location":"concepts/agents/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Tools</li> <li>Explore Workflows</li> <li>Understand Memory</li> </ul>"},{"location":"features/provider_switching/","title":"Provider Switching Guide","text":""},{"location":"features/provider_switching/#overview","title":"Overview","text":"<p>AgentiCraft v0.1.1 introduces dynamic provider switching, allowing agents to seamlessly switch between different LLM providers (OpenAI, Anthropic, Ollama) at runtime. This feature enables:</p> <ul> <li>Cost optimization by using appropriate models for different tasks</li> <li>Failover resilience with automatic fallback to alternative providers</li> <li>Model comparison for evaluating different LLMs on the same task</li> <li>Local/cloud flexibility by switching between cloud APIs and local models</li> </ul>"},{"location":"features/provider_switching/#quick-start","title":"Quick Start","text":"<pre><code>from agenticraft import Agent\n\n# Create an agent\nagent = Agent(name=\"FlexibleAgent\")\n\n# NEW in v0.1.1: Explicit provider specification\nagent = Agent(\n    name=\"ClaudeAgent\",\n    provider=\"anthropic\",  # Explicit provider\n    model=\"claude-3-opus-20240229\"\n)\n\n# Switch to different providers\nagent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\nagent.set_provider(\"ollama\", model=\"llama2\")\nagent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n</code></pre>"},{"location":"features/provider_switching/#available-providers","title":"Available Providers","text":""},{"location":"features/provider_switching/#openai","title":"OpenAI","text":"<ul> <li>Models: <code>gpt-4</code>, <code>gpt-4-turbo</code>, <code>gpt-3.5-turbo</code>, <code>o1-preview</code>, <code>o1-mini</code></li> <li>Features: Function calling, JSON mode, streaming</li> <li>Setup: Requires <code>OPENAI_API_KEY</code> environment variable</li> </ul>"},{"location":"features/provider_switching/#anthropic","title":"Anthropic","text":"<ul> <li>Models: <code>claude-3-opus-20240229</code>, <code>claude-3-sonnet-20240229</code>, <code>claude-3-haiku-20240307</code></li> <li>Features: Large context window, constitutional AI</li> <li>Setup: Requires <code>ANTHROPIC_API_KEY</code> environment variable</li> </ul>"},{"location":"features/provider_switching/#ollama-local","title":"Ollama (Local)","text":"<ul> <li>Models: <code>llama2</code>, <code>mistral</code>, <code>codellama</code>, <code>gemma</code>, <code>phi</code>, and more</li> <li>Features: Local inference, no API costs, privacy</li> <li>Setup: Requires Ollama running locally (<code>ollama serve</code>)</li> </ul>"},{"location":"features/provider_switching/#basic-usage","title":"Basic Usage","text":""},{"location":"features/provider_switching/#simple-provider-switching","title":"Simple Provider Switching","text":"<pre><code>from agenticraft import Agent\n\n# Method 1: Auto-detection from model name (backward compatible)\nagent = Agent(\n    name=\"Assistant\",\n    model=\"gpt-4\",  # Auto-detects OpenAI\n    instructions=\"You are a helpful AI assistant.\"\n)\n\n# Method 2: Explicit provider specification (NEW in v0.1.1)\nagent = Agent(\n    name=\"Assistant\",\n    provider=\"openai\",  # Explicit provider\n    model=\"gpt-4\",\n    instructions=\"You are a helpful AI assistant.\"\n)\n\n# Benefits of explicit provider:\n# - No ambiguity about which provider is used\n# - Works with custom model names\n# - Better for configuration files\n# - Clearer intent in code\n\n# Get current provider info\ninfo = agent.get_provider_info()\nprint(f\"Current provider: {info['provider']}\")\nprint(f\"Model: {info['model']}\")\n\n# Switch to Anthropic\nagent.set_provider(\"anthropic\", model=\"claude-3-sonnet-20240229\")\n\n# Switch to local Ollama\nagent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n\n# List available providers\nproviders = agent.list_available_providers()\nprint(f\"Available providers: {providers}\")\n</code></pre>"},{"location":"features/provider_switching/#with-error-handling","title":"With Error Handling","text":"<pre><code>from agenticraft.core.exceptions import ProviderError\n\ntry:\n    agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\nexcept ProviderError as e:\n    print(f\"Failed to switch provider: {e}\")\n    # Fallback to another provider\n    agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n</code></pre>"},{"location":"features/provider_switching/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"features/provider_switching/#cost-optimized-agent","title":"Cost-Optimized Agent","text":"<p>Use different models based on task complexity:</p> <pre><code>class SmartAgent:\n    def __init__(self):\n        self.agent = Agent(name=\"SmartAgent\")\n\n    def estimate_complexity(self, prompt: str) -&gt; str:\n        # Simple heuristic\n        if len(prompt.split()) &gt; 50 or \"analyze\" in prompt.lower():\n            return \"high\"\n        elif len(prompt.split()) &lt; 10:\n            return \"low\"\n        return \"medium\"\n\n    async def run(self, prompt: str) -&gt; str:\n        complexity = self.estimate_complexity(prompt)\n\n        if complexity == \"high\":\n            self.agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n        elif complexity == \"low\":\n            self.agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n        else:\n            self.agent.set_provider(\"openai\", model=\"gpt-4\")\n\n        response = await self.agent.arun(prompt)\n        return response.content\n</code></pre>"},{"location":"features/provider_switching/#resilient-agent-with-failover","title":"Resilient Agent with Failover","text":"<p>Automatically failover to backup providers:</p> <pre><code>class ResilientAgent:\n    def __init__(self):\n        self.agent = Agent(name=\"ResilientAgent\")\n        self.providers = [\n            (\"openai\", \"gpt-4\"),\n            (\"anthropic\", \"claude-3-sonnet-20240229\"),\n            (\"ollama\", \"llama2\"),\n        ]\n\n    async def run(self, prompt: str) -&gt; str:\n        for provider, model in self.providers:\n            try:\n                self.agent.set_provider(provider, model=model)\n                response = await self.agent.arun(prompt)\n                return response.content\n            except Exception as e:\n                print(f\"Provider {provider} failed: {e}\")\n                continue\n\n        raise Exception(\"All providers failed\")\n</code></pre>"},{"location":"features/provider_switching/#model-comparison","title":"Model Comparison","text":"<p>Compare responses from different models:</p> <pre><code>async def compare_models(prompt: str):\n    agent = Agent(name=\"Comparator\")\n    models = [\n        (\"openai\", \"gpt-4\"),\n        (\"anthropic\", \"claude-3-opus-20240229\"),\n        (\"ollama\", \"llama2\"),\n    ]\n\n    results = {}\n    for provider, model in models:\n        try:\n            agent.set_provider(provider, model=model)\n            response = await agent.arun(prompt)\n            results[f\"{provider}/{model}\"] = response.content\n        except Exception as e:\n            results[f\"{provider}/{model}\"] = f\"Error: {e}\"\n\n    return results\n</code></pre>"},{"location":"features/provider_switching/#provider-specific-features","title":"Provider-Specific Features","text":""},{"location":"features/provider_switching/#openai_1","title":"OpenAI","text":"<pre><code># JSON response format\nresponse = await agent.arun(\n    \"List 3 colors\",\n    response_format={\"type\": \"json_object\"}\n)\n\n# Streaming (when implemented)\nasync for chunk in agent.astream(\"Tell me a story\"):\n    print(chunk, end=\"\")\n</code></pre>"},{"location":"features/provider_switching/#anthropic_1","title":"Anthropic","text":"<pre><code># Anthropic handles system messages differently\nagent.config.instructions = \"You are Claude, created by Anthropic.\"\nagent.set_provider(\"anthropic\")\n\n# Larger context window\nresponse = await agent.arun(very_long_prompt)  # Up to 200k tokens\n</code></pre>"},{"location":"features/provider_switching/#ollama","title":"Ollama","text":"<pre><code># Local model with custom parameters\nagent.set_provider(\"ollama\", model=\"llama2\")\n\nresponse = await agent.arun(\n    \"Generate text\",\n    temperature=0.9,\n    seed=42,  # Reproducible generation\n    num_predict=200  # Max tokens\n)\n</code></pre>"},{"location":"features/provider_switching/#configuration-options","title":"Configuration Options","text":""},{"location":"features/provider_switching/#using-provider-parameter","title":"Using Provider Parameter","text":"<p>The <code>provider</code> parameter in AgentConfig allows explicit provider specification:</p> <pre><code># Explicit provider specification\nagent = Agent(\n    name=\"MyAgent\",\n    provider=\"anthropic\",  # Explicit provider\n    model=\"claude-3-opus-20240229\"\n)\n\n# From configuration dictionary\nconfig = {\n    \"name\": \"ConfigAgent\",\n    \"provider\": \"ollama\",\n    \"model\": \"llama2\",\n    \"base_url\": \"http://localhost:11434\",\n    \"temperature\": 0.7\n}\nagent = Agent(**config)\n\n# Provider validation\ntry:\n    agent = Agent(provider=\"invalid_provider\")  # Raises ValueError\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"features/provider_switching/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>import os\n\n# Read from environment\nprovider = os.getenv(\"AGENT_PROVIDER\", \"openai\")\nmodel = os.getenv(\"AGENT_MODEL\", \"gpt-4\")\n\nagent = Agent(\n    name=\"EnvAgent\",\n    provider=provider,\n    model=model\n)\n</code></pre>"},{"location":"features/provider_switching/#whats-preserved-when-switching","title":"What's Preserved When Switching","text":"<p>When you switch providers, the following are preserved:</p> <ul> <li>\u2705 Agent configuration: name, instructions, temperature, max_tokens</li> <li>\u2705 Tools: All registered tools remain available</li> <li>\u2705 Memory: Conversation history and memory stores</li> <li>\u2705 Reasoning patterns: The agent's reasoning approach</li> <li>\u2705 Agent ID: The unique identifier remains the same</li> </ul> <p>What changes:</p> <ul> <li>\u274c Model: Updates to the new provider's model</li> <li>\u274c API credentials: Uses the new provider's credentials</li> <li>\u274c Provider client: A new provider instance is created</li> </ul>"},{"location":"features/provider_switching/#performance-considerations","title":"Performance Considerations","text":""},{"location":"features/provider_switching/#provider-latency","title":"Provider Latency","text":"<p>Typical response times (approximate):</p> <ul> <li>OpenAI GPT-3.5: 0.5-2 seconds</li> <li>OpenAI GPT-4: 2-10 seconds</li> <li>Anthropic Claude: 1-5 seconds</li> <li>Ollama (local): 0.1-5 seconds (depends on hardware)</li> </ul>"},{"location":"features/provider_switching/#switching-overhead","title":"Switching Overhead","text":"<p>Provider switching is lightweight: - Creating new provider instance: ~1ms - Validating credentials: ~10ms - Total switch time: &lt;50ms</p>"},{"location":"features/provider_switching/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Cache provider instances if switching frequently:    <pre><code># Future enhancement - provider pooling\nprovider_pool = {\n    \"openai\": OpenAIProvider(...),\n    \"anthropic\": AnthropicProvider(...)\n}\n</code></pre></p> </li> <li> <p>Use appropriate models for tasks:</p> </li> <li>Simple queries: <code>gpt-3.5-turbo</code>, <code>claude-3-haiku</code></li> <li>Complex reasoning: <code>gpt-4</code>, <code>claude-3-opus</code></li> <li> <p>Local/private: <code>ollama/llama2</code>, <code>ollama/mistral</code></p> </li> <li> <p>Handle provider differences:</p> </li> <li>Test tools with each provider</li> <li>Be aware of token limits</li> <li>Consider response format variations</li> </ol>"},{"location":"features/provider_switching/#troubleshooting","title":"Troubleshooting","text":""},{"location":"features/provider_switching/#common-issues","title":"Common Issues","text":"<p>Provider not found: <pre><code>ProviderError: Unknown provider: xyz\n</code></pre> Solution: Check available providers with <code>agent.list_available_providers()</code></p> <p>Authentication failed: <pre><code>ProviderAuthError: Missing API key for anthropic\n</code></pre> Solution: Set environment variable <code>ANTHROPIC_API_KEY</code></p> <p>Ollama connection failed: <pre><code>ProviderError: Cannot connect to Ollama\n</code></pre> Solution: Ensure Ollama is running: <code>ollama serve</code></p> <p>Model not available: <pre><code>ProviderError: Model 'gpt-5' not found\n</code></pre> Solution: Check supported models for each provider</p>"},{"location":"features/provider_switching/#debug-logging","title":"Debug Logging","text":"<p>Enable debug logging to troubleshoot:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Now provider switches will be logged\nagent.set_provider(\"anthropic\")\n# Logs: \"Agent 'Assistant' switched to anthropic (model: claude-3-opus-20240229)\"\n</code></pre>"},{"location":"features/provider_switching/#future-enhancements","title":"Future Enhancements","text":"<p>Planned improvements for future versions:</p> <ul> <li>Provider pooling: Reuse provider instances</li> <li>Automatic model selection: Choose optimal model based on task</li> <li>Cost tracking: Monitor spending across providers</li> <li>Performance metrics: Compare provider response times</li> <li>Streaming support: Unified streaming interface</li> <li>Provider profiles: Save and load provider configurations</li> </ul>"},{"location":"features/provider_switching/#examples","title":"Examples","text":"<p>See the <code>examples/provider_switching/</code> directory for complete examples:</p> <ul> <li><code>basic_switching.py</code>: Simple provider switching examples</li> <li><code>cost_optimization.py</code>: Optimize costs with smart provider selection</li> <li><code>provider_failover.py</code>: Build resilient agents with automatic failover</li> </ul>"},{"location":"features/provider_switching/#api-reference","title":"API Reference","text":""},{"location":"features/provider_switching/#agentset_provider","title":"Agent.set_provider()","text":"<pre><code>def set_provider(\n    self, \n    provider_name: str,\n    model: Optional[str] = None,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Switch the agent's LLM provider dynamically.\n\n    Args:\n        provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n        model: Optional model override for the new provider\n        api_key: Optional API key for the new provider\n        base_url: Optional base URL (mainly for Ollama)\n        **kwargs: Additional provider-specific parameters\n\n    Raises:\n        ProviderError: If the provider name is invalid or setup fails\n    \"\"\"\n</code></pre>"},{"location":"features/provider_switching/#agentget_provider_info","title":"Agent.get_provider_info()","text":"<pre><code>def get_provider_info(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get information about the current provider.\n\n    Returns:\n        Dict containing provider name, model, and capabilities\n    \"\"\"\n</code></pre>"},{"location":"features/provider_switching/#agentlist_available_providers","title":"Agent.list_available_providers()","text":"<pre><code>def list_available_providers(self) -&gt; List[str]:\n    \"\"\"\n    List available LLM providers.\n\n    Returns:\n        List of provider names that can be used with set_provider\n    \"\"\"\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>pip package manager</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install agenticraft\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/agenticraft/agenticraft.git\ncd agenticraft\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import agenticraft\nprint(agenticraft.__version__)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Configure your environment</li> <li>Create your first agent</li> </ul>"},{"location":"guides/mcp-integration/","title":"MCP Integration Guide","text":"<p>The Model Context Protocol (MCP) allows AgentiCraft agents to use tools from any MCP-compatible server, and expose AgentiCraft tools to other MCP clients.</p>"},{"location":"guides/mcp-integration/#what-is-mcp","title":"What is MCP?","text":"<p>MCP is a standardized protocol for: - Tool discovery and description - Tool execution across different systems - Interoperability between AI frameworks</p>"},{"location":"guides/mcp-integration/#using-mcp-tools-in-agenticraft","title":"Using MCP Tools in AgentiCraft","text":""},{"location":"guides/mcp-integration/#connecting-to-an-mcp-server","title":"Connecting to an MCP Server","text":"<pre><code>from agenticraft import Agent\nfrom agenticraft.protocols.mcp import MCPClient\n\n# Connect to MCP server\nasync with MCPClient(\"ws://localhost:3000\") as mcp:\n    # Get available tools\n    tools = mcp.get_tools()\n\n    # Create agent with MCP tools\n    agent = Agent(\n        name=\"MCPAgent\",\n        tools=tools\n    )\n\n    # Use tools transparently\n    response = await agent.arun(\"Search for Python tutorials\")\n</code></pre>"},{"location":"guides/mcp-integration/#http-based-mcp-server","title":"HTTP-based MCP Server","text":"<pre><code># Connect via HTTP instead of WebSocket\nmcp = MCPClient(\"http://localhost:3000/mcp\")\nawait mcp.connect()\n\n# Use the same way\nagent = Agent(tools=mcp.get_tools())\n</code></pre>"},{"location":"guides/mcp-integration/#discovering-available-tools","title":"Discovering Available Tools","text":"<pre><code># List tool names\nprint(mcp.available_tools)\n\n# Get specific tool\nsearch_tool = mcp.get_tool(\"web_search\")\n\n# Get server info\nprint(mcp.server_info)\n</code></pre>"},{"location":"guides/mcp-integration/#exposing-agenticraft-tools-via-mcp","title":"Exposing AgentiCraft Tools via MCP","text":""},{"location":"guides/mcp-integration/#creating-an-mcp-server","title":"Creating an MCP Server","text":"<pre><code>from agenticraft.protocols.mcp import MCPServer\nfrom agenticraft import tool\n\n# Define tools\n@tool\ndef calculate(expression: str) -&gt; float:\n    \"\"\"Evaluate a mathematical expression.\"\"\"\n    return eval(expression, {\"__builtins__\": {}})\n\n@tool\ndef get_time() -&gt; str:\n    \"\"\"Get current time.\"\"\"\n    from datetime import datetime\n    return datetime.now().isoformat()\n\n# Create MCP server\nserver = MCPServer(\n    name=\"My Tools Server\",\n    version=\"1.0.0\"\n)\n\n# Register tools\nserver.register_tools([calculate, get_time])\n\n# Start WebSocket server\nawait server.start_websocket_server(port=3000)\n</code></pre>"},{"location":"guides/mcp-integration/#http-mode-with-fastapi","title":"HTTP Mode with FastAPI","text":"<pre><code>from fastapi import FastAPI\nimport uvicorn\n\n# Create server\nserver = MCPServer()\nserver.register_tools([calculate, get_time])\n\n# Get FastAPI app\napp = server.create_fastapi_app()\n\n# Run with uvicorn\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"guides/mcp-integration/#advanced-mcp-tools","title":"Advanced MCP Tools","text":""},{"location":"guides/mcp-integration/#mcp-specific-tool-metadata","title":"MCP-Specific Tool Metadata","text":"<pre><code>from agenticraft.protocols.mcp import mcp_tool\n\n@mcp_tool(\n    name=\"weather\",\n    returns={\n        \"type\": \"object\",\n        \"properties\": {\n            \"temperature\": {\"type\": \"number\"},\n            \"conditions\": {\"type\": \"string\"},\n            \"humidity\": {\"type\": \"number\"}\n        }\n    },\n    examples=[\n        {\n            \"input\": {\"city\": \"New York\"},\n            \"output\": {\n                \"temperature\": 72,\n                \"conditions\": \"sunny\",\n                \"humidity\": 65\n            }\n        }\n    ]\n)\ndef get_weather(city: str) -&gt; dict:\n    \"\"\"Get weather information for a city.\"\"\"\n    # Implementation here\n    return {\n        \"temperature\": 72,\n        \"conditions\": \"sunny\",\n        \"humidity\": 65\n    }\n</code></pre>"},{"location":"guides/mcp-integration/#tool-categories","title":"Tool Categories","text":"<pre><code>from agenticraft.protocols.mcp import MCPRegistry\n\n# Get global registry\nregistry = MCPRegistry()\n\n# Register tools with categories\nregistry.register_agenticraft_tool(\n    calculate,\n    category=\"math\"\n)\nregistry.register_agenticraft_tool(\n    get_weather,\n    category=\"data\"\n)\n\n# List by category\nmath_tools = registry.list_tools(category=\"math\")\n</code></pre>"},{"location":"guides/mcp-integration/#mcp-client-configuration","title":"MCP Client Configuration","text":""},{"location":"guides/mcp-integration/#authentication","title":"Authentication","text":"<pre><code># With API key\nmcp = MCPClient(\n    \"wss://api.example.com/mcp\",\n    headers={\"Authorization\": \"Bearer YOUR_KEY\"}\n)\n\n# With custom headers\nmcp = MCPClient(\n    \"https://api.example.com\",\n    headers={\n        \"X-API-Key\": \"YOUR_KEY\",\n        \"X-Client-ID\": \"agenticraft\"\n    }\n)\n</code></pre>"},{"location":"guides/mcp-integration/#timeout-and-retries","title":"Timeout and Retries","text":"<pre><code>mcp = MCPClient(\n    \"ws://localhost:3000\",\n    timeout=60,  # 60 second timeout\n    max_retries=5\n)\n</code></pre>"},{"location":"guides/mcp-integration/#error-handling","title":"Error Handling","text":"<pre><code>from agenticraft.core.exceptions import ToolError\n\ntry:\n    async with MCPClient(\"ws://localhost:3000\") as mcp:\n        result = await mcp.call_tool(\"search\", {\"query\": \"AI\"})\nexcept ToolError as e:\n    print(f\"Tool error: {e}\")\nexcept Exception as e:\n    print(f\"Connection error: {e}\")\n</code></pre>"},{"location":"guides/mcp-integration/#best-practices","title":"Best Practices","text":""},{"location":"guides/mcp-integration/#1-connection-management","title":"1. Connection Management","text":"<p>Always use context managers: <pre><code>async with MCPClient(url) as mcp:\n    # Use MCP\n    pass\n# Connection automatically closed\n</code></pre></p>"},{"location":"guides/mcp-integration/#2-tool-validation","title":"2. Tool Validation","text":"<p>Validate tools before use: <pre><code># Check if tool exists\nif \"web_search\" in mcp.available_tools:\n    tool = mcp.get_tool(\"web_search\")\n</code></pre></p>"},{"location":"guides/mcp-integration/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement retry logic: <pre><code>from tenacity import retry, stop_after_attempt\n\n@retry(stop=stop_after_attempt(3))\nasync def call_with_retry(mcp, tool_name, args):\n    return await mcp.call_tool(tool_name, args)\n</code></pre></p>"},{"location":"guides/mcp-integration/#4-tool-documentation","title":"4. Tool Documentation","text":"<p>Always provide clear descriptions: <pre><code>@mcp_tool(\n    description=\"Search the web for information\",\n    examples=[{\n        \"input\": {\"query\": \"Python tutorials\"},\n        \"output\": [\"Tutorial 1\", \"Tutorial 2\"]\n    }]\n)\ndef search(query: str) -&gt; list:\n    pass\n</code></pre></p>"},{"location":"guides/mcp-integration/#testing-mcp-integration","title":"Testing MCP Integration","text":""},{"location":"guides/mcp-integration/#mock-mcp-server","title":"Mock MCP Server","text":"<pre><code>from agenticraft.protocols.mcp import MCPServer\n\n# Create test server\ntest_server = MCPServer()\n\n@tool\ndef test_tool(input: str) -&gt; str:\n    return f\"Processed: {input}\"\n\ntest_server.register_tool(test_tool)\n\n# Test with client\nasync with MCPClient(\"ws://localhost:3001\") as client:\n    result = await client.call_tool(\"test_tool\", {\"input\": \"test\"})\n    assert result == \"Processed: test\"\n</code></pre>"},{"location":"guides/mcp-integration/#integration-tests","title":"Integration Tests","text":"<pre><code>import pytest\n\n@pytest.mark.asyncio\nasync def test_mcp_integration():\n    # Start server\n    server = MCPServer()\n    server.register_tool(calculate)\n\n    # In real test, run server in background\n    # Here we test the handler directly\n\n    # Create request\n    from agenticraft.protocols.mcp import MCPRequest, MCPMethod\n\n    request = MCPRequest(\n        method=MCPMethod.LIST_TOOLS\n    )\n\n    response = await server.handle_request(request)\n    assert not response.is_error\n    assert len(response.result[\"tools\"]) == 1\n</code></pre>"},{"location":"guides/mcp-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/mcp-integration/#common-issues","title":"Common Issues","text":"<ol> <li>WebSocket connection fails</li> <li>Check if server is running</li> <li>Verify URL format (ws:// or wss://)</li> <li> <p>Check firewall settings</p> </li> <li> <p>Tool not found</p> </li> <li>Refresh tool list: <code>await mcp._discover_tools()</code></li> <li>Check tool name spelling</li> <li> <p>Verify server has tool registered</p> </li> <li> <p>Timeout errors</p> </li> <li>Increase timeout: <code>MCPClient(url, timeout=120)</code></li> <li>Check network latency</li> <li>Verify server processing time</li> </ol>"},{"location":"guides/mcp-integration/#debug-mode","title":"Debug Mode","text":"<p>Enable detailed logging: <pre><code>import logging\n\nlogging.getLogger(\"agenticraft.protocols.mcp\").setLevel(logging.DEBUG)\n</code></pre></p>"},{"location":"guides/mcp-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Explore available MCP servers</li> <li>Learn about creating custom MCP tools</li> <li>See MCP examples</li> </ul>"},{"location":"guides/provider_switching_performance/","title":"Provider Switching Performance Optimization Guide","text":""},{"location":"guides/provider_switching_performance/#overview","title":"Overview","text":"<p>This guide covers performance considerations and optimization strategies for provider switching in AgentiCraft v0.1.1.</p>"},{"location":"guides/provider_switching_performance/#performance-metrics","title":"Performance Metrics","text":""},{"location":"guides/provider_switching_performance/#provider-switching-overhead","title":"Provider Switching Overhead","text":"Operation Time Impact Provider instance creation ~1ms Negligible Credential validation ~10ms Minimal First API call (cold) 100-500ms Noticeable Subsequent API calls Provider-dependent Varies"},{"location":"guides/provider_switching_performance/#provider-response-times","title":"Provider Response Times","text":"Provider Model First Token Full Response Tokens/sec OpenAI GPT-3.5 200-500ms 0.5-2s 50-100 OpenAI GPT-4 500-2000ms 2-10s 20-40 Anthropic Claude-3-Opus 300-1000ms 2-5s 30-60 Anthropic Claude-3-Sonnet 200-500ms 1-3s 40-80 Ollama Llama2 (M1 Mac) 50-200ms 0.5-5s 10-50 Ollama Llama2 (GPU) 10-50ms 0.1-1s 100-500"},{"location":"guides/provider_switching_performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"guides/provider_switching_performance/#1-provider-instance-caching","title":"1. Provider Instance Caching","text":"<p>Currently, AgentiCraft creates a new provider instance on each switch. For frequent switching, implement caching:</p> <pre><code>class CachedProviderAgent(Agent):\n    \"\"\"Agent with provider instance caching.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._provider_cache = {}\n        self._cache_size = 5  # Maximum cached providers\n\n    def set_provider(self, provider_name: str, **kwargs):\n        \"\"\"Set provider with caching.\"\"\"\n        cache_key = f\"{provider_name}:{kwargs.get('model', 'default')}\"\n\n        # Check cache\n        if cache_key in self._provider_cache:\n            self._provider = self._provider_cache[cache_key]\n            self.config.model = kwargs.get('model', self.config.model)\n            return\n\n        # Create new provider\n        super().set_provider(provider_name, **kwargs)\n\n        # Cache it\n        self._provider_cache[cache_key] = self._provider\n\n        # Evict oldest if cache is full\n        if len(self._provider_cache) &gt; self._cache_size:\n            oldest = next(iter(self._provider_cache))\n            del self._provider_cache[oldest]\n</code></pre>"},{"location":"guides/provider_switching_performance/#2-connection-pooling","title":"2. Connection Pooling","text":"<p>For high-throughput applications, use connection pooling:</p> <pre><code>import httpx\n\n# Global connection pools\n_connection_pools = {\n    \"openai\": httpx.AsyncClient(\n        limits=httpx.Limits(max_connections=100, max_keepalive=20),\n        timeout=httpx.Timeout(30.0)\n    ),\n    \"anthropic\": httpx.AsyncClient(\n        limits=httpx.Limits(max_connections=50, max_keepalive=10),\n        timeout=httpx.Timeout(60.0)\n    ),\n}\n\nclass PooledProvider(BaseProvider):\n    \"\"\"Provider using connection pooling.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.client = _connection_pools.get(self.name)\n</code></pre>"},{"location":"guides/provider_switching_performance/#3-parallel-provider-warm-up","title":"3. Parallel Provider Warm-up","text":"<p>Pre-warm providers during initialization:</p> <pre><code>class FastStartAgent(Agent):\n    \"\"\"Agent with pre-warmed providers.\"\"\"\n\n    async def initialize_providers(self, providers: List[Tuple[str, str]]):\n        \"\"\"Pre-warm multiple providers in parallel.\"\"\"\n        import asyncio\n\n        async def warm_provider(provider_name: str, model: str):\n            try:\n                self.set_provider(provider_name, model=model)\n                # Make a minimal request to establish connection\n                await self.arun(\"Hi\", max_tokens=1)\n            except Exception:\n                pass  # Ignore warm-up failures\n\n        # Warm all providers in parallel\n        await asyncio.gather(*[\n            warm_provider(provider, model)\n            for provider, model in providers\n        ])\n\n# Usage\nagent = FastStartAgent()\nawait agent.initialize_providers([\n    (\"openai\", \"gpt-3.5-turbo\"),\n    (\"anthropic\", \"claude-3-sonnet-20240229\"),\n    (\"ollama\", \"llama2\")\n])\n</code></pre>"},{"location":"guides/provider_switching_performance/#4-smart-model-selection","title":"4. Smart Model Selection","text":"<p>Choose models based on task requirements:</p> <pre><code>class PerformanceOptimizedAgent:\n    \"\"\"Agent that selects models for optimal performance.\"\"\"\n\n    # Model performance profiles\n    MODEL_PROFILES = {\n        # (provider, model): (latency_ms, tokens_per_sec, cost_per_1k)\n        (\"openai\", \"gpt-3.5-turbo\"): (500, 75, 0.002),\n        (\"openai\", \"gpt-4\"): (2000, 30, 0.03),\n        (\"anthropic\", \"claude-3-haiku-20240307\"): (300, 100, 0.00025),\n        (\"anthropic\", \"claude-3-sonnet-20240229\"): (1000, 60, 0.003),\n        (\"ollama\", \"llama2\"): (100, 30, 0),\n    }\n\n    def select_optimal_model(\n        self,\n        max_latency_ms: int = 5000,\n        min_quality_score: float = 0.7,\n        max_cost_per_1k: float = 0.01\n    ) -&gt; Tuple[str, str]:\n        \"\"\"Select optimal model based on constraints.\"\"\"\n        candidates = []\n\n        for (provider, model), (latency, tps, cost) in self.MODEL_PROFILES.items():\n            if (latency &lt;= max_latency_ms and cost &lt;= max_cost_per_1k):\n                # Simple quality score (you'd want a better metric)\n                quality = 0.5 if \"3.5\" in model or \"llama\" in model else 0.9\n                if quality &gt;= min_quality_score:\n                    candidates.append((provider, model, latency, cost))\n\n        # Sort by latency (or implement more complex scoring)\n        candidates.sort(key=lambda x: x[2])\n\n        if candidates:\n            return candidates[0][0], candidates[0][1]\n        return \"openai\", \"gpt-3.5-turbo\"  # Default fallback\n</code></pre>"},{"location":"guides/provider_switching_performance/#5-response-caching","title":"5. Response Caching","text":"<p>Cache responses for identical queries:</p> <pre><code>from functools import lru_cache\nimport hashlib\n\nclass CachedAgent(Agent):\n    \"\"\"Agent with response caching.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._response_cache = {}\n        self._cache_ttl = 3600  # 1 hour\n\n    def _get_cache_key(self, prompt: str, provider: str, model: str) -&gt; str:\n        \"\"\"Generate cache key for prompt.\"\"\"\n        content = f\"{provider}:{model}:{prompt}\"\n        return hashlib.md5(content.encode()).hexdigest()\n\n    async def arun(self, prompt: str, **kwargs) -&gt; AgentResponse:\n        \"\"\"Run with caching.\"\"\"\n        # Check if caching is appropriate\n        if kwargs.get(\"temperature\", 0.7) &gt; 0.1:\n            # Don't cache non-deterministic responses\n            return await super().arun(prompt, **kwargs)\n\n        # Check cache\n        provider_name = self.provider.__class__.__name__.lower().replace(\"provider\", \"\")\n        cache_key = self._get_cache_key(prompt, provider_name, self.config.model)\n\n        if cache_key in self._response_cache:\n            cached = self._response_cache[cache_key]\n            if time.time() - cached[\"timestamp\"] &lt; self._cache_ttl:\n                return cached[\"response\"]\n\n        # Get fresh response\n        response = await super().arun(prompt, **kwargs)\n\n        # Cache it\n        self._response_cache[cache_key] = {\n            \"response\": response,\n            \"timestamp\": time.time()\n        }\n\n        return response\n</code></pre>"},{"location":"guides/provider_switching_performance/#6-batch-processing","title":"6. Batch Processing","text":"<p>Process multiple requests efficiently:</p> <pre><code>class BatchProcessingAgent(Agent):\n    \"\"\"Agent optimized for batch processing.\"\"\"\n\n    async def arun_batch(\n        self,\n        prompts: List[str],\n        max_concurrent: int = 5\n    ) -&gt; List[AgentResponse]:\n        \"\"\"Process multiple prompts concurrently.\"\"\"\n        import asyncio\n\n        semaphore = asyncio.Semaphore(max_concurrent)\n\n        async def process_one(prompt: str) -&gt; AgentResponse:\n            async with semaphore:\n                return await self.arun(prompt)\n\n        # Process all prompts concurrently with rate limiting\n        responses = await asyncio.gather(*[\n            process_one(prompt) for prompt in prompts\n        ])\n\n        return responses\n\n# Usage\nagent = BatchProcessingAgent()\nprompts = [\"Question 1\", \"Question 2\", \"Question 3\", ...]\nresponses = await agent.arun_batch(prompts, max_concurrent=3)\n</code></pre>"},{"location":"guides/provider_switching_performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"guides/provider_switching_performance/#basic-metrics-collection","title":"Basic Metrics Collection","text":"<pre><code>import time\nfrom dataclasses import dataclass\nfrom typing import Dict, List\n\n@dataclass\nclass PerformanceMetrics:\n    provider: str\n    model: str\n    prompt_tokens: int\n    completion_tokens: int\n    latency_ms: float\n    first_token_ms: float\n    success: bool\n\nclass MonitoredAgent(Agent):\n    \"\"\"Agent with performance monitoring.\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.metrics: List[PerformanceMetrics] = []\n\n    async def arun(self, prompt: str, **kwargs) -&gt; AgentResponse:\n        \"\"\"Run with performance monitoring.\"\"\"\n        start_time = time.perf_counter()\n        first_token_time = None\n\n        try:\n            # For streaming responses (future)\n            if kwargs.get(\"stream\"):\n                # Track time to first token\n                pass\n\n            response = await super().arun(prompt, **kwargs)\n\n            # Record metrics\n            latency = (time.perf_counter() - start_time) * 1000\n\n            metrics = PerformanceMetrics(\n                provider=self.provider.__class__.__name__,\n                model=self.config.model,\n                prompt_tokens=response.metadata.get(\"usage\", {}).get(\"prompt_tokens\", 0),\n                completion_tokens=response.metadata.get(\"usage\", {}).get(\"completion_tokens\", 0),\n                latency_ms=latency,\n                first_token_ms=first_token_time or latency,\n                success=True\n            )\n\n            self.metrics.append(metrics)\n            return response\n\n        except Exception as e:\n            # Record failure\n            latency = (time.perf_counter() - start_time) * 1000\n            metrics = PerformanceMetrics(\n                provider=self.provider.__class__.__name__,\n                model=self.config.model,\n                prompt_tokens=0,\n                completion_tokens=0,\n                latency_ms=latency,\n                first_token_ms=latency,\n                success=False\n            )\n            self.metrics.append(metrics)\n            raise\n\n    def get_performance_summary(self) -&gt; Dict[str, Any]:\n        \"\"\"Get performance summary statistics.\"\"\"\n        if not self.metrics:\n            return {}\n\n        by_provider = {}\n        for metric in self.metrics:\n            key = f\"{metric.provider}/{metric.model}\"\n            if key not in by_provider:\n                by_provider[key] = {\n                    \"count\": 0,\n                    \"success_count\": 0,\n                    \"total_latency\": 0,\n                    \"total_tokens\": 0,\n                    \"latencies\": []\n                }\n\n            stats = by_provider[key]\n            stats[\"count\"] += 1\n            if metric.success:\n                stats[\"success_count\"] += 1\n            stats[\"total_latency\"] += metric.latency_ms\n            stats[\"total_tokens\"] += metric.prompt_tokens + metric.completion_tokens\n            stats[\"latencies\"].append(metric.latency_ms)\n\n        # Calculate statistics\n        summary = {}\n        for key, stats in by_provider.items():\n            latencies = sorted(stats[\"latencies\"])\n            summary[key] = {\n                \"requests\": stats[\"count\"],\n                \"success_rate\": stats[\"success_count\"] / stats[\"count\"],\n                \"avg_latency_ms\": stats[\"total_latency\"] / stats[\"count\"],\n                \"p50_latency_ms\": latencies[len(latencies) // 2] if latencies else 0,\n                \"p95_latency_ms\": latencies[int(len(latencies) * 0.95)] if latencies else 0,\n                \"total_tokens\": stats[\"total_tokens\"],\n                \"tokens_per_request\": stats[\"total_tokens\"] / stats[\"count\"]\n            }\n\n        return summary\n</code></pre>"},{"location":"guides/provider_switching_performance/#opentelemetry-integration","title":"OpenTelemetry Integration","text":"<pre><code>from opentelemetry import trace\nfrom opentelemetry.trace import Status, StatusCode\n\ntracer = trace.get_tracer(__name__)\n\nclass TelemetryAgent(Agent):\n    \"\"\"Agent with OpenTelemetry integration.\"\"\"\n\n    async def arun(self, prompt: str, **kwargs) -&gt; AgentResponse:\n        \"\"\"Run with distributed tracing.\"\"\"\n        provider_name = self.provider.__class__.__name__\n\n        with tracer.start_as_current_span(\n            \"agent.run\",\n            attributes={\n                \"agent.name\": self.name,\n                \"provider.name\": provider_name,\n                \"model.name\": self.config.model,\n                \"prompt.length\": len(prompt),\n            }\n        ) as span:\n            try:\n                response = await super().arun(prompt, **kwargs)\n\n                # Add response attributes\n                span.set_attributes({\n                    \"response.length\": len(response.content),\n                    \"tokens.prompt\": response.metadata.get(\"usage\", {}).get(\"prompt_tokens\", 0),\n                    \"tokens.completion\": response.metadata.get(\"usage\", {}).get(\"completion_tokens\", 0),\n                })\n\n                span.set_status(Status(StatusCode.OK))\n                return response\n\n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n                raise\n</code></pre>"},{"location":"guides/provider_switching_performance/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Cache Provider Instances for frequently used configurations</li> <li>Use Connection Pooling for high-throughput applications  </li> <li>Pre-warm Providers during initialization</li> <li>Select Models Intelligently based on task requirements</li> <li>Implement Response Caching for deterministic queries</li> <li>Process in Batches when handling multiple requests</li> <li>Monitor Performance to identify bottlenecks</li> <li>Use Distributed Tracing for production debugging</li> </ol>"},{"location":"guides/provider_switching_performance/#benchmarking-script","title":"Benchmarking Script","text":"<pre><code># benchmark_providers.py\nimport asyncio\nimport time\nfrom statistics import mean, stdev\n\nfrom agenticraft import Agent\n\nasync def benchmark_provider(provider: str, model: str, prompts: List[str]) -&gt; Dict:\n    \"\"\"Benchmark a specific provider/model combination.\"\"\"\n    agent = Agent()\n    agent.set_provider(provider, model=model)\n\n    latencies = []\n    errors = 0\n\n    for prompt in prompts:\n        try:\n            start = time.perf_counter()\n            await agent.arun(prompt)\n            latency = (time.perf_counter() - start) * 1000\n            latencies.append(latency)\n        except Exception:\n            errors += 1\n\n    return {\n        \"provider\": provider,\n        \"model\": model,\n        \"requests\": len(prompts),\n        \"errors\": errors,\n        \"avg_latency_ms\": mean(latencies) if latencies else 0,\n        \"std_dev_ms\": stdev(latencies) if len(latencies) &gt; 1 else 0,\n        \"min_latency_ms\": min(latencies) if latencies else 0,\n        \"max_latency_ms\": max(latencies) if latencies else 0,\n    }\n\n# Run benchmarks\nasync def main():\n    test_prompts = [\n        \"What is 2+2?\",\n        \"Explain quantum computing in one sentence\",\n        \"Write a haiku about programming\",\n    ]\n\n    configurations = [\n        (\"openai\", \"gpt-3.5-turbo\"),\n        (\"openai\", \"gpt-4\"),\n        (\"anthropic\", \"claude-3-sonnet-20240229\"),\n        (\"ollama\", \"llama2\"),\n    ]\n\n    results = []\n    for provider, model in configurations:\n        try:\n            result = await benchmark_provider(provider, model, test_prompts)\n            results.append(result)\n            print(f\"{provider}/{model}: {result['avg_latency_ms']:.0f}ms avg\")\n        except Exception as e:\n            print(f\"{provider}/{model}: Failed - {e}\")\n\n    return results\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This completes the performance optimization guide for provider switching in AgentiCraft v0.1.1.</p>"},{"location":"implementation/advanced_agents_complete/","title":"Advanced Agents Implementation Summary","text":""},{"location":"implementation/advanced_agents_complete/#overview","title":"Overview","text":"<p>AgentiCraft v0.1.1 introduces two powerful specialized agents that extend the base Agent class with advanced capabilities:</p> <ol> <li>ReasoningAgent - Transparent, step-by-step reasoning</li> <li>WorkflowAgent - Multi-step workflow orchestration</li> </ol> <p>Both agents are fully implemented, tested, and documented.</p>"},{"location":"implementation/advanced_agents_complete/#reasoningagent","title":"ReasoningAgent","text":""},{"location":"implementation/advanced_agents_complete/#purpose","title":"Purpose","text":"<p>ReasoningAgent makes AI thinking transparent by exposing its step-by-step reasoning process. This is ideal for: - Educational applications - Debugging and problem-solving - Building trust through transparency - Complex analysis requiring multiple perspectives</p>"},{"location":"implementation/advanced_agents_complete/#key-features","title":"Key Features","text":"<ol> <li>Step-by-Step Reasoning</li> <li>Automatically prompts for detailed thinking</li> <li>Parses and structures reasoning steps</li> <li> <p>Provides both raw and formatted output</p> </li> <li> <p>Multi-Perspective Analysis</p> </li> <li>Analyze topics from multiple viewpoints</li> <li>Configurable perspectives</li> <li> <p>Automatic synthesis of insights</p> </li> <li> <p>Reasoning History</p> </li> <li>Tracks all reasoning sessions</li> <li>Allows retrospective analysis</li> <li>Explainable AI capabilities</li> </ol>"},{"location":"implementation/advanced_agents_complete/#implementation-details","title":"Implementation Details","text":"<ul> <li>Location: <code>/agenticraft/agents/reasoning.py</code></li> <li>Lines of Code: ~400</li> <li>Test Coverage: 15 test methods</li> <li>Key Classes:</li> <li><code>ReasoningAgent</code> - Main agent class</li> <li><code>ReasoningResponse</code> - Enhanced response with reasoning details</li> <li><code>ReasoningStepDetail</code> - Individual reasoning step</li> <li><code>AnalysisResponse</code> - Multi-perspective analysis results</li> </ul>"},{"location":"implementation/advanced_agents_complete/#example-usage","title":"Example Usage","text":"<pre><code>from agenticraft.agents import ReasoningAgent\n\n# Create a reasoning agent\ntutor = ReasoningAgent(\n    name=\"MathTutor\",\n    instructions=\"You are a patient math tutor.\"\n)\n\n# Get step-by-step solution\nresponse = await tutor.think_and_act(\n    \"How do I solve 2x + 5 = 13?\"\n)\n\n# Access reasoning steps\nfor step in response.reasoning_steps:\n    print(f\"{step.number}. {step.description}\")\n    if step.conclusion:\n        print(f\"   \u2192 {step.conclusion}\")\n\n# Multi-perspective analysis\nanalysis = await tutor.analyze(\n    \"Should we implement this feature?\",\n    perspectives=[\"technical\", \"business\", \"user\"]\n)\n</code></pre>"},{"location":"implementation/advanced_agents_complete/#workflowagent","title":"WorkflowAgent","text":""},{"location":"implementation/advanced_agents_complete/#purpose_1","title":"Purpose","text":"<p>WorkflowAgent orchestrates complex multi-step processes with dependencies, parallel execution, and conditional logic. Perfect for: - Data processing pipelines - Business process automation - Task orchestration - Complex workflows with branching logic</p>"},{"location":"implementation/advanced_agents_complete/#key-features_1","title":"Key Features","text":"<ol> <li>Workflow Definition</li> <li>Declarative step definition</li> <li>Dependency management</li> <li> <p>Parallel execution support</p> </li> <li> <p>Conditional Logic</p> </li> <li>Steps can have conditions</li> <li>Dynamic workflow paths</li> <li> <p>Context-based decisions</p> </li> <li> <p>Error Handling</p> </li> <li>Retry mechanisms</li> <li>Timeout support</li> <li> <p>Graceful failure handling</p> </li> <li> <p>Custom Handlers</p> </li> <li>Register custom step handlers</li> <li>Async and sync support</li> <li>Full agent context access</li> </ol>"},{"location":"implementation/advanced_agents_complete/#implementation-details_1","title":"Implementation Details","text":"<ul> <li>Location: <code>/agenticraft/agents/workflow.py</code></li> <li>Lines of Code: ~600</li> <li>Test Coverage: 20 test methods</li> <li>Key Classes:</li> <li><code>WorkflowAgent</code> - Main agent class</li> <li><code>Workflow</code> - Workflow definition</li> <li><code>WorkflowStep</code> - Individual workflow step</li> <li><code>WorkflowResult</code> - Execution results</li> <li><code>StepStatus</code> - Step execution status enum</li> </ul>"},{"location":"implementation/advanced_agents_complete/#example-usage_1","title":"Example Usage","text":"<pre><code>from agenticraft.agents import WorkflowAgent\n\n# Create workflow agent\nagent = WorkflowAgent(name=\"DataProcessor\")\n\n# Define workflow\nworkflow = agent.create_workflow(\"data_pipeline\")\n\n# Add steps with dependencies\nworkflow.add_step(\"fetch\", \"Fetch data from API\")\nworkflow.add_step(\"validate\", \"Validate data\", depends_on=[\"fetch\"])\nworkflow.add_step(\"transform\", \"Transform data\", depends_on=[\"validate\"])\nworkflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n# Execute workflow\nresult = await agent.execute_workflow(workflow)\n\n# Check results\nprint(result.format_summary())\nfor step_name, step_result in result.step_results.items():\n    print(f\"{step_name}: {step_result.status}\")\n</code></pre>"},{"location":"implementation/advanced_agents_complete/#testing","title":"Testing","text":"<p>Both agents have comprehensive test coverage:</p>"},{"location":"implementation/advanced_agents_complete/#reasoningagent-tests-test_reasoning_agentpy","title":"ReasoningAgent Tests (<code>test_reasoning_agent.py</code>)","text":"<ul> <li>Initialization and configuration</li> <li>Step-by-step reasoning parsing</li> <li>Multi-perspective analysis</li> <li>Reasoning history tracking</li> <li>Response formatting</li> </ul>"},{"location":"implementation/advanced_agents_complete/#workflowagent-tests-test_workflow_agentpy","title":"WorkflowAgent Tests (<code>test_workflow_agent.py</code>)","text":"<ul> <li>Workflow creation and validation</li> <li>Sequential execution</li> <li>Parallel execution</li> <li>Conditional steps</li> <li>Error handling and timeouts</li> <li>Custom handlers</li> </ul>"},{"location":"implementation/advanced_agents_complete/#examples","title":"Examples","text":"<p>Created detailed example scripts:</p> <ol> <li><code>reasoning_agent_example.py</code></li> <li>Math tutoring with step-by-step solutions</li> <li>Multi-perspective policy analysis</li> <li> <p>Code debugging with reasoning traces</p> </li> <li> <p><code>workflow_agent_example.py</code></p> </li> <li>Data processing pipeline</li> <li>Parallel content generation</li> <li>Conditional approval workflow</li> <li>Error handling demonstration</li> </ol>"},{"location":"implementation/advanced_agents_complete/#integration","title":"Integration","text":"<p>Both agents integrate seamlessly with existing AgentiCraft features:</p> <ul> <li>Provider Switching: Works with all LLM providers</li> <li>Tools: Full tool support for enhanced capabilities</li> <li>Memory: Conversation and context preservation</li> <li>Base Agent Features: All standard agent capabilities</li> </ul>"},{"location":"implementation/advanced_agents_complete/#benefits","title":"Benefits","text":""},{"location":"implementation/advanced_agents_complete/#reasoningagent-benefits","title":"ReasoningAgent Benefits","text":"<ul> <li>Transparency: See exactly how the AI thinks</li> <li>Education: Perfect for teaching and learning</li> <li>Trust: Build confidence through explainability</li> <li>Debugging: Understand complex problem-solving</li> </ul>"},{"location":"implementation/advanced_agents_complete/#workflowagent-benefits","title":"WorkflowAgent Benefits","text":"<ul> <li>Automation: Complex processes made simple</li> <li>Efficiency: Parallel execution saves time</li> <li>Flexibility: Conditional logic for dynamic workflows</li> <li>Reliability: Built-in error handling</li> </ul>"},{"location":"implementation/advanced_agents_complete/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for v0.2.0: - Workflow templates and reusable components - Visual workflow builder - More sophisticated reasoning patterns - Integration with external workflow systems - Advanced retry strategies - Workflow versioning and history</p>"},{"location":"implementation/advanced_agents_complete/#conclusion","title":"Conclusion","text":"<p>The ReasoningAgent and WorkflowAgent implementations are complete and ready for v0.1.1. They provide powerful new capabilities while maintaining the simplicity and elegance of the AgentiCraft framework. With comprehensive tests and examples, users can immediately start building more transparent and sophisticated AI applications.</p>"},{"location":"implementation/provider_implementation_complete/","title":"Provider Implementation Summary","text":""},{"location":"implementation/provider_implementation_complete/#great-news-all-providers-are-complete","title":"\ud83c\udf89 Great News: All Providers Are Complete!","text":"<p>All three LLM providers for AgentiCraft v0.1.1 are fully implemented and tested:</p>"},{"location":"implementation/provider_implementation_complete/#openai-provider-agenticraftprovidersopenaipy","title":"\u2705 OpenAI Provider (<code>agenticraft/providers/openai.py</code>)","text":"<ul> <li>Lines of Code: ~180</li> <li>Status: Complete with comprehensive tests</li> <li>Features:</li> <li>Full async/await support</li> <li>Native tool/function calling</li> <li>Proper error handling</li> <li>Token usage tracking</li> <li>Support for all OpenAI models</li> </ul>"},{"location":"implementation/provider_implementation_complete/#anthropic-provider-agenticraftprovidersanthropicpy","title":"\u2705 Anthropic Provider (<code>agenticraft/providers/anthropic.py</code>)","text":"<ul> <li>Lines of Code: ~250</li> <li>Status: Complete with comprehensive tests</li> <li>Features:</li> <li>Claude 3 model support (Opus, Sonnet, Haiku)</li> <li>System message extraction (Anthropic pattern)</li> <li>Native tool calling support</li> <li>Token usage tracking</li> <li>Proper error handling and retries</li> </ul>"},{"location":"implementation/provider_implementation_complete/#ollama-provider-agenticraftprovidersollamapy","title":"\u2705 Ollama Provider (<code>agenticraft/providers/ollama.py</code>)","text":"<ul> <li>Lines of Code: ~400</li> <li>Status: Complete with comprehensive tests</li> <li>Features:</li> <li>Local model execution</li> <li>No API key required</li> <li>Model management (list, pull)</li> <li>Tool simulation via prompts</li> <li>Custom server configuration</li> <li>Detailed error messages for common issues</li> </ul>"},{"location":"implementation/provider_implementation_complete/#test-coverage","title":"Test Coverage","text":"<p>Each provider has comprehensive unit tests:</p>"},{"location":"implementation/provider_implementation_complete/#testsunitproviderstest_openaipy","title":"<code>tests/unit/providers/test_openai.py</code>","text":"<ul> <li>17 test methods</li> <li>Covers initialization, completion, tools, errors</li> </ul>"},{"location":"implementation/provider_implementation_complete/#testsunitproviderstest_anthropicpy","title":"<code>tests/unit/providers/test_anthropic.py</code>","text":"<ul> <li>19 test methods</li> <li>Covers system messages, tool conversion, all edge cases</li> </ul>"},{"location":"implementation/provider_implementation_complete/#testsunitproviderstest_ollamapy","title":"<code>tests/unit/providers/test_ollama.py</code>","text":"<ul> <li>23 test methods</li> <li>Covers local execution, model management, connection handling</li> </ul>"},{"location":"implementation/provider_implementation_complete/#provider-factory-integration","title":"Provider Factory Integration","text":"<p>The <code>ProviderFactory</code> correctly handles all providers:</p> <pre><code># Auto-detection works\nProviderFactory.create(\"gpt-4\")                    # \u2192 OpenAIProvider\nProviderFactory.create(\"claude-3-opus-20240229\")   # \u2192 AnthropicProvider\nProviderFactory.create(\"llama2\")                   # \u2192 OllamaProvider\n\n# Explicit provider specification works\nProviderFactory.create(\"gpt-4\", provider=\"openai\")\nProviderFactory.create(\"custom-model\", provider=\"ollama\")\n</code></pre>"},{"location":"implementation/provider_implementation_complete/#key-implementation-details","title":"Key Implementation Details","text":""},{"location":"implementation/provider_implementation_complete/#1-consistent-interface","title":"1. Consistent Interface","text":"<p>All providers implement the same <code>BaseProvider</code> interface: - <code>async def complete(...) -&gt; CompletionResponse</code> - <code>def validate_auth() -&gt; None</code></p>"},{"location":"implementation/provider_implementation_complete/#2-error-handling","title":"2. Error Handling","text":"<p>Each provider has specific error handling: - OpenAI: API key validation, rate limits - Anthropic: API key validation, response parsing - Ollama: Connection errors, model availability</p>"},{"location":"implementation/provider_implementation_complete/#3-tool-support","title":"3. Tool Support","text":"<ul> <li>OpenAI: Native function calling</li> <li>Anthropic: Native tool use with format conversion</li> <li>Ollama: Tool simulation via system prompts</li> </ul>"},{"location":"implementation/provider_implementation_complete/#4-authentication","title":"4. Authentication","text":"<ul> <li>OpenAI: Requires <code>OPENAI_API_KEY</code></li> <li>Anthropic: Requires <code>ANTHROPIC_API_KEY</code></li> <li>Ollama: No authentication (local)</li> </ul>"},{"location":"implementation/provider_implementation_complete/#usage-examples","title":"Usage Examples","text":"<p>All providers work identically from the user's perspective:</p> <pre><code>from agenticraft import Agent\n\n# Create agents with different providers\nopenai_agent = Agent(model=\"gpt-4\")\nclaude_agent = Agent(model=\"claude-3-opus-20240229\")\nlocal_agent = Agent(model=\"ollama/llama2\")\n\n# All use the same interface\nresponse = await agent.arun(\"Hello!\")\nprint(response.content)\n\n# Provider switching works seamlessly\nagent.set_provider(\"anthropic\", model=\"claude-3-sonnet-20240229\")\n</code></pre>"},{"location":"implementation/provider_implementation_complete/#what-this-means-for-v011","title":"What This Means for v0.1.1","text":"<p>With all providers implemented: - \u2705 Core provider switching is complete - \u2705 All three providers are ready - \u2705 Comprehensive test coverage exists - \u2705 Examples and documentation are ready</p> <p>The only remaining work for v0.1.1 is: 1. Advanced agents (ReasoningAgent, WorkflowAgent) 2. PyPI packaging 3. Documentation website 4. Final release preparation</p>"},{"location":"implementation/provider_implementation_complete/#conclusion","title":"Conclusion","text":"<p>The provider implementation work that was estimated to take 2 days is already complete! This puts the v0.1.1 release ahead of schedule. The provider switching feature is fully functional and ready for users.</p>"},{"location":"implementation/provider_parameter_summary/","title":"AgentConfig Provider Parameter Implementation Summary","text":""},{"location":"implementation/provider_parameter_summary/#overview","title":"Overview","text":"<p>The <code>provider</code> parameter has been added to AgentConfig in v0.1.1, allowing explicit specification of which LLM provider to use. This enhancement provides better control and clarity while maintaining backward compatibility.</p>"},{"location":"implementation/provider_parameter_summary/#implementation-details","title":"Implementation Details","text":""},{"location":"implementation/provider_parameter_summary/#1-agentconfig-changes","title":"1. AgentConfig Changes","text":"<p>Added to <code>agenticraft/core/agent.py</code>:</p> <pre><code>class AgentConfig(BaseModel):\n    # ... existing fields ...\n\n    provider: Optional[str] = Field(\n        default=None,\n        description=\"Explicit provider name (e.g., 'openai', 'anthropic', 'ollama'). If not specified, auto-detected from model name.\"\n    )\n\n    @field_validator('provider')\n    def validate_provider(cls, provider: Optional[str]) -&gt; Optional[str]:\n        \"\"\"Validate provider name if specified.\"\"\"\n        if provider is not None:\n            valid_providers = [\"openai\", \"anthropic\", \"ollama\", \"google\"]\n            if provider not in valid_providers:\n                raise ValueError(\n                    f\"Invalid provider: {provider}. \"\n                    f\"Valid providers are: {', '.join(valid_providers)}\"\n                )\n        return provider\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#2-agent-class-updates","title":"2. Agent Class Updates","text":"<p>The <code>provider</code> property now checks for explicit provider:</p> <pre><code>@property\ndef provider(self) -&gt; BaseProvider:\n    \"\"\"Get or create the LLM provider.\"\"\"\n    if self._provider is None:\n        # Use explicit provider if specified in config\n        if self.config.provider:\n            self._provider = ProviderFactory.create(\n                model=self.config.model,\n                provider=self.config.provider,  # Pass explicit provider\n                api_key=self.config.api_key,\n                base_url=self.config.base_url,\n                timeout=self.config.timeout,\n                max_retries=self.config.max_retries\n            )\n        else:\n            # Auto-detect from model name (existing behavior)\n            self._provider = ProviderFactory.create(\n                model=self.config.model,\n                api_key=self.config.api_key,\n                base_url=self.config.base_url,\n                timeout=self.config.timeout,\n                max_retries=self.config.max_retries\n            )\n    return self._provider\n</code></pre> <p>The <code>set_provider</code> method now updates <code>config.provider</code>:</p> <pre><code># Update configuration\nself.config.model = model\nself.config.provider = provider_name  # NEW: Store explicit provider\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#3-providerfactory-updates","title":"3. ProviderFactory Updates","text":"<p>Add optional <code>provider</code> parameter to <code>create</code> method:</p> <pre><code>@classmethod\ndef create(\n    cls,\n    model: str,\n    provider: Optional[str] = None,  # NEW: Optional explicit provider\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; BaseProvider:\n    \"\"\"Create a provider based on model name or explicit provider.\"\"\"\n    # If explicit provider specified, use it\n    if provider:\n        cls._lazy_load_providers()\n        provider_class = cls._providers.get(provider)\n        if not provider_class:\n            raise ProviderNotFoundError(f\"Unknown provider: {provider}\")\n\n        return provider_class(\n            api_key=api_key,\n            base_url=base_url,\n            model=model,\n            **kwargs\n        )\n\n    # Otherwise, auto-detect from model name (existing logic)\n    # ...\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#benefits","title":"Benefits","text":"<ol> <li>Explicit Control: No ambiguity about which provider is being used</li> <li>Custom Models: Support for custom model names that wouldn't be auto-detected</li> <li>Configuration-Friendly: Better for config files and environment-based setup</li> <li>Clearer Intent: Makes code more readable and self-documenting</li> <li>Backward Compatible: Existing code without provider parameter continues to work</li> </ol>"},{"location":"implementation/provider_parameter_summary/#usage-examples","title":"Usage Examples","text":""},{"location":"implementation/provider_parameter_summary/#basic-usage","title":"Basic Usage","text":"<pre><code># Explicit provider (NEW)\nagent = Agent(\n    name=\"ClaudeAgent\",\n    provider=\"anthropic\",\n    model=\"claude-3-opus-20240229\"\n)\n\n# Auto-detection (still works)\nagent = Agent(\n    name=\"GPTAgent\",\n    model=\"gpt-4\"  # Auto-detects OpenAI\n)\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#configuration-dictionary","title":"Configuration Dictionary","text":"<pre><code>config = {\n    \"name\": \"ConfiguredAgent\",\n    \"provider\": \"ollama\",\n    \"model\": \"custom-model\",\n    \"base_url\": \"http://localhost:11434\"\n}\nagent = Agent(**config)\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#environment-based","title":"Environment-Based","text":"<pre><code>import os\n\nagent = Agent(\n    name=\"EnvAgent\",\n    provider=os.getenv(\"AGENT_PROVIDER\", \"openai\"),\n    model=os.getenv(\"AGENT_MODEL\", \"gpt-4\")\n)\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#with-validation","title":"With Validation","text":"<pre><code>try:\n    agent = Agent(provider=\"invalid_provider\")\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # \"Invalid provider: invalid_provider. Valid providers are: openai, anthropic, ollama, google\"\n</code></pre>"},{"location":"implementation/provider_parameter_summary/#testing","title":"Testing","text":"<p>Created comprehensive unit tests in <code>tests/unit/core/test_agent_config_provider.py</code>:</p> <ul> <li>Provider field validation</li> <li>Auto-detection compatibility</li> <li>Explicit provider priority</li> <li>Configuration serialization</li> <li>Provider switching updates</li> </ul>"},{"location":"implementation/provider_parameter_summary/#documentation-updates","title":"Documentation Updates","text":"<ol> <li>Feature Guide: Updated <code>docs/features/provider_switching.md</code> with provider parameter examples</li> <li>Examples: Created <code>examples/provider_switching/provider_parameter_example.py</code></li> <li>Patch File: Created <code>patches/agent_config_provider.patch</code> for implementation reference</li> </ol>"},{"location":"implementation/provider_parameter_summary/#migration-notes","title":"Migration Notes","text":"<ul> <li>No breaking changes - existing code continues to work</li> <li>The provider parameter is optional and defaults to None (auto-detection)</li> <li>When specified, the provider parameter takes priority over auto-detection</li> <li>The <code>set_provider()</code> method now updates the <code>config.provider</code> field</li> </ul>"},{"location":"implementation/provider_parameter_summary/#status","title":"Status","text":"<p>\u2705 Complete - The provider parameter feature is fully implemented and ready for v0.1.1 release.</p>"},{"location":"migration/v0.1.0_to_v0.1.1/","title":"Migration Guide: v0.1.0 to v0.1.1","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#overview","title":"Overview","text":"<p>AgentiCraft v0.1.1 introduces several new features while maintaining backward compatibility. This guide helps you upgrade smoothly and take advantage of new capabilities.</p>"},{"location":"migration/v0.1.0_to_v0.1.1/#whats-new-in-v011","title":"What's New in v0.1.1","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#major-features","title":"Major Features","text":"<ul> <li>Provider Switching: Dynamically switch between OpenAI, Anthropic, and Ollama</li> <li>New Providers: Anthropic (Claude) and Ollama (local models) support</li> <li>Advanced Agents: ReasoningAgent and WorkflowAgent implementations</li> <li>PyPI Package: Install via <code>pip install agenticraft</code></li> </ul>"},{"location":"migration/v0.1.0_to_v0.1.1/#improvements","title":"Improvements","text":"<ul> <li>Better error handling and provider fallback</li> <li>Enhanced documentation with more examples</li> <li>Performance optimizations</li> <li>Improved test coverage (&gt;95%)</li> </ul>"},{"location":"migration/v0.1.0_to_v0.1.1/#installation","title":"Installation","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#upgrading-from-v010","title":"Upgrading from v0.1.0","text":"<pre><code># If installed from source\ncd agenticraft\ngit pull origin main\npip install -e .\n\n# Once published to PyPI (after June 7, 2025)\npip install --upgrade agenticraft\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#new-installation","title":"New Installation","text":"<pre><code># From PyPI (after June 7, 2025)\npip install agenticraft\n\n# From source\ngit clone https://github.com/agenticraft/agenticraft.git\ncd agenticraft\npip install -e .\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#breaking-changes","title":"Breaking Changes","text":"<p>Good news! There are no breaking changes in v0.1.1. All existing code will continue to work.</p>"},{"location":"migration/v0.1.0_to_v0.1.1/#new-features-usage","title":"New Features Usage","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#1-provider-switching","title":"1. Provider Switching","text":"<p>New in v0.1.1: Switch providers at runtime</p> <pre><code># Existing code still works\nagent = Agent(name=\"MyAgent\", model=\"gpt-4\")\n\n# NEW: Switch providers dynamically\nagent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\nagent.set_provider(\"ollama\", model=\"llama2\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#2-anthropic-provider","title":"2. Anthropic Provider","text":"<p>New in v0.1.1: Use Claude models</p> <pre><code># Before (v0.1.0) - Only OpenAI\nagent = Agent(model=\"gpt-4\")\n\n# After (v0.1.1) - Multiple providers\nagent = Agent(model=\"claude-3-opus-20240229\")  # Auto-detects Anthropic\n# or explicitly\nagent = Agent(provider=\"anthropic\", model=\"claude-3-opus-20240229\")\n</code></pre> <p>Required setup: <pre><code>export ANTHROPIC_API_KEY=\"your-anthropic-api-key\"\n</code></pre></p>"},{"location":"migration/v0.1.0_to_v0.1.1/#3-ollama-provider-local-models","title":"3. Ollama Provider (Local Models)","text":"<p>New in v0.1.1: Run models locally</p> <pre><code># Use local models with Ollama\nagent = Agent(\n    model=\"llama2\",  # Auto-detects Ollama\n    base_url=\"http://localhost:11434\"  # Optional, this is default\n)\n\n# Or use ollama/ prefix\nagent = Agent(model=\"ollama/mistral\")\n</code></pre> <p>Required setup: <pre><code># Install Ollama\ncurl -fsSL https://ollama.com/install.sh | sh\n\n# Start Ollama\nollama serve\n\n# Pull a model\nollama pull llama2\n</code></pre></p>"},{"location":"migration/v0.1.0_to_v0.1.1/#4-reasoningagent","title":"4. ReasoningAgent","text":"<p>New in v0.1.1: Agent with transparent reasoning</p> <pre><code>from agenticraft.agents import ReasoningAgent\n\n# Before (v0.1.0)\nagent = Agent(name=\"Assistant\")\nresponse = agent.run(\"Complex question\")\n# Limited visibility into reasoning\n\n# After (v0.1.1)\nagent = ReasoningAgent(name=\"Assistant\")\nresponse = await agent.think_and_act(\"Complex question\")\n\n# Access detailed reasoning\nprint(f\"Goal: {response.reasoning.goal_analysis}\")\nfor step in response.reasoning.steps:\n    print(f\"Step {step.number}: {step.description}\")\n    print(f\"Confidence: {step.confidence}\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#5-workflowagent","title":"5. WorkflowAgent","text":"<p>New in v0.1.1: Agent optimized for workflows</p> <pre><code>from agenticraft.agents import WorkflowAgent\nfrom agenticraft.workflows import Workflow, Step\n\n# Create workflow\nworkflow = Workflow(\"data_pipeline\")\nworkflow.add_step(\"fetch\", fetch_data_agent)\nworkflow.add_step(\"process\", process_agent, depends_on=[\"fetch\"])\nworkflow.add_step(\"analyze\", analyze_agent, depends_on=[\"process\"])\n\n# Before (v0.1.0) - Manual orchestration\nresults = []\nresults.append(await fetch_data_agent.run())\nresults.append(await process_agent.run(results[0]))\nresults.append(await analyze_agent.run(results[1]))\n\n# After (v0.1.1) - WorkflowAgent\nagent = WorkflowAgent(name=\"Pipeline\")\nagent.add_workflow(workflow)\nresult = await agent.run(\"Execute data pipeline\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#configuration-changes","title":"Configuration Changes","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#environment-variables","title":"Environment Variables","text":"<p>v0.1.1 recognizes additional environment variables:</p> <pre><code># Existing (v0.1.0)\nOPENAI_API_KEY=sk-...\n\n# New in v0.1.1\nANTHROPIC_API_KEY=sk-ant-...\nOLLAMA_BASE_URL=http://localhost:11434  # Optional\n\n# Provider defaults (optional)\nAGENTICRAFT_DEFAULT_PROVIDER=anthropic\nAGENTICRAFT_DEFAULT_MODEL=claude-3-opus-20240229\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#settings-updates","title":"Settings Updates","text":"<pre><code># agenticraft/core/config.py additions\nclass Settings:\n    # Existing settings preserved\n\n    # New in v0.1.1\n    anthropic_api_key: Optional[str] = None\n    ollama_base_url: str = \"http://localhost:11434\"\n    default_provider: str = \"openai\"  # Can be \"anthropic\", \"ollama\"\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#common-migration-scenarios","title":"Common Migration Scenarios","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#scenario-1-add-anthropic-as-fallback","title":"Scenario 1: Add Anthropic as Fallback","text":"<pre><code># Before (v0.1.0)\ntry:\n    response = agent.run(prompt)\nexcept Exception as e:\n    # Manual retry with same provider\n    response = agent.run(prompt)\n\n# After (v0.1.1)\ntry:\n    response = agent.run(prompt)\nexcept Exception as e:\n    # Fallback to different provider\n    agent.set_provider(\"anthropic\")\n    response = agent.run(prompt)\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#scenario-2-use-local-model-for-privacy","title":"Scenario 2: Use Local Model for Privacy","text":"<pre><code># Before (v0.1.0) - Always uses cloud API\nagent = Agent(name=\"PrivateAgent\")\nresponse = agent.run(sensitive_data)  # Sent to OpenAI\n\n# After (v0.1.1) - Keep data local\nagent = Agent(name=\"PrivateAgent\", model=\"ollama/llama2\")\nresponse = agent.run(sensitive_data)  # Processed locally\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#scenario-3-cost-optimization","title":"Scenario 3: Cost Optimization","text":"<pre><code># Before (v0.1.0) - Fixed model\nagent = Agent(model=\"gpt-4\")  # Expensive for all tasks\n\n# After (v0.1.1) - Dynamic model selection\nclass SmartAgent:\n    def __init__(self):\n        self.agent = Agent()\n\n    def run(self, prompt):\n        if self.is_simple(prompt):\n            self.agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n        else:\n            self.agent.set_provider(\"openai\", model=\"gpt-4\")\n        return self.agent.run(prompt)\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#testing-your-code","title":"Testing Your Code","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#running-tests-with-multiple-providers","title":"Running Tests with Multiple Providers","text":"<pre><code># test_my_agent.py\nimport pytest\nfrom agenticraft import Agent\n\n@pytest.mark.parametrize(\"provider,model\", [\n    (\"openai\", \"gpt-3.5-turbo\"),\n    (\"anthropic\", \"claude-3-sonnet-20240229\"),\n    (\"ollama\", \"llama2\"),\n])\ndef test_agent_with_providers(provider, model):\n    \"\"\"Test agent works with different providers.\"\"\"\n    agent = Agent(name=\"TestAgent\")\n\n    try:\n        agent.set_provider(provider, model=model)\n        response = agent.run(\"Hello\")\n        assert response.content\n    except Exception as e:\n        pytest.skip(f\"{provider} not available: {e}\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#performance-considerations","title":"Performance Considerations","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#provider-latency-comparison","title":"Provider Latency Comparison","text":"Provider Model Avg Latency Cost/1K tokens OpenAI GPT-3.5 0.5-2s $0.002 OpenAI GPT-4 2-10s $0.03 Anthropic Claude-3-Opus 2-5s $0.015 Anthropic Claude-3-Sonnet 1-3s $0.003 Ollama Llama2 0.1-5s Free"},{"location":"migration/v0.1.0_to_v0.1.1/#memory-usage","title":"Memory Usage","text":"<ul> <li>v0.1.0: ~100MB base</li> <li>v0.1.1: ~110MB base (+10MB for multi-provider support)</li> <li>With Ollama: Depends on model (1-8GB)</li> </ul>"},{"location":"migration/v0.1.0_to_v0.1.1/#troubleshooting","title":"Troubleshooting","text":""},{"location":"migration/v0.1.0_to_v0.1.1/#issue-unknown-provider-error","title":"Issue: \"Unknown provider\" error","text":"<pre><code># Error\nProviderError: Unknown provider: claude\n\n# Fix - Use correct provider name\nagent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#issue-anthropic-api-key-not-found","title":"Issue: Anthropic API key not found","text":"<pre><code># Error\nProviderAuthError: Missing API key for anthropic\n\n# Fix\nexport ANTHROPIC_API_KEY=\"your-key\"\n# or\nagent = Agent(api_key=\"your-key\", model=\"claude-3-opus-20240229\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#issue-ollama-connection-failed","title":"Issue: Ollama connection failed","text":"<pre><code># Error\nProviderError: Cannot connect to Ollama at localhost:11434\n\n# Fix\n# 1. Start Ollama\nollama serve\n\n# 2. Or specify custom URL\nagent.set_provider(\"ollama\", base_url=\"http://your-server:11434\")\n</code></pre>"},{"location":"migration/v0.1.0_to_v0.1.1/#best-practices-for-v011","title":"Best Practices for v0.1.1","text":"<ol> <li> <p>Use Environment Variables for API keys    <pre><code># .env file\nOPENAI_API_KEY=sk-...\nANTHROPIC_API_KEY=sk-ant-...\n</code></pre></p> </li> <li> <p>Implement Provider Fallback for reliability    <pre><code>providers = [\n    (\"openai\", \"gpt-4\"),\n    (\"anthropic\", \"claude-3-sonnet-20240229\"),\n    (\"ollama\", \"llama2\")\n]\n\nfor provider, model in providers:\n    try:\n        agent.set_provider(provider, model=model)\n        break\n    except ProviderError:\n        continue\n</code></pre></p> </li> <li> <p>Choose Models Wisely for cost/performance</p> </li> <li>Simple tasks: <code>gpt-3.5-turbo</code>, <code>claude-3-haiku</code></li> <li>Complex tasks: <code>gpt-4</code>, <code>claude-3-opus</code></li> <li> <p>Private data: <code>ollama/llama2</code></p> </li> <li> <p>Test with Multiple Providers to ensure compatibility</p> </li> </ol>"},{"location":"migration/v0.1.0_to_v0.1.1/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://docs.agenticraft.ai</li> <li>Examples: See <code>examples/provider_switching/</code></li> <li>Issues: https://github.com/agenticraft/agenticraft/issues</li> <li>Discord: https://discord.gg/agenticraft</li> </ul>"},{"location":"migration/v0.1.0_to_v0.1.1/#summary","title":"Summary","text":"<p>v0.1.1 is a backward-compatible release that adds powerful new features:</p> <ul> <li>\u2705 No breaking changes - existing code continues to work</li> <li>\u2705 Easy provider switching with <code>set_provider()</code></li> <li>\u2705 Support for Anthropic (Claude) and Ollama (local)</li> <li>\u2705 New specialized agents (ReasoningAgent, WorkflowAgent)</li> <li>\u2705 Available on PyPI for easy installation</li> </ul> <p>Upgrade today to access multiple LLM providers and build more resilient, cost-effective agents!</p>"},{"location":"reference/","title":"API Reference","text":"<p>This section contains the complete API reference for AgentiCraft.</p>"},{"location":"reference/#core-components","title":"Core Components","text":"<ul> <li><code>agenticraft.core.agent</code> - Base Agent class and functionality</li> <li><code>agenticraft.core.tool</code> - Tool decorators and abstractions</li> <li><code>agenticraft.core.workflow</code> - Workflow engine</li> <li><code>agenticraft.core.memory</code> - Memory interfaces</li> <li><code>agenticraft.core.reasoning</code> - Reasoning patterns</li> <li><code>agenticraft.core.provider</code> - LLM provider interface</li> </ul>"},{"location":"reference/#subsystems","title":"Subsystems","text":"<ul> <li><code>agenticraft.tools</code> - Built-in tools</li> <li><code>agenticraft.memory</code> - Memory implementations</li> <li><code>agenticraft.providers</code> - LLM provider integrations</li> <li><code>agenticraft.protocols.mcp</code> - Model Context Protocol</li> <li><code>agenticraft.telemetry</code> - Observability components</li> <li><code>agenticraft.plugins</code> - Plugin system</li> </ul>"},{"location":"reference/#cli","title":"CLI","text":"<ul> <li><code>agenticraft.cli</code> - Command-line interface</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Overview</li> <li>Core</li> <li>Agent</li> <li>Tool</li> <li>Workflow</li> <li>Memory</li> <li>Reasoning</li> <li>Provider</li> <li>Exceptions</li> <li>Components</li> <li>Tools</li> <li>Memory</li> <li>Providers</li> <li>MCP</li> <li>Telemetry</li> <li>Plugins</li> <li>CLI</li> </ul>"},{"location":"reference/__init__/","title":"init","text":""},{"location":"reference/__init__/#agenticraft","title":"<code>agenticraft</code>","text":"<p>AgentiCraft: Dead simple AI agents with reasoning traces.</p> <p>A lightweight, production-ready framework for building AI agents with transparent reasoning, MCP protocol support, and comprehensive observability.</p>"},{"location":"reference/__init__/#agenticraft.Agent","title":"<code>Agent</code>","text":"<p>Base Agent class for AgentiCraft.</p> <p>The Agent class is the core abstraction in AgentiCraft. It combines an LLM provider, tools, memory, and reasoning patterns to create an intelligent agent capable of complex tasks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent's name</p> <code>'Agent'</code> <code>instructions</code> <code>str</code> <p>System instructions for the agent</p> <code>'You are a helpful AI assistant.'</code> <code>model</code> <code>str</code> <p>LLM model to use</p> <code>'gpt-4'</code> <code>**kwargs</code> <code>Any</code> <p>Additional configuration options</p> <code>{}</code> Example <p>Creating a simple agent::</p> <pre><code>agent = Agent(\n    name=\"MathTutor\",\n    instructions=\"You are a patient math tutor.\",\n    model=\"gpt-4\"\n)\n</code></pre> <p>Creating an agent with tools::</p> <pre><code>from agenticraft import tool\n\n@tool\ndef calculate(expr: str) -&gt; float:\n    return eval(expr)\n\nagent = Agent(\n    name=\"Calculator\",\n    tools=[calculate]\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>class Agent:\n    \"\"\"Base Agent class for AgentiCraft.\n\n    The Agent class is the core abstraction in AgentiCraft. It combines\n    an LLM provider, tools, memory, and reasoning patterns to create\n    an intelligent agent capable of complex tasks.\n\n    Args:\n        name: The agent's name\n        instructions: System instructions for the agent\n        model: LLM model to use\n        **kwargs: Additional configuration options\n\n    Example:\n        Creating a simple agent::\n\n            agent = Agent(\n                name=\"MathTutor\",\n                instructions=\"You are a patient math tutor.\",\n                model=\"gpt-4\"\n            )\n\n        Creating an agent with tools::\n\n            from agenticraft import tool\n\n            @tool\n            def calculate(expr: str) -&gt; float:\n                return eval(expr)\n\n            agent = Agent(\n                name=\"Calculator\",\n                tools=[calculate]\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Agent\",\n        instructions: str = \"You are a helpful AI assistant.\",\n        model: str = \"gpt-4\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize an Agent.\"\"\"\n        # Create config\n        self.config = AgentConfig(\n            name=name,\n            instructions=instructions,\n            model=model,\n            **kwargs\n        )\n\n        # Generate unique ID\n        self.id = uuid4()\n\n        # Initialize components\n        self._provider: Optional[BaseProvider] = None\n        self._tool_registry = ToolRegistry()\n        self._memory_store = MemoryStore()\n        self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n        # Register tools\n        for tool in self.config.tools:\n            self._tool_registry.register(tool)\n\n        # Initialize memory\n        for memory in self.config.memory:\n            self._memory_store.add_memory(memory)\n\n        # Message history\n        self._messages: List[Message] = []\n\n        logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the agent's name.\"\"\"\n        return self.config.name\n\n    @property\n    def provider(self) -&gt; BaseProvider:\n        \"\"\"Get or create the LLM provider.\"\"\"\n        if self._provider is None:\n            # Use explicit provider if specified in config\n            if self.config.provider:\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    provider=self.config.provider,  # Pass explicit provider\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n            else:\n                # Auto-detect from model name\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n        return self._provider\n\n    def run(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent synchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n\n        Example:\n            Basic usage::\n\n                response = agent.run(\"What's the weather?\")\n                print(response.content)\n\n            With context::\n\n                response = agent.run(\n                    \"Summarize this\",\n                    context={\"document\": \"Long text...\"}\n                )\n        \"\"\"\n        return asyncio.run(self.arun(prompt, context, **kwargs))\n\n    async def arun(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent asynchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n        \"\"\"\n        try:\n            # Start reasoning\n            reasoning_trace = self._reasoning.start_trace(prompt)\n\n            # Add user message\n            user_message = Message(\n                role=MessageRole.USER,\n                content=prompt,\n                metadata={\"context\": context} if context else {}\n            )\n            self._messages.append(user_message)\n\n            # Get memory context\n            memory_context = await self._memory_store.get_context(\n                query=prompt,\n                max_items=10\n            )\n\n            # Build conversation\n            messages = self._build_messages(memory_context, context)\n\n            # Get available tools\n            tools_schema = self._tool_registry.get_tools_schema()\n\n            # Call LLM\n            reasoning_trace.add_step(\"calling_llm\", {\n                \"model\": self.config.model,\n                \"temperature\": self.config.temperature\n            })\n\n            response = await self.provider.complete(\n                messages=messages,\n                tools=tools_schema if tools_schema else None,\n                temperature=self.config.temperature,\n                max_tokens=self.config.max_tokens,\n                **kwargs\n            )\n\n            # Process tool calls if any\n            tool_results = []\n            executed_tool_calls = []  # Track the tool calls we executed\n            if response.tool_calls:\n                executed_tool_calls = response.tool_calls  # Save for later\n                tool_results = await self._execute_tools(\n                    response.tool_calls,\n                    reasoning_trace\n                )\n\n                # If tools were called, we need another LLM call with results\n                if tool_results:\n                    tool_message = Message(\n                        role=MessageRole.ASSISTANT,\n                        content=response.content,\n                        tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                    )\n                    self._messages.append(tool_message)\n\n                    # Add tool results\n                    for result in tool_results:\n                        result_message = Message(\n                            role=MessageRole.TOOL,\n                            content=json.dumps(result.result),\n                            metadata={\"tool_call_id\": result.tool_call_id}\n                        )\n                        messages.append(result_message)\n\n                    # Get final response\n                    response = await self.provider.complete(\n                        messages=messages,\n                        temperature=self.config.temperature,\n                        max_tokens=self.config.max_tokens,\n                        **kwargs\n                    )\n\n            # Add assistant message\n            assistant_message = Message(\n                role=MessageRole.ASSISTANT,\n                content=response.content,\n                metadata=response.metadata\n            )\n            self._messages.append(assistant_message)\n\n            # Store in memory\n            await self._memory_store.store(\n                user_message=user_message,\n                assistant_message=assistant_message\n            )\n\n            # Complete reasoning\n            reasoning_trace.complete({\"response\": response.content})\n\n            # Build response\n            return AgentResponse(\n                content=response.content,\n                reasoning=self._reasoning.format_trace(reasoning_trace),\n                tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n                metadata={\n                    \"model\": self.config.model,\n                    \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                    **response.metadata\n                },\n                agent_id=self.id\n            )\n\n        except Exception as e:\n            logger.error(f\"Agent execution failed: {e}\")\n            raise AgentError(f\"Agent execution failed: {e}\") from e\n\n    def _build_messages(\n        self,\n        memory_context: List[Message],\n        user_context: Optional[Dict[str, Any]] = None\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Build the message list for the LLM.\"\"\"\n        messages = []\n\n        # System message\n        system_content = self.config.instructions\n        if user_context:\n            context_str = \"\\n\".join(\n                f\"{k}: {v}\" for k, v in user_context.items()\n            )\n            system_content += f\"\\n\\nContext:\\n{context_str}\"\n\n        messages.append({\n            \"role\": \"system\",\n            \"content\": system_content\n        })\n\n        # Add memory context\n        for msg in memory_context:\n            messages.append(msg.to_dict())\n\n        # Add recent messages\n        for msg in self._messages[-10:]:  # Last 10 messages\n            messages.append(msg.to_dict())\n\n        return messages\n\n    async def _execute_tools(\n        self,\n        tool_calls: List[ToolCall],\n        reasoning_trace: ReasoningTrace\n    ) -&gt; List[ToolResult]:\n        \"\"\"Execute tool calls.\"\"\"\n        results = []\n\n        for tool_call in tool_calls:\n            reasoning_trace.add_step(\"executing_tool\", {\n                \"tool\": tool_call.name,\n                \"arguments\": tool_call.arguments\n            })\n\n            try:\n                result = await self._tool_registry.execute(\n                    tool_call.name,\n                    **tool_call.arguments\n                )\n\n                results.append(ToolResult(\n                    tool_call_id=tool_call.id,\n                    result=result\n                ))\n\n                reasoning_trace.add_step(\"tool_result\", {\n                    \"tool\": tool_call.name,\n                    \"result\": result\n                })\n\n            except Exception as e:\n                logger.error(f\"Tool execution failed: {e}\")\n                error_result = ToolResult(\n                    tool_call_id=tool_call.id,\n                    result={\"error\": str(e)},\n                    error=str(e)\n                )\n                results.append(error_result)\n\n                reasoning_trace.add_step(\"tool_error\", {\n                    \"tool\": tool_call.name,\n                    \"error\": str(e)\n                })\n\n        return results\n\n    def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n        \"\"\"Add a tool to the agent dynamically.\n\n        Args:\n            tool: Tool instance or callable to add\n\n        Example:\n            Adding a tool after creation::\n\n                @tool\n                def search(query: str) -&gt; str:\n                    return f\"Results for {query}\"\n\n                agent.add_tool(search)\n        \"\"\"\n        self._tool_registry.register(tool)\n        self.config.tools.append(tool)\n\n    def clear_memory(self) -&gt; None:\n        \"\"\"Clear the agent's memory.\"\"\"\n        self._memory_store.clear()\n        self._messages.clear()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the agent.\"\"\"\n        return (\n            f\"Agent(name='{self.name}', \"\n            f\"model='{self.config.model}', \"\n            f\"tools={len(self.config.tools)})\"\n        )\n\n    def set_provider(\n        self, \n        provider_name: str,\n        model: Optional[str] = None,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Switch the agent's LLM provider dynamically.\n\n        This method allows switching between different LLM providers while\n        preserving the agent's configuration, tools, memory, and state.\n\n        Args:\n            provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n            model: Optional model override for the new provider\n            api_key: Optional API key for the new provider\n            base_url: Optional base URL (mainly for Ollama)\n            **kwargs: Additional provider-specific parameters\n\n        Raises:\n            ProviderError: If the provider name is invalid or setup fails\n\n        Example:\n            &gt;&gt;&gt; # Switch to Anthropic\n            &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch to local Ollama\n            &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch back to OpenAI with specific model\n            &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n        Note:\n            When switching providers, the agent will:\n            - Preserve all configuration except model and API settings\n            - Maintain tool registrations and functionality\n            - Keep conversation memory intact\n            - Continue with the same reasoning patterns\n        \"\"\"\n        # Map of provider names to their default models\n        provider_defaults = {\n            \"openai\": \"gpt-4\",\n            \"anthropic\": \"claude-3-opus-20240229\",\n            \"ollama\": \"llama2\"\n        }\n\n        # Validate provider name\n        if provider_name not in provider_defaults:\n            raise ProviderError(\n                f\"Unknown provider: {provider_name}. \"\n                f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n            )\n\n        # Determine model to use\n        if model is None:\n            # If no model specified, use provider default\n            model = provider_defaults[provider_name]\n        else:\n            # For Ollama, strip \"ollama/\" prefix if present\n            if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n                model = model[7:]  # Remove \"ollama/\" prefix\n\n        # Store current state for rollback\n        old_provider = self._provider\n        old_model = self.config.model\n        old_api_key = self.config.api_key\n        old_base_url = self.config.base_url\n\n        try:\n            # Update configuration\n            self.config.model = model\n            self.config.provider = provider_name\n            if api_key is not None:\n                self.config.api_key = api_key\n            if base_url is not None:\n                self.config.base_url = base_url\n\n            # Clear current provider to force recreation\n            self._provider = None\n\n            # Access provider property to trigger creation with new settings\n            new_provider = self.provider\n\n            # Validate the new provider works\n            new_provider.validate_auth()\n\n            logger.info(\n                f\"Agent '{self.name}' switched to {provider_name} \"\n                f\"(model: {model})\"\n            )\n\n        except Exception as e:\n            # Rollback on failure\n            self._provider = old_provider\n            self.config.model = old_model\n            self.config.api_key = old_api_key\n            self.config.base_url = old_base_url\n\n            logger.error(f\"Failed to switch provider: {e}\")\n            raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n\n\n    def get_provider_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get information about the current provider.\n\n        Returns:\n            Dict containing provider name, model, and capabilities\n\n        Example:\n            &gt;&gt;&gt; info = agent.get_provider_info()\n            &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n        \"\"\"\n        provider = self.provider\n        provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n        return {\n            \"provider\": provider_name,\n            \"model\": self.config.model,\n            \"supports_streaming\": hasattr(provider, 'stream'),\n            \"supports_tools\": True,  # All providers support tools via adaptation\n            \"timeout\": self.config.timeout,\n            \"max_retries\": self.config.max_retries,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_tokens\n        }\n\n\n    def list_available_providers(self) -&gt; List[str]:\n        \"\"\"List available LLM providers.\n\n        Returns:\n            List of provider names that can be used with set_provider\n\n        Example:\n            &gt;&gt;&gt; providers = agent.list_available_providers()\n            &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n        \"\"\"\n        # Import here to avoid circular imports\n        from .provider import ProviderFactory\n\n        # Ensure providers are loaded\n        ProviderFactory._lazy_load_providers()\n\n        return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the agent's name.</p>"},{"location":"reference/__init__/#agenticraft.Agent.provider","title":"<code>provider</code>  <code>property</code>","text":"<p>Get or create the LLM provider.</p>"},{"location":"reference/__init__/#agenticraft.Agent.__init__","title":"<code>__init__(name='Agent', instructions='You are a helpful AI assistant.', model='gpt-4', **kwargs)</code>","text":"<p>Initialize an Agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Agent\",\n    instructions: str = \"You are a helpful AI assistant.\",\n    model: str = \"gpt-4\",\n    **kwargs: Any\n):\n    \"\"\"Initialize an Agent.\"\"\"\n    # Create config\n    self.config = AgentConfig(\n        name=name,\n        instructions=instructions,\n        model=model,\n        **kwargs\n    )\n\n    # Generate unique ID\n    self.id = uuid4()\n\n    # Initialize components\n    self._provider: Optional[BaseProvider] = None\n    self._tool_registry = ToolRegistry()\n    self._memory_store = MemoryStore()\n    self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n    # Register tools\n    for tool in self.config.tools:\n        self._tool_registry.register(tool)\n\n    # Initialize memory\n    for memory in self.config.memory:\n        self._memory_store.add_memory(memory)\n\n    # Message history\n    self._messages: List[Message] = []\n\n    logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.run","title":"<code>run(prompt, context=None, **kwargs)</code>","text":"<p>Run the agent synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Example <p>Basic usage::</p> <pre><code>response = agent.run(\"What's the weather?\")\nprint(response.content)\n</code></pre> <p>With context::</p> <pre><code>response = agent.run(\n    \"Summarize this\",\n    context={\"document\": \"Long text...\"}\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def run(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent synchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n\n    Example:\n        Basic usage::\n\n            response = agent.run(\"What's the weather?\")\n            print(response.content)\n\n        With context::\n\n            response = agent.run(\n                \"Summarize this\",\n                context={\"document\": \"Long text...\"}\n            )\n    \"\"\"\n    return asyncio.run(self.arun(prompt, context, **kwargs))\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.arun","title":"<code>arun(prompt, context=None, **kwargs)</code>  <code>async</code>","text":"<p>Run the agent asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>async def arun(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent asynchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n    \"\"\"\n    try:\n        # Start reasoning\n        reasoning_trace = self._reasoning.start_trace(prompt)\n\n        # Add user message\n        user_message = Message(\n            role=MessageRole.USER,\n            content=prompt,\n            metadata={\"context\": context} if context else {}\n        )\n        self._messages.append(user_message)\n\n        # Get memory context\n        memory_context = await self._memory_store.get_context(\n            query=prompt,\n            max_items=10\n        )\n\n        # Build conversation\n        messages = self._build_messages(memory_context, context)\n\n        # Get available tools\n        tools_schema = self._tool_registry.get_tools_schema()\n\n        # Call LLM\n        reasoning_trace.add_step(\"calling_llm\", {\n            \"model\": self.config.model,\n            \"temperature\": self.config.temperature\n        })\n\n        response = await self.provider.complete(\n            messages=messages,\n            tools=tools_schema if tools_schema else None,\n            temperature=self.config.temperature,\n            max_tokens=self.config.max_tokens,\n            **kwargs\n        )\n\n        # Process tool calls if any\n        tool_results = []\n        executed_tool_calls = []  # Track the tool calls we executed\n        if response.tool_calls:\n            executed_tool_calls = response.tool_calls  # Save for later\n            tool_results = await self._execute_tools(\n                response.tool_calls,\n                reasoning_trace\n            )\n\n            # If tools were called, we need another LLM call with results\n            if tool_results:\n                tool_message = Message(\n                    role=MessageRole.ASSISTANT,\n                    content=response.content,\n                    tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                )\n                self._messages.append(tool_message)\n\n                # Add tool results\n                for result in tool_results:\n                    result_message = Message(\n                        role=MessageRole.TOOL,\n                        content=json.dumps(result.result),\n                        metadata={\"tool_call_id\": result.tool_call_id}\n                    )\n                    messages.append(result_message)\n\n                # Get final response\n                response = await self.provider.complete(\n                    messages=messages,\n                    temperature=self.config.temperature,\n                    max_tokens=self.config.max_tokens,\n                    **kwargs\n                )\n\n        # Add assistant message\n        assistant_message = Message(\n            role=MessageRole.ASSISTANT,\n            content=response.content,\n            metadata=response.metadata\n        )\n        self._messages.append(assistant_message)\n\n        # Store in memory\n        await self._memory_store.store(\n            user_message=user_message,\n            assistant_message=assistant_message\n        )\n\n        # Complete reasoning\n        reasoning_trace.complete({\"response\": response.content})\n\n        # Build response\n        return AgentResponse(\n            content=response.content,\n            reasoning=self._reasoning.format_trace(reasoning_trace),\n            tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n            metadata={\n                \"model\": self.config.model,\n                \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                **response.metadata\n            },\n            agent_id=self.id\n        )\n\n    except Exception as e:\n        logger.error(f\"Agent execution failed: {e}\")\n        raise AgentError(f\"Agent execution failed: {e}\") from e\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.add_tool","title":"<code>add_tool(tool)</code>","text":"<p>Add a tool to the agent dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, callable]</code> <p>Tool instance or callable to add</p> required Example <p>Adding a tool after creation::</p> <pre><code>@tool\ndef search(query: str) -&gt; str:\n    return f\"Results for {query}\"\n\nagent.add_tool(search)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n    \"\"\"Add a tool to the agent dynamically.\n\n    Args:\n        tool: Tool instance or callable to add\n\n    Example:\n        Adding a tool after creation::\n\n            @tool\n            def search(query: str) -&gt; str:\n                return f\"Results for {query}\"\n\n            agent.add_tool(search)\n    \"\"\"\n    self._tool_registry.register(tool)\n    self.config.tools.append(tool)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.clear_memory","title":"<code>clear_memory()</code>","text":"<p>Clear the agent's memory.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def clear_memory(self) -&gt; None:\n    \"\"\"Clear the agent's memory.\"\"\"\n    self._memory_store.clear()\n    self._messages.clear()\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the agent.\"\"\"\n    return (\n        f\"Agent(name='{self.name}', \"\n        f\"model='{self.config.model}', \"\n        f\"tools={len(self.config.tools)})\"\n    )\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.set_provider","title":"<code>set_provider(provider_name, model=None, api_key=None, base_url=None, **kwargs)</code>","text":"<p>Switch the agent's LLM provider dynamically.</p> <p>This method allows switching between different LLM providers while preserving the agent's configuration, tools, memory, and state.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Name of the provider (\"openai\", \"anthropic\", \"ollama\")</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override for the new provider</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for the new provider</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL (mainly for Ollama)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters</p> <code>{}</code> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If the provider name is invalid or setup fails</p> Example Note <p>When switching providers, the agent will: - Preserve all configuration except model and API settings - Maintain tool registrations and functionality - Keep conversation memory intact - Continue with the same reasoning patterns</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def set_provider(\n    self, \n    provider_name: str,\n    model: Optional[str] = None,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"Switch the agent's LLM provider dynamically.\n\n    This method allows switching between different LLM providers while\n    preserving the agent's configuration, tools, memory, and state.\n\n    Args:\n        provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n        model: Optional model override for the new provider\n        api_key: Optional API key for the new provider\n        base_url: Optional base URL (mainly for Ollama)\n        **kwargs: Additional provider-specific parameters\n\n    Raises:\n        ProviderError: If the provider name is invalid or setup fails\n\n    Example:\n        &gt;&gt;&gt; # Switch to Anthropic\n        &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch to local Ollama\n        &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch back to OpenAI with specific model\n        &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n    Note:\n        When switching providers, the agent will:\n        - Preserve all configuration except model and API settings\n        - Maintain tool registrations and functionality\n        - Keep conversation memory intact\n        - Continue with the same reasoning patterns\n    \"\"\"\n    # Map of provider names to their default models\n    provider_defaults = {\n        \"openai\": \"gpt-4\",\n        \"anthropic\": \"claude-3-opus-20240229\",\n        \"ollama\": \"llama2\"\n    }\n\n    # Validate provider name\n    if provider_name not in provider_defaults:\n        raise ProviderError(\n            f\"Unknown provider: {provider_name}. \"\n            f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n        )\n\n    # Determine model to use\n    if model is None:\n        # If no model specified, use provider default\n        model = provider_defaults[provider_name]\n    else:\n        # For Ollama, strip \"ollama/\" prefix if present\n        if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n            model = model[7:]  # Remove \"ollama/\" prefix\n\n    # Store current state for rollback\n    old_provider = self._provider\n    old_model = self.config.model\n    old_api_key = self.config.api_key\n    old_base_url = self.config.base_url\n\n    try:\n        # Update configuration\n        self.config.model = model\n        self.config.provider = provider_name\n        if api_key is not None:\n            self.config.api_key = api_key\n        if base_url is not None:\n            self.config.base_url = base_url\n\n        # Clear current provider to force recreation\n        self._provider = None\n\n        # Access provider property to trigger creation with new settings\n        new_provider = self.provider\n\n        # Validate the new provider works\n        new_provider.validate_auth()\n\n        logger.info(\n            f\"Agent '{self.name}' switched to {provider_name} \"\n            f\"(model: {model})\"\n        )\n\n    except Exception as e:\n        # Rollback on failure\n        self._provider = old_provider\n        self.config.model = old_model\n        self.config.api_key = old_api_key\n        self.config.base_url = old_base_url\n\n        logger.error(f\"Failed to switch provider: {e}\")\n        raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.set_provider--switch-to-anthropic","title":"Switch to Anthropic","text":"<p>agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")</p>"},{"location":"reference/__init__/#agenticraft.Agent.set_provider--switch-to-local-ollama","title":"Switch to local Ollama","text":"<p>agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")</p>"},{"location":"reference/__init__/#agenticraft.Agent.set_provider--switch-back-to-openai-with-specific-model","title":"Switch back to OpenAI with specific model","text":"<p>agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")</p>"},{"location":"reference/__init__/#agenticraft.Agent.get_provider_info","title":"<code>get_provider_info()</code>","text":"<p>Get information about the current provider.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing provider name, model, and capabilities</p> Example <p>info = agent.get_provider_info() print(f\"Using {info['provider']} with model {info['model']}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def get_provider_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the current provider.\n\n    Returns:\n        Dict containing provider name, model, and capabilities\n\n    Example:\n        &gt;&gt;&gt; info = agent.get_provider_info()\n        &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n    \"\"\"\n    provider = self.provider\n    provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n    return {\n        \"provider\": provider_name,\n        \"model\": self.config.model,\n        \"supports_streaming\": hasattr(provider, 'stream'),\n        \"supports_tools\": True,  # All providers support tools via adaptation\n        \"timeout\": self.config.timeout,\n        \"max_retries\": self.config.max_retries,\n        \"temperature\": self.config.temperature,\n        \"max_tokens\": self.config.max_tokens\n    }\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Agent.list_available_providers","title":"<code>list_available_providers()</code>","text":"<p>List available LLM providers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of provider names that can be used with set_provider</p> Example <p>providers = agent.list_available_providers() print(f\"Available providers: {', '.join(providers)}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def list_available_providers(self) -&gt; List[str]:\n    \"\"\"List available LLM providers.\n\n    Returns:\n        List of provider names that can be used with set_provider\n\n    Example:\n        &gt;&gt;&gt; providers = agent.list_available_providers()\n        &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n    \"\"\"\n    # Import here to avoid circular imports\n    from .provider import ProviderFactory\n\n    # Ensure providers are loaded\n    ProviderFactory._lazy_load_providers()\n\n    return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool","title":"<code>BaseTool</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all tools.</p> <p>Tools extend agent capabilities by providing specific functions that can be called during agent execution.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class BaseTool(ABC):\n    \"\"\"Base class for all tools.\n\n    Tools extend agent capabilities by providing specific functions\n    that can be called during agent execution.\n    \"\"\"\n\n    def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n        \"\"\"Initialize a tool.\n\n        Args:\n            name: Override the tool name\n            description: Override the tool description\n        \"\"\"\n        # Check if class has a name attribute first\n        if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n            self.name = self.__class__.name\n        else:\n            self.name = name or self.__class__.__name__\n\n        # Check if class has a description attribute first\n        if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n            self.description = self.__class__.description\n        else:\n            self.description = description or self.__class__.__doc__ or \"No description\"\n\n    @abstractmethod\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool asynchronously.\"\"\"\n        pass\n\n    def run(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool synchronously.\"\"\"\n        return asyncio.run(self.arun(**kwargs))\n\n    @abstractmethod\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get the tool definition for LLM providers.\"\"\"\n        pass\n\n    async def __call__(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Make the tool callable.\"\"\"\n        return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool.__init__","title":"<code>__init__(name=None, description=None)</code>","text":"<p>Initialize a tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override the tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override the tool description</p> <code>None</code> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n    \"\"\"Initialize a tool.\n\n    Args:\n        name: Override the tool name\n        description: Override the tool description\n    \"\"\"\n    # Check if class has a name attribute first\n    if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n        self.name = self.__class__.name\n    else:\n        self.name = name or self.__class__.__name__\n\n    # Check if class has a description attribute first\n    if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n        self.description = self.__class__.description\n    else:\n        self.description = description or self.__class__.__doc__ or \"No description\"\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool.arun","title":"<code>arun(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Run the tool asynchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\nasync def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool asynchronously.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool.run","title":"<code>run(**kwargs)</code>","text":"<p>Run the tool synchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool synchronously.\"\"\"\n    return asyncio.run(self.arun(**kwargs))\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool.get_definition","title":"<code>get_definition()</code>  <code>abstractmethod</code>","text":"<p>Get the tool definition for LLM providers.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\ndef get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get the tool definition for LLM providers.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#agenticraft.BaseTool.__call__","title":"<code>__call__(**kwargs)</code>  <code>async</code>","text":"<p>Make the tool callable.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def __call__(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Make the tool callable.\"\"\"\n    return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow","title":"<code>Workflow</code>","text":"<p>Simple step-based workflow engine.</p> <p>Workflows in AgentiCraft use a straightforward dependency system instead of complex graphs. Steps are executed in order based on their dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Workflow name</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> Example <p>Basic workflow::</p> <pre><code>workflow = Workflow(\"analysis_pipeline\")\n\nworkflow.add_step(\n    Step(\"load\", tool=load_data, inputs={\"file\": \"data.csv\"})\n)\nworkflow.add_step(\n    Step(\"analyze\", agent=analyst, depends_on=[\"load\"])\n)\nworkflow.add_step(\n    Step(\"report\", agent=reporter, depends_on=[\"analyze\"])\n)\n\nresult = await workflow.run(file=\"sales.csv\")\n</code></pre> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class Workflow:\n    \"\"\"Simple step-based workflow engine.\n\n    Workflows in AgentiCraft use a straightforward dependency system\n    instead of complex graphs. Steps are executed in order based on\n    their dependencies.\n\n    Args:\n        name: Workflow name\n        description: Optional description\n\n    Example:\n        Basic workflow::\n\n            workflow = Workflow(\"analysis_pipeline\")\n\n            workflow.add_step(\n                Step(\"load\", tool=load_data, inputs={\"file\": \"data.csv\"})\n            )\n            workflow.add_step(\n                Step(\"analyze\", agent=analyst, depends_on=[\"load\"])\n            )\n            workflow.add_step(\n                Step(\"report\", agent=reporter, depends_on=[\"analyze\"])\n            )\n\n            result = await workflow.run(file=\"sales.csv\")\n    \"\"\"\n\n    def __init__(self, name: str, description: Optional[str] = None):\n        \"\"\"Initialize workflow.\"\"\"\n        self.id = str(uuid4())\n        self.name = name\n        self.description = description or f\"Workflow: {name}\"\n        self._steps: Dict[str, Step] = {}\n        self._execution_order: Optional[List[str]] = None\n\n    def add_step(self, step: Step) -&gt; None:\n        \"\"\"Add a single step to the workflow.\n\n        Args:\n            step: Step to add\n\n        Raises:\n            WorkflowError: If step name already exists\n        \"\"\"\n        if step.name in self._steps:\n            raise WorkflowError(f\"Step '{step.name}' already exists\")\n\n        self._steps[step.name] = step\n        self._execution_order = None  # Reset execution order\n\n    def add_steps(self, steps: List[Step]) -&gt; None:\n        \"\"\"Add multiple steps to the workflow.\n\n        Args:\n            steps: List of steps to add\n        \"\"\"\n        for step in steps:\n            self.add_step(step)\n\n    def _validate_dependencies(self) -&gt; None:\n        \"\"\"Validate all step dependencies exist.\"\"\"\n        for step in self._steps.values():\n            for dep in step.depends_on:\n                if dep not in self._steps:\n                    raise WorkflowError(\n                        f\"Step '{step.name}' depends on non-existent step '{dep}'\"\n                    )\n\n    def _calculate_execution_order(self) -&gt; List[str]:\n        \"\"\"Calculate step execution order using topological sort.\"\"\"\n        self._validate_dependencies()\n\n        # Build dependency graph\n        graph: Dict[str, Set[str]] = {name: set() for name in self._steps}\n        in_degree: Dict[str, int] = {name: 0 for name in self._steps}\n\n        for step in self._steps.values():\n            for dep in step.depends_on:\n                graph[dep].add(step.name)\n                in_degree[step.name] += 1\n\n        # Topological sort using Kahn's algorithm\n        queue = [name for name, degree in in_degree.items() if degree == 0]\n        order = []\n\n        while queue:\n            current = queue.pop(0)\n            order.append(current)\n\n            for neighbor in graph[current]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # Check for cycles\n        if len(order) != len(self._steps):\n            raise WorkflowError(\"Workflow contains circular dependencies\")\n\n        return order\n\n    async def run(self, **inputs: Any) -&gt; WorkflowResult:\n        \"\"\"Run the workflow.\n\n        Args:\n            **inputs: Initial inputs for the workflow\n\n        Returns:\n            WorkflowResult with outputs from all steps\n        \"\"\"\n        # Calculate execution order if needed\n        if self._execution_order is None:\n            self._execution_order = self._calculate_execution_order()\n\n        # Initialize result\n        result = WorkflowResult(\n            workflow_id=self.id,\n            workflow_name=self.name,\n            success=True,\n            steps={},\n            started_at=datetime.now(),\n            completed_at=datetime.now()  # Will update\n        )\n\n        # Context for passing data between steps\n        context: Dict[str, Any] = inputs.copy()\n\n        # Execute steps in order\n        for step_name in self._execution_order:\n            step = self._steps[step_name]\n\n            try:\n                # Execute step\n                step_result = await self._execute_step(step, context)\n                result.steps[step_name] = step_result\n\n                # Add output to context for dependent steps\n                context[step_name] = step_result.output\n\n            except Exception as e:\n                # Handle step failure\n                step_result = StepResult(\n                    step_name=step_name,\n                    success=False,\n                    output=None,\n                    error=str(e),\n                    started_at=datetime.now(),\n                    completed_at=datetime.now()\n                )\n                result.steps[step_name] = step_result\n                result.success = False\n\n                # Stop execution on failure\n                break\n\n        result.completed_at = datetime.now()\n        return result\n\n    async def _execute_step(self, step: Step, context: Dict[str, Any]) -&gt; StepResult:\n        \"\"\"Execute a single step.\"\"\"\n        started_at = datetime.now()\n\n        # Prepare inputs\n        step_inputs = {}\n        for key, value in step.inputs.items():\n            if isinstance(value, str) and value.startswith(\"$\"):\n                # Reference to context variable\n                ref_key = value[1:]  # Remove $\n                if ref_key in context:\n                    step_inputs[key] = context[ref_key]\n                else:\n                    raise StepExecutionError(\n                        step.name,\n                        f\"Reference '${ref_key}' not found in context\"\n                    )\n            else:\n                step_inputs[key] = value\n\n        # Add dependency outputs to inputs\n        for dep in step.depends_on:\n            if dep in context:\n                step_inputs[dep] = context[dep]\n\n        # Execute with retries\n        last_error = None\n        for attempt in range(step.retry_count + 1):\n            try:\n                if step.agent:\n                    # Execute with agent\n                    response = await self._execute_with_agent(\n                        step.agent,\n                        step_inputs,\n                        step.timeout\n                    )\n                    output = response\n                elif step.tool:\n                    # Execute with tool\n                    output = await self._execute_with_tool(\n                        step.tool,\n                        step_inputs,\n                        step.timeout\n                    )\n                else:\n                    raise StepExecutionError(step.name, \"No executor defined\")\n\n                # Success\n                return StepResult(\n                    step_name=step.name,\n                    success=True,\n                    output=output,\n                    started_at=started_at,\n                    completed_at=datetime.now(),\n                    metadata={\"attempts\": attempt + 1}\n                )\n\n            except Exception as e:\n                last_error = e\n                if attempt &lt; step.retry_count:\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n                    continue\n                break\n\n        # All attempts failed\n        raise StepExecutionError(\n            step.name,\n            f\"Failed after {step.retry_count + 1} attempts: {last_error}\"\n        )\n\n    async def _execute_with_agent(\n        self,\n        agent: Agent,\n        inputs: Dict[str, Any],\n        timeout: Optional[int]\n    ) -&gt; AgentResponse:\n        \"\"\"Execute step with an agent.\"\"\"\n        # Build prompt from inputs\n        prompt_parts = []\n        context = {}\n\n        for key, value in inputs.items():\n            if isinstance(value, str) and len(value) &lt; 100:\n                prompt_parts.append(f\"{key}: {value}\")\n            else:\n                context[key] = value\n\n        prompt = \"\\n\".join(prompt_parts) if prompt_parts else \"Process the provided context\"\n\n        # Execute with timeout if specified\n        if timeout:\n            return await asyncio.wait_for(\n                agent.arun(prompt, context=context),\n                timeout=timeout\n            )\n        else:\n            return await agent.arun(prompt, context=context)\n\n    async def _execute_with_tool(\n        self,\n        tool: Any,\n        inputs: Dict[str, Any],\n        timeout: Optional[int]\n    ) -&gt; Any:\n        \"\"\"Execute step with a tool.\"\"\"\n        # Execute with timeout if specified\n        if timeout:\n            return await asyncio.wait_for(\n                tool.arun(**inputs),\n                timeout=timeout\n            )\n        else:\n            return await tool.arun(**inputs)\n\n    def visualize(self) -&gt; str:\n        \"\"\"Get a text visualization of the workflow.\"\"\"\n        if not self._steps:\n            return \"Empty workflow\"\n\n        lines = [f\"Workflow: {self.name}\"]\n        lines.append(\"=\" * (len(lines[0]) + 5))\n\n        # Calculate execution order if needed\n        if self._execution_order is None:\n            self._execution_order = self._calculate_execution_order()\n\n        for i, step_name in enumerate(self._execution_order, 1):\n            step = self._steps[step_name]\n            executor = \"agent\" if step.agent else \"tool\"\n            deps = f\" &lt;- {', '.join(step.depends_on)}\" if step.depends_on else \"\"\n            lines.append(f\"{i}. {step_name} ({executor}){deps}\")\n\n        return \"\\n\".join(lines)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"Workflow(name='{self.name}', steps={len(self._steps)})\"\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.__init__","title":"<code>__init__(name, description=None)</code>","text":"<p>Initialize workflow.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __init__(self, name: str, description: Optional[str] = None):\n    \"\"\"Initialize workflow.\"\"\"\n    self.id = str(uuid4())\n    self.name = name\n    self.description = description or f\"Workflow: {name}\"\n    self._steps: Dict[str, Step] = {}\n    self._execution_order: Optional[List[str]] = None\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.add_step","title":"<code>add_step(step)</code>","text":"<p>Add a single step to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>Step to add</p> required <p>Raises:</p> Type Description <code>WorkflowError</code> <p>If step name already exists</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def add_step(self, step: Step) -&gt; None:\n    \"\"\"Add a single step to the workflow.\n\n    Args:\n        step: Step to add\n\n    Raises:\n        WorkflowError: If step name already exists\n    \"\"\"\n    if step.name in self._steps:\n        raise WorkflowError(f\"Step '{step.name}' already exists\")\n\n    self._steps[step.name] = step\n    self._execution_order = None  # Reset execution order\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.add_steps","title":"<code>add_steps(steps)</code>","text":"<p>Add multiple steps to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>List[Step]</code> <p>List of steps to add</p> required Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def add_steps(self, steps: List[Step]) -&gt; None:\n    \"\"\"Add multiple steps to the workflow.\n\n    Args:\n        steps: List of steps to add\n    \"\"\"\n    for step in steps:\n        self.add_step(step)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.run","title":"<code>run(**inputs)</code>  <code>async</code>","text":"<p>Run the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>**inputs</code> <code>Any</code> <p>Initial inputs for the workflow</p> <code>{}</code> <p>Returns:</p> Type Description <code>WorkflowResult</code> <p>WorkflowResult with outputs from all steps</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>async def run(self, **inputs: Any) -&gt; WorkflowResult:\n    \"\"\"Run the workflow.\n\n    Args:\n        **inputs: Initial inputs for the workflow\n\n    Returns:\n        WorkflowResult with outputs from all steps\n    \"\"\"\n    # Calculate execution order if needed\n    if self._execution_order is None:\n        self._execution_order = self._calculate_execution_order()\n\n    # Initialize result\n    result = WorkflowResult(\n        workflow_id=self.id,\n        workflow_name=self.name,\n        success=True,\n        steps={},\n        started_at=datetime.now(),\n        completed_at=datetime.now()  # Will update\n    )\n\n    # Context for passing data between steps\n    context: Dict[str, Any] = inputs.copy()\n\n    # Execute steps in order\n    for step_name in self._execution_order:\n        step = self._steps[step_name]\n\n        try:\n            # Execute step\n            step_result = await self._execute_step(step, context)\n            result.steps[step_name] = step_result\n\n            # Add output to context for dependent steps\n            context[step_name] = step_result.output\n\n        except Exception as e:\n            # Handle step failure\n            step_result = StepResult(\n                step_name=step_name,\n                success=False,\n                output=None,\n                error=str(e),\n                started_at=datetime.now(),\n                completed_at=datetime.now()\n            )\n            result.steps[step_name] = step_result\n            result.success = False\n\n            # Stop execution on failure\n            break\n\n    result.completed_at = datetime.now()\n    return result\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.visualize","title":"<code>visualize()</code>","text":"<p>Get a text visualization of the workflow.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def visualize(self) -&gt; str:\n    \"\"\"Get a text visualization of the workflow.\"\"\"\n    if not self._steps:\n        return \"Empty workflow\"\n\n    lines = [f\"Workflow: {self.name}\"]\n    lines.append(\"=\" * (len(lines[0]) + 5))\n\n    # Calculate execution order if needed\n    if self._execution_order is None:\n        self._execution_order = self._calculate_execution_order()\n\n    for i, step_name in enumerate(self._execution_order, 1):\n        step = self._steps[step_name]\n        executor = \"agent\" if step.agent else \"tool\"\n        deps = f\" &lt;- {', '.join(step.depends_on)}\" if step.depends_on else \"\"\n        lines.append(f\"{i}. {step_name} ({executor}){deps}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Workflow.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"Workflow(name='{self.name}', steps={len(self._steps)})\"\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Step","title":"<code>Step</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single step in a workflow.</p> <p>Steps are the building blocks of workflows. Each step can be executed by an agent or a tool, and can depend on other steps.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name for this step</p> <code>agent</code> <code>Optional[Agent]</code> <p>Agent to execute this step</p> <code>tool</code> <code>Optional[Any]</code> <p>Tool to execute this step (if no agent)</p> <code>inputs</code> <code>Dict[str, Any]</code> <p>Input parameters for this step</p> <code>depends_on</code> <code>List[str]</code> <p>Names of steps this depends on</p> <code>retry_count</code> <code>int</code> <p>Number of retries on failure</p> <code>timeout</code> <code>Optional[int]</code> <p>Timeout in seconds</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class Step(BaseModel):\n    \"\"\"A single step in a workflow.\n\n    Steps are the building blocks of workflows. Each step can be\n    executed by an agent or a tool, and can depend on other steps.\n\n    Attributes:\n        name: Unique name for this step\n        agent: Agent to execute this step\n        tool: Tool to execute this step (if no agent)\n        inputs: Input parameters for this step\n        depends_on: Names of steps this depends on\n        retry_count: Number of retries on failure\n        timeout: Timeout in seconds\n    \"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    name: str\n    agent: Optional[Agent] = None\n    tool: Optional[Any] = None  # Will be BaseTool when imported\n    inputs: Dict[str, Any] = Field(default_factory=dict)\n    depends_on: List[str] = Field(default_factory=list)\n    retry_count: int = Field(default=0, ge=0)\n    timeout: Optional[int] = Field(default=None, gt=0)\n\n    @model_validator(mode='before')\n    @classmethod\n    def validate_executor(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Ensure we have either an agent or tool.\"\"\"\n        agent = values.get('agent')\n        tool = values.get('tool')\n\n        if agent is None and tool is None:\n            raise ValueError(\"Step must have either an agent or a tool\")\n        if agent is not None and tool is not None:\n            raise ValueError(\"Step cannot have both agent and tool\")\n\n        # Check if agent is a mock object (for testing)\n        if agent is not None:\n            agent_type_str = str(type(agent))\n            is_mock = (\n                'mock' in agent_type_str.lower() or\n                hasattr(agent, '_mock_name') or\n                hasattr(agent, '_mock_methods') or\n                hasattr(agent, '_spec_class') or\n                hasattr(agent, '_mock_sealed') or\n                (hasattr(type(agent), '__module__') and \n                 type(agent).__module__ in ['unittest.mock', 'mock'])\n            )\n            if is_mock:\n                # Allow mocks in testing\n                return values\n\n            # In production, validate it's an Agent or has arun method\n            # Import here to avoid circular imports\n            try:\n                from .agent import Agent\n                if not isinstance(agent, Agent) and not hasattr(agent, 'arun'):\n                    raise ValueError(\"Agent must be an Agent instance or have an arun method\")\n            except ImportError:\n                # If can't import Agent, just check for arun method\n                if not hasattr(agent, 'arun'):\n                    raise ValueError(\"Agent must have an arun method\")\n\n        # Similar check for tool\n        if tool is not None:\n            tool_type_str = str(type(tool))\n            is_mock = (\n                'mock' in tool_type_str.lower() or\n                hasattr(tool, '_mock_name') or\n                hasattr(tool, '_mock_methods')\n            )\n            if is_mock:\n                return values\n\n        return values\n\n    def __init__(self, name: str, **kwargs):\n        \"\"\"Convenience constructor.\n\n        Example:\n            Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})\n        \"\"\"\n        super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Step.validate_executor","title":"<code>validate_executor(values)</code>  <code>classmethod</code>","text":"<p>Ensure we have either an agent or tool.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>@model_validator(mode='before')\n@classmethod\ndef validate_executor(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Ensure we have either an agent or tool.\"\"\"\n    agent = values.get('agent')\n    tool = values.get('tool')\n\n    if agent is None and tool is None:\n        raise ValueError(\"Step must have either an agent or a tool\")\n    if agent is not None and tool is not None:\n        raise ValueError(\"Step cannot have both agent and tool\")\n\n    # Check if agent is a mock object (for testing)\n    if agent is not None:\n        agent_type_str = str(type(agent))\n        is_mock = (\n            'mock' in agent_type_str.lower() or\n            hasattr(agent, '_mock_name') or\n            hasattr(agent, '_mock_methods') or\n            hasattr(agent, '_spec_class') or\n            hasattr(agent, '_mock_sealed') or\n            (hasattr(type(agent), '__module__') and \n             type(agent).__module__ in ['unittest.mock', 'mock'])\n        )\n        if is_mock:\n            # Allow mocks in testing\n            return values\n\n        # In production, validate it's an Agent or has arun method\n        # Import here to avoid circular imports\n        try:\n            from .agent import Agent\n            if not isinstance(agent, Agent) and not hasattr(agent, 'arun'):\n                raise ValueError(\"Agent must be an Agent instance or have an arun method\")\n        except ImportError:\n            # If can't import Agent, just check for arun method\n            if not hasattr(agent, 'arun'):\n                raise ValueError(\"Agent must have an arun method\")\n\n    # Similar check for tool\n    if tool is not None:\n        tool_type_str = str(type(tool))\n        is_mock = (\n            'mock' in tool_type_str.lower() or\n            hasattr(tool, '_mock_name') or\n            hasattr(tool, '_mock_methods')\n        )\n        if is_mock:\n            return values\n\n    return values\n</code></pre>"},{"location":"reference/__init__/#agenticraft.Step.__init__","title":"<code>__init__(name, **kwargs)</code>","text":"<p>Convenience constructor.</p> Example <p>Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __init__(self, name: str, **kwargs):\n    \"\"\"Convenience constructor.\n\n    Example:\n        Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.AgenticraftError","title":"<code>AgenticraftError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all AgentiCraft errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgenticraftError(Exception):\n    \"\"\"Base exception for all AgentiCraft errors.\"\"\"\n\n    def __init__(self, message: str, **kwargs):\n        super().__init__(message)\n        self.message = message\n        self.details = kwargs\n        # Store any additional context as attributes\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.AgentError","title":"<code>AgentError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Raised when an agent operation fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgentError(AgenticraftError):\n    \"\"\"Raised when an agent operation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ToolError","title":"<code>ToolError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for tool-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolError(AgenticraftError):\n    \"\"\"Base exception for tool-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowError","title":"<code>WorkflowError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for workflow-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class WorkflowError(AgenticraftError):\n    \"\"\"Base exception for workflow-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/__init__/#agenticraft.StepExecutionError","title":"<code>StepExecutionError</code>","text":"<p>               Bases: <code>WorkflowError</code></p> <p>Raised when a workflow step fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class StepExecutionError(WorkflowError):\n    \"\"\"Raised when a workflow step fails.\"\"\"\n\n    def __init__(self, step_name: str, error: str):\n        super().__init__(f\"Step '{step_name}' failed: {error}\")\n        self.step_name = step_name\n        self.error = error\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent","title":"<code>ReasoningAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent that exposes its reasoning process transparently.</p> <pre><code>ReasoningAgent extends the base Agent class to provide detailed\nvisibility into the reasoning process. It uses Chain of Thought\nby default and formats responses to include step-by-step thinking.\n\nExample:\n    Basic usage::\n\n        agent = ReasoningAgent(\n            name=\"Tutor\",\n            instructions=\"You are a helpful tutor who explains step-by-step.\"\n        )\n\n        response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n        print(\"Answer:\", response.content)\n        print(\"\n</code></pre> <p>Reasoning Process:\")             print(response.reasoning)</p> <pre><code>        # Access detailed reasoning\n        for step in response.reasoning_steps:\n            print(f\"{step.number}. {step.description}\")\n            if step.conclusion:\n                print(f\"   Conclusion: {step.conclusion}\")\n</code></pre> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningAgent(Agent):\n    \"\"\"An agent that exposes its reasoning process transparently.\n\n    ReasoningAgent extends the base Agent class to provide detailed\n    visibility into the reasoning process. It uses Chain of Thought\n    by default and formats responses to include step-by-step thinking.\n\n    Example:\n        Basic usage::\n\n            agent = ReasoningAgent(\n                name=\"Tutor\",\n                instructions=\"You are a helpful tutor who explains step-by-step.\"\n            )\n\n            response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n            print(\"Answer:\", response.content)\n            print(\"\\nReasoning Process:\")\n            print(response.reasoning)\n\n            # Access detailed reasoning\n            for step in response.reasoning_steps:\n                print(f\"{step.number}. {step.description}\")\n                if step.conclusion:\n                    print(f\"   Conclusion: {step.conclusion}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"ReasoningAgent\",\n        instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n        **kwargs\n    ):\n        \"\"\"Initialize ReasoningAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions (augmented with reasoning prompt)\n            **kwargs: Additional configuration passed to base Agent\n        \"\"\"\n        # Augment instructions to encourage step-by-step reasoning\n        reasoning_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n            \"For each step:\\n\"\n            \"1. State what you're doing\\n\"\n            \"2. Explain why\\n\"\n            \"3. Show any calculations or logic\\n\"\n            \"4. State your conclusion for that step\\n\\n\"\n            \"Format your response with clear sections:\\n\"\n            \"- REASONING: Your step-by-step thought process\\n\"\n            \"- ANSWER: Your final answer\\n\"\n        )\n\n        # Use Chain of Thought reasoning by default\n        if 'reasoning_pattern' not in kwargs:\n            kwargs['reasoning_pattern'] = ChainOfThought()\n\n        super().__init__(\n            name=name,\n            instructions=reasoning_instructions,\n            **kwargs\n        )\n\n        self.reasoning_history: List[ReasoningTrace] = []\n\n    async def think_and_act(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        expose_thinking: bool = True,\n        **kwargs\n    ) -&gt; 'ReasoningResponse':\n        \"\"\"Think through a problem step-by-step and act on it.\n\n        Args:\n            prompt: The problem or question to solve\n            context: Optional context\n            expose_thinking: Whether to expose internal reasoning\n            **kwargs: Additional arguments passed to LLM\n\n        Returns:\n            ReasoningResponse with detailed reasoning information\n        \"\"\"\n        # Start reasoning trace\n        trace = self._reasoning.start_trace(prompt)\n\n        # Add thinking step\n        trace.add_step(\"thinking\", {\n            \"approach\": \"step_by_step\",\n            \"expose_thinking\": expose_thinking\n        })\n\n        # If expose_thinking, add a special prompt\n        thinking_prompt = prompt\n        if expose_thinking:\n            thinking_prompt = (\n                f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n                f\"{prompt}\\n\\n\"\n                f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n            )\n\n        # Run the agent with thinking prompt\n        response = await self.arun(thinking_prompt, context, **kwargs)\n\n        # Parse the response to extract reasoning steps\n        reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n        # Store reasoning trace\n        self.reasoning_history.append(trace)\n\n        # Create enhanced response\n        return ReasoningResponse(\n            content=response.content,\n            reasoning=response.reasoning,\n            reasoning_steps=reasoning_steps,\n            reasoning_trace=trace,\n            tool_calls=response.tool_calls,\n            metadata=response.metadata,\n            agent_id=response.agent_id\n        )\n\n    def _parse_reasoning_steps(\n        self, \n        content: str, \n        trace: ReasoningTrace\n    ) -&gt; List['ReasoningStepDetail']:\n        \"\"\"Parse reasoning steps from the response content.\n\n        Args:\n            content: The response content\n            trace: The reasoning trace\n\n        Returns:\n            List of detailed reasoning steps\n        \"\"\"\n        steps = []\n\n        # Try to extract structured reasoning\n        lines = content.split('\\n')\n        current_step = None\n        step_number = 0\n        in_reasoning_section = False\n\n        for line in lines:\n            line = line.strip()\n\n            # Check for reasoning section\n            if line.upper().startswith('REASONING:'):\n                in_reasoning_section = True\n                continue\n            elif line.upper().startswith('ANSWER:'):\n                in_reasoning_section = False\n                continue\n\n            if in_reasoning_section and line:\n                # Look for numbered steps\n                if (line[0].isdigit() and '.' in line) or line.startswith('Step'):\n                    if current_step:\n                        steps.append(current_step)\n\n                    step_number += 1\n                    # Extract step description\n                    desc_start = line.find('.') + 1 if '.' in line else line.find(':') + 1\n                    description = line[desc_start:].strip()\n\n                    current_step = ReasoningStepDetail(\n                        number=step_number,\n                        description=description,\n                        details=[],\n                        conclusion=None\n                    )\n                elif current_step and line.startswith(('-', '\u2022', '*')):\n                    # Add as detail to current step\n                    current_step.details.append(line[1:].strip())\n                elif current_step and ('therefore' in line.lower() or \n                                     'conclusion:' in line.lower() or\n                                     'so,' in line.lower()):\n                    # This is a conclusion\n                    current_step.conclusion = line\n\n        # Add the last step\n        if current_step:\n            steps.append(current_step)\n\n        # If no structured steps found, create from trace\n        if not steps and trace.steps:\n            for i, trace_step in enumerate(trace.steps):\n                if trace_step.step_type not in ['analyzing_prompt', 'breakdown']:\n                    steps.append(ReasoningStepDetail(\n                        number=i + 1,\n                        description=trace_step.description,\n                        details=[f\"{k}: {v}\" for k, v in trace_step.data.items()],\n                        conclusion=None\n                    ))\n\n        return steps\n\n    async def analyze(\n        self,\n        prompt: str,\n        perspectives: List[str] = None,\n        **kwargs\n    ) -&gt; 'AnalysisResponse':\n        \"\"\"Analyze a topic from multiple perspectives.\n\n        Args:\n            prompt: The topic or question to analyze\n            perspectives: List of perspectives to consider\n            **kwargs: Additional arguments\n\n        Returns:\n            AnalysisResponse with multi-perspective analysis\n        \"\"\"\n        if perspectives is None:\n            perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n        # Build analysis prompt\n        analysis_prompt = (\n            f\"Please analyze the following from multiple perspectives:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Consider these perspectives:\\n\"\n        )\n        for perspective in perspectives:\n            analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n        analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n        # Get analysis\n        response = await self.think_and_act(analysis_prompt, **kwargs)\n\n        # Parse perspectives from response\n        perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n        return AnalysisResponse(\n            content=response.content,\n            perspectives=perspective_analyses,\n            reasoning_steps=response.reasoning_steps,\n            synthesis=self._synthesize_perspectives(perspective_analyses),\n            metadata=response.metadata\n        )\n\n    def _parse_perspectives(\n        self, \n        content: str, \n        perspectives: List[str]\n    ) -&gt; Dict[str, str]:\n        \"\"\"Parse perspective analyses from content.\"\"\"\n        analyses = {}\n        lines = content.split('\\n')\n        current_perspective = None\n        current_content = []\n\n        for line in lines:\n            # Check if this line starts a new perspective\n            for perspective in perspectives:\n                if perspective.lower() in line.lower() and 'perspective' in line.lower():\n                    if current_perspective:\n                        analyses[current_perspective] = '\\n'.join(current_content).strip()\n                    current_perspective = perspective\n                    current_content = []\n                    break\n            else:\n                if current_perspective:\n                    current_content.append(line)\n\n        # Add the last perspective\n        if current_perspective:\n            analyses[current_perspective] = '\\n'.join(current_content).strip()\n\n        return analyses\n\n    def _synthesize_perspectives(self, perspectives: Dict[str, str]) -&gt; str:\n        \"\"\"Create a synthesis of multiple perspectives.\"\"\"\n        if not perspectives:\n            return \"No perspectives to synthesize.\"\n\n        synthesis = \"Synthesis: Considering all perspectives, \"\n\n        # Simple synthesis based on perspective count\n        if len(perspectives) &gt; 1:\n            synthesis += \"this topic reveals multiple important dimensions. \"\n            synthesis += f\"The {', '.join(perspectives.keys())} perspectives \"\n            synthesis += \"each contribute valuable insights that should be balanced.\"\n        else:\n            key = list(perspectives.keys())[0]\n            synthesis += f\"the {key} perspective provides the primary framework for understanding.\"\n\n        return synthesis\n\n    def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n        \"\"\"Get recent reasoning history.\n\n        Args:\n            limit: Maximum number of traces to return\n\n        Returns:\n            List of recent reasoning traces\n        \"\"\"\n        return self.reasoning_history[-limit:]\n\n    def explain_last_response(self) -&gt; str:\n        \"\"\"Explain the reasoning behind the last response.\"\"\"\n        if not self.reasoning_history:\n            return \"No reasoning history available.\"\n\n        last_trace = self.reasoning_history[-1]\n        return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent.__init__","title":"<code>__init__(name='ReasoningAgent', instructions='You are a helpful assistant that explains your reasoning step-by-step.', **kwargs)</code>","text":"<p>Initialize ReasoningAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'ReasoningAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions (augmented with reasoning prompt)</p> <code>'You are a helpful assistant that explains your reasoning step-by-step.'</code> <code>**kwargs</code> <p>Additional configuration passed to base Agent</p> <code>{}</code> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"ReasoningAgent\",\n    instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n    **kwargs\n):\n    \"\"\"Initialize ReasoningAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions (augmented with reasoning prompt)\n        **kwargs: Additional configuration passed to base Agent\n    \"\"\"\n    # Augment instructions to encourage step-by-step reasoning\n    reasoning_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n        \"For each step:\\n\"\n        \"1. State what you're doing\\n\"\n        \"2. Explain why\\n\"\n        \"3. Show any calculations or logic\\n\"\n        \"4. State your conclusion for that step\\n\\n\"\n        \"Format your response with clear sections:\\n\"\n        \"- REASONING: Your step-by-step thought process\\n\"\n        \"- ANSWER: Your final answer\\n\"\n    )\n\n    # Use Chain of Thought reasoning by default\n    if 'reasoning_pattern' not in kwargs:\n        kwargs['reasoning_pattern'] = ChainOfThought()\n\n    super().__init__(\n        name=name,\n        instructions=reasoning_instructions,\n        **kwargs\n    )\n\n    self.reasoning_history: List[ReasoningTrace] = []\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent.think_and_act","title":"<code>think_and_act(prompt, context=None, expose_thinking=True, **kwargs)</code>  <code>async</code>","text":"<p>Think through a problem step-by-step and act on it.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The problem or question to solve</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context</p> <code>None</code> <code>expose_thinking</code> <code>bool</code> <p>Whether to expose internal reasoning</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>ReasoningResponse</code> <p>ReasoningResponse with detailed reasoning information</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def think_and_act(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    expose_thinking: bool = True,\n    **kwargs\n) -&gt; 'ReasoningResponse':\n    \"\"\"Think through a problem step-by-step and act on it.\n\n    Args:\n        prompt: The problem or question to solve\n        context: Optional context\n        expose_thinking: Whether to expose internal reasoning\n        **kwargs: Additional arguments passed to LLM\n\n    Returns:\n        ReasoningResponse with detailed reasoning information\n    \"\"\"\n    # Start reasoning trace\n    trace = self._reasoning.start_trace(prompt)\n\n    # Add thinking step\n    trace.add_step(\"thinking\", {\n        \"approach\": \"step_by_step\",\n        \"expose_thinking\": expose_thinking\n    })\n\n    # If expose_thinking, add a special prompt\n    thinking_prompt = prompt\n    if expose_thinking:\n        thinking_prompt = (\n            f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n        )\n\n    # Run the agent with thinking prompt\n    response = await self.arun(thinking_prompt, context, **kwargs)\n\n    # Parse the response to extract reasoning steps\n    reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n    # Store reasoning trace\n    self.reasoning_history.append(trace)\n\n    # Create enhanced response\n    return ReasoningResponse(\n        content=response.content,\n        reasoning=response.reasoning,\n        reasoning_steps=reasoning_steps,\n        reasoning_trace=trace,\n        tool_calls=response.tool_calls,\n        metadata=response.metadata,\n        agent_id=response.agent_id\n    )\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent.analyze","title":"<code>analyze(prompt, perspectives=None, **kwargs)</code>  <code>async</code>","text":"<p>Analyze a topic from multiple perspectives.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The topic or question to analyze</p> required <code>perspectives</code> <code>List[str]</code> <p>List of perspectives to consider</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnalysisResponse</code> <p>AnalysisResponse with multi-perspective analysis</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def analyze(\n    self,\n    prompt: str,\n    perspectives: List[str] = None,\n    **kwargs\n) -&gt; 'AnalysisResponse':\n    \"\"\"Analyze a topic from multiple perspectives.\n\n    Args:\n        prompt: The topic or question to analyze\n        perspectives: List of perspectives to consider\n        **kwargs: Additional arguments\n\n    Returns:\n        AnalysisResponse with multi-perspective analysis\n    \"\"\"\n    if perspectives is None:\n        perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n    # Build analysis prompt\n    analysis_prompt = (\n        f\"Please analyze the following from multiple perspectives:\\n\\n\"\n        f\"{prompt}\\n\\n\"\n        f\"Consider these perspectives:\\n\"\n    )\n    for perspective in perspectives:\n        analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n    analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n    # Get analysis\n    response = await self.think_and_act(analysis_prompt, **kwargs)\n\n    # Parse perspectives from response\n    perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n    return AnalysisResponse(\n        content=response.content,\n        perspectives=perspective_analyses,\n        reasoning_steps=response.reasoning_steps,\n        synthesis=self._synthesize_perspectives(perspective_analyses),\n        metadata=response.metadata\n    )\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent.get_reasoning_history","title":"<code>get_reasoning_history(limit=10)</code>","text":"<p>Get recent reasoning history.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of traces to return</p> <code>10</code> <p>Returns:</p> Type Description <code>List[ReasoningTrace]</code> <p>List of recent reasoning traces</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n    \"\"\"Get recent reasoning history.\n\n    Args:\n        limit: Maximum number of traces to return\n\n    Returns:\n        List of recent reasoning traces\n    \"\"\"\n    return self.reasoning_history[-limit:]\n</code></pre>"},{"location":"reference/__init__/#agenticraft.ReasoningAgent.explain_last_response","title":"<code>explain_last_response()</code>","text":"<p>Explain the reasoning behind the last response.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def explain_last_response(self) -&gt; str:\n    \"\"\"Explain the reasoning behind the last response.\"\"\"\n    if not self.reasoning_history:\n        return \"No reasoning history available.\"\n\n    last_trace = self.reasoning_history[-1]\n    return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent","title":"<code>WorkflowAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent optimized for executing multi-step workflows.</p> <p>WorkflowAgent extends the base Agent to provide workflow execution capabilities including step dependencies, parallel execution, conditional logic, and error handling.</p> Example <p>Basic workflow::</p> <pre><code>agent = WorkflowAgent(name=\"DataProcessor\")\n\n# Define workflow\nworkflow = agent.create_workflow(\"data_pipeline\")\nworkflow.add_step(\"fetch\", \"Fetch data from the API\")\nworkflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\nworkflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\nworkflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n# Execute workflow\nresult = await agent.execute_workflow(workflow)\n\n# Check results\nfor step_name, step_result in result.step_results.items():\n    print(f\"{step_name}: {step_result.status}\")\n</code></pre> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowAgent(Agent):\n    \"\"\"An agent optimized for executing multi-step workflows.\n\n    WorkflowAgent extends the base Agent to provide workflow execution\n    capabilities including step dependencies, parallel execution,\n    conditional logic, and error handling.\n\n    Example:\n        Basic workflow::\n\n            agent = WorkflowAgent(name=\"DataProcessor\")\n\n            # Define workflow\n            workflow = agent.create_workflow(\"data_pipeline\")\n            workflow.add_step(\"fetch\", \"Fetch data from the API\")\n            workflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\n            workflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\n            workflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n            # Execute workflow\n            result = await agent.execute_workflow(workflow)\n\n            # Check results\n            for step_name, step_result in result.step_results.items():\n                print(f\"{step_name}: {step_result.status}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"WorkflowAgent\",\n        instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n        **kwargs\n    ):\n        \"\"\"Initialize WorkflowAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions\n            **kwargs: Additional configuration\n        \"\"\"\n        # Augment instructions for workflow execution\n        workflow_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"When executing workflow steps:\\n\"\n            \"1. Follow the exact instructions for each step\\n\"\n            \"2. Use the context from previous steps when needed\\n\"\n            \"3. Provide clear, actionable output\\n\"\n            \"4. Report any issues or blockers immediately\"\n        )\n\n        super().__init__(\n            name=name,\n            instructions=workflow_instructions,\n            **kwargs\n        )\n\n        self.workflows: Dict[str, Workflow] = {}\n        self.handlers: Dict[str, Callable] = {}\n        self.running_workflows: Dict[str, Workflow] = {}\n\n    def create_workflow(\n        self,\n        name: str,\n        description: str = \"\"\n    ) -&gt; Workflow:\n        \"\"\"Create a new workflow.\n\n        Args:\n            name: Workflow name\n            description: Workflow description\n\n        Returns:\n            The created Workflow\n        \"\"\"\n        workflow = Workflow(name=name, description=description)\n        self.workflows[workflow.id] = workflow\n        return workflow\n\n    def register_handler(\n        self,\n        name: str,\n        handler: Callable\n    ) -&gt; None:\n        \"\"\"Register a custom step handler.\n\n        Args:\n            name: Handler name\n            handler: Callable that takes (agent, step, context) and returns result\n        \"\"\"\n        self.handlers[name] = handler\n\n    async def execute_workflow(\n        self,\n        workflow: Union[Workflow, str],\n        context: Optional[Dict[str, Any]] = None,\n        parallel: bool = True\n    ) -&gt; 'WorkflowResult':\n        \"\"\"Execute a workflow.\n\n        Args:\n            workflow: Workflow instance or ID\n            context: Initial workflow context\n            parallel: Whether to run parallel steps concurrently\n\n        Returns:\n            WorkflowResult with execution details\n        \"\"\"\n        # Get workflow instance\n        if isinstance(workflow, str):\n            workflow = self.workflows.get(workflow)\n            if not workflow:\n                raise AgentError(f\"Workflow '{workflow}' not found\")\n\n        # Validate workflow\n        errors = workflow.validate()\n        if errors:\n            raise AgentError(f\"Workflow validation failed: {errors}\")\n\n        # Initialize execution\n        workflow.status = StepStatus.RUNNING\n        workflow.started_at = datetime.now()\n        workflow.context = context or {}\n        self.running_workflows[workflow.id] = workflow\n\n        try:\n            # Execute workflow\n            if parallel:\n                await self._execute_parallel(workflow)\n            else:\n                await self._execute_sequential(workflow)\n\n            # Mark as completed\n            workflow.status = StepStatus.COMPLETED\n            workflow.completed_at = datetime.now()\n\n        except Exception as e:\n            workflow.status = StepStatus.FAILED\n            workflow.completed_at = datetime.now()\n            raise\n        finally:\n            del self.running_workflows[workflow.id]\n\n        # Build result\n        return WorkflowResult(\n            workflow_id=workflow.id,\n            workflow_name=workflow.name,\n            status=workflow.status,\n            duration=self._calculate_duration(workflow),\n            step_results={\n                step.name: StepResult(\n                    name=step.name,\n                    status=step.status,\n                    result=step.result,\n                    error=step.error,\n                    duration=step.duration\n                )\n                for step in workflow.steps\n            },\n            context=workflow.context\n        )\n\n    async def _execute_sequential(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow steps sequentially.\"\"\"\n        completed_steps = []\n\n        while True:\n            # Get next ready step\n            ready_steps = workflow.get_ready_steps()\n            if not ready_steps:\n                break\n\n            # Execute first ready step\n            step = ready_steps[0]\n            await self._execute_step(step, workflow)\n\n            if step.status == StepStatus.COMPLETED:\n                completed_steps.append(step.name)\n\n    async def _execute_parallel(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow with parallel step support.\"\"\"\n        completed_steps = set()\n        pending_tasks = {}\n\n        while True:\n            # Get ready steps\n            ready_steps = workflow.get_ready_steps()\n\n            # Start tasks for ready steps\n            for step in ready_steps:\n                if step.name not in pending_tasks:\n                    task = asyncio.create_task(self._execute_step(step, workflow))\n                    pending_tasks[step.name] = (step, task)\n\n            # If no pending tasks, we're done\n            if not pending_tasks:\n                break\n\n            # Wait for any task to complete\n            done, pending = await asyncio.wait(\n                [task for _, task in pending_tasks.values()],\n                return_when=asyncio.FIRST_COMPLETED\n            )\n\n            # Process completed tasks\n            for task in done:\n                # Find which step this task belongs to\n                for step_name, (step, step_task) in list(pending_tasks.items()):\n                    if step_task == task:\n                        del pending_tasks[step_name]\n                        if step.status == StepStatus.COMPLETED:\n                            completed_steps.add(step_name)\n                        break\n\n    async def _execute_step(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; None:\n        \"\"\"Execute a single workflow step.\"\"\"\n        step.status = StepStatus.RUNNING\n        step.started_at = datetime.now()\n\n        try:\n            # Check condition if present\n            if step.condition and not self._evaluate_condition(step.condition, workflow.context):\n                step.status = StepStatus.SKIPPED\n                step.result = \"Skipped due to condition\"\n                return\n\n            # Execute with timeout if specified\n            if step.timeout:\n                result = await asyncio.wait_for(\n                    self._run_step_action(step, workflow),\n                    timeout=step.timeout\n                )\n            else:\n                result = await self._run_step_action(step, workflow)\n\n            # Store result\n            step.result = result\n            step.status = StepStatus.COMPLETED\n\n            # Update workflow context\n            workflow.context[f\"{step.name}_result\"] = result\n\n        except asyncio.TimeoutError:\n            step.error = f\"Step timed out after {step.timeout} seconds\"\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        except Exception as e:\n            step.error = str(e)\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        finally:\n            if step.status in [StepStatus.COMPLETED, StepStatus.FAILED, StepStatus.SKIPPED]:\n                step.completed_at = datetime.now()\n\n    async def _run_step_action(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; Any:\n        \"\"\"Run the action for a step.\"\"\"\n        # Use custom handler if specified\n        if step.handler and step.handler in self.handlers:\n            handler = self.handlers[step.handler]\n            if asyncio.iscoroutinefunction(handler):\n                return await handler(self, step, workflow.context)\n            else:\n                return handler(self, step, workflow.context)\n\n        # Use action prompt\n        if step.action:\n            # Build prompt with context\n            prompt = f\"Execute the following step: {step.action}\"\n\n            # Add relevant context\n            if workflow.context:\n                relevant_context = {\n                    k: v for k, v in workflow.context.items()\n                    if any(dep in k for dep in step.depends_on) or k in ['initial_input', 'user_request']\n                }\n                if relevant_context:\n                    prompt += f\"\\n\\nContext from previous steps:\\n{relevant_context}\"\n\n            # Execute with agent\n            response = await self.arun(prompt)\n            return response.content\n\n        # No action defined\n        return f\"Step '{step.name}' completed\"\n\n    def _evaluate_condition(\n        self,\n        condition: str,\n        context: Dict[str, Any]\n    ) -&gt; bool:\n        \"\"\"Evaluate a step condition.\n\n        Simple evaluation - in production, use a safe expression evaluator.\n        \"\"\"\n        try:\n            # Very basic condition evaluation\n            # In production, use a proper expression evaluator\n            if \"==\" in condition:\n                parts = condition.split(\"==\")\n                if len(parts) == 2:\n                    left = parts[0].strip()\n                    right = parts[1].strip().strip(\"'\\\"\")\n                    return str(context.get(left, \"\")) == right\n\n            # Default to True if we can't evaluate\n            return True\n\n        except Exception:\n            return True\n\n    def _calculate_duration(self, workflow: Workflow) -&gt; float:\n        \"\"\"Calculate total workflow duration.\"\"\"\n        if not workflow.started_at or not workflow.completed_at:\n            return 0.0\n        return (workflow.completed_at - workflow.started_at).total_seconds()\n\n    def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get the current status of a running workflow.\"\"\"\n        workflow = self.running_workflows.get(workflow_id)\n        if not workflow:\n            return None\n\n        return {\n            \"id\": workflow.id,\n            \"name\": workflow.name,\n            \"status\": workflow.status,\n            \"steps\": {\n                step.name: {\n                    \"status\": step.status,\n                    \"duration\": step.duration\n                }\n                for step in workflow.steps\n            }\n        }\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent.__init__","title":"<code>__init__(name='WorkflowAgent', instructions='You are a workflow execution agent. Follow the steps precisely.', **kwargs)</code>","text":"<p>Initialize WorkflowAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'WorkflowAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions</p> <code>'You are a workflow execution agent. Follow the steps precisely.'</code> <code>**kwargs</code> <p>Additional configuration</p> <code>{}</code> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"WorkflowAgent\",\n    instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n    **kwargs\n):\n    \"\"\"Initialize WorkflowAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions\n        **kwargs: Additional configuration\n    \"\"\"\n    # Augment instructions for workflow execution\n    workflow_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"When executing workflow steps:\\n\"\n        \"1. Follow the exact instructions for each step\\n\"\n        \"2. Use the context from previous steps when needed\\n\"\n        \"3. Provide clear, actionable output\\n\"\n        \"4. Report any issues or blockers immediately\"\n    )\n\n    super().__init__(\n        name=name,\n        instructions=workflow_instructions,\n        **kwargs\n    )\n\n    self.workflows: Dict[str, Workflow] = {}\n    self.handlers: Dict[str, Callable] = {}\n    self.running_workflows: Dict[str, Workflow] = {}\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent.create_workflow","title":"<code>create_workflow(name, description='')</code>","text":"<p>Create a new workflow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Workflow name</p> required <code>description</code> <code>str</code> <p>Workflow description</p> <code>''</code> <p>Returns:</p> Type Description <code>Workflow</code> <p>The created Workflow</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def create_workflow(\n    self,\n    name: str,\n    description: str = \"\"\n) -&gt; Workflow:\n    \"\"\"Create a new workflow.\n\n    Args:\n        name: Workflow name\n        description: Workflow description\n\n    Returns:\n        The created Workflow\n    \"\"\"\n    workflow = Workflow(name=name, description=description)\n    self.workflows[workflow.id] = workflow\n    return workflow\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent.register_handler","title":"<code>register_handler(name, handler)</code>","text":"<p>Register a custom step handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Handler name</p> required <code>handler</code> <code>Callable</code> <p>Callable that takes (agent, step, context) and returns result</p> required Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def register_handler(\n    self,\n    name: str,\n    handler: Callable\n) -&gt; None:\n    \"\"\"Register a custom step handler.\n\n    Args:\n        name: Handler name\n        handler: Callable that takes (agent, step, context) and returns result\n    \"\"\"\n    self.handlers[name] = handler\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent.execute_workflow","title":"<code>execute_workflow(workflow, context=None, parallel=True)</code>  <code>async</code>","text":"<p>Execute a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Union[Workflow, str]</code> <p>Workflow instance or ID</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Initial workflow context</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>Whether to run parallel steps concurrently</p> <code>True</code> <p>Returns:</p> Type Description <code>WorkflowResult</code> <p>WorkflowResult with execution details</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>async def execute_workflow(\n    self,\n    workflow: Union[Workflow, str],\n    context: Optional[Dict[str, Any]] = None,\n    parallel: bool = True\n) -&gt; 'WorkflowResult':\n    \"\"\"Execute a workflow.\n\n    Args:\n        workflow: Workflow instance or ID\n        context: Initial workflow context\n        parallel: Whether to run parallel steps concurrently\n\n    Returns:\n        WorkflowResult with execution details\n    \"\"\"\n    # Get workflow instance\n    if isinstance(workflow, str):\n        workflow = self.workflows.get(workflow)\n        if not workflow:\n            raise AgentError(f\"Workflow '{workflow}' not found\")\n\n    # Validate workflow\n    errors = workflow.validate()\n    if errors:\n        raise AgentError(f\"Workflow validation failed: {errors}\")\n\n    # Initialize execution\n    workflow.status = StepStatus.RUNNING\n    workflow.started_at = datetime.now()\n    workflow.context = context or {}\n    self.running_workflows[workflow.id] = workflow\n\n    try:\n        # Execute workflow\n        if parallel:\n            await self._execute_parallel(workflow)\n        else:\n            await self._execute_sequential(workflow)\n\n        # Mark as completed\n        workflow.status = StepStatus.COMPLETED\n        workflow.completed_at = datetime.now()\n\n    except Exception as e:\n        workflow.status = StepStatus.FAILED\n        workflow.completed_at = datetime.now()\n        raise\n    finally:\n        del self.running_workflows[workflow.id]\n\n    # Build result\n    return WorkflowResult(\n        workflow_id=workflow.id,\n        workflow_name=workflow.name,\n        status=workflow.status,\n        duration=self._calculate_duration(workflow),\n        step_results={\n            step.name: StepResult(\n                name=step.name,\n                status=step.status,\n                result=step.result,\n                error=step.error,\n                duration=step.duration\n            )\n            for step in workflow.steps\n        },\n        context=workflow.context\n    )\n</code></pre>"},{"location":"reference/__init__/#agenticraft.WorkflowAgent.get_workflow_status","title":"<code>get_workflow_status(workflow_id)</code>","text":"<p>Get the current status of a running workflow.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get the current status of a running workflow.\"\"\"\n    workflow = self.running_workflows.get(workflow_id)\n    if not workflow:\n        return None\n\n    return {\n        \"id\": workflow.id,\n        \"name\": workflow.name,\n        \"status\": workflow.status,\n        \"steps\": {\n            step.name: {\n                \"status\": step.status,\n                \"duration\": step.duration\n            }\n            for step in workflow.steps\n        }\n    }\n</code></pre>"},{"location":"reference/__init__/#agenticraft.tool","title":"<code>tool(name=None, description=None)</code>","text":"<p>Decorator to create a tool from a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override the function name as the tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override the function docstring as description</p> <code>None</code> Example <p>Basic tool::</p> <pre><code>@tool\ndef get_weather(city: str) -&gt; str:\n    '''Get weather for a city.'''\n    return f\"Weather in {city}: Sunny\"\n</code></pre> <p>With overrides::</p> <pre><code>@tool(name=\"calc\", description=\"Calculate math\")\ndef calculate(expr: str) -&gt; float:\n    return eval(expr)\n</code></pre> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def tool(\n    name: Optional[str] = None,\n    description: Optional[str] = None\n) -&gt; Callable:\n    \"\"\"Decorator to create a tool from a function.\n\n    Args:\n        name: Override the function name as the tool name\n        description: Override the function docstring as description\n\n    Example:\n        Basic tool::\n\n            @tool\n            def get_weather(city: str) -&gt; str:\n                '''Get weather for a city.'''\n                return f\"Weather in {city}: Sunny\"\n\n        With overrides::\n\n            @tool(name=\"calc\", description=\"Calculate math\")\n            def calculate(expr: str) -&gt; float:\n                return eval(expr)\n    \"\"\"\n    def decorator(func: Callable) -&gt; FunctionTool:\n        return FunctionTool(func, name=name, description=description)\n\n    # Handle both @tool and @tool() syntax\n    if callable(name):\n        func = name\n        name = None\n        return decorator(func)\n\n    return decorator\n</code></pre>"},{"location":"reference/agents/__init__/","title":"init","text":""},{"location":"reference/agents/__init__/#agenticraft.agents","title":"<code>agents</code>","text":"<p>Pre-built agents for common use cases.</p> <p>AgentiCraft provides specialized agents that extend the base Agent class with additional capabilities for specific use cases.</p>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent","title":"<code>ReasoningAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent that exposes its reasoning process transparently.</p> <pre><code>ReasoningAgent extends the base Agent class to provide detailed\nvisibility into the reasoning process. It uses Chain of Thought\nby default and formats responses to include step-by-step thinking.\n\nExample:\n    Basic usage::\n\n        agent = ReasoningAgent(\n            name=\"Tutor\",\n            instructions=\"You are a helpful tutor who explains step-by-step.\"\n        )\n\n        response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n        print(\"Answer:\", response.content)\n        print(\"\n</code></pre> <p>Reasoning Process:\")             print(response.reasoning)</p> <pre><code>        # Access detailed reasoning\n        for step in response.reasoning_steps:\n            print(f\"{step.number}. {step.description}\")\n            if step.conclusion:\n                print(f\"   Conclusion: {step.conclusion}\")\n</code></pre> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningAgent(Agent):\n    \"\"\"An agent that exposes its reasoning process transparently.\n\n    ReasoningAgent extends the base Agent class to provide detailed\n    visibility into the reasoning process. It uses Chain of Thought\n    by default and formats responses to include step-by-step thinking.\n\n    Example:\n        Basic usage::\n\n            agent = ReasoningAgent(\n                name=\"Tutor\",\n                instructions=\"You are a helpful tutor who explains step-by-step.\"\n            )\n\n            response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n            print(\"Answer:\", response.content)\n            print(\"\\nReasoning Process:\")\n            print(response.reasoning)\n\n            # Access detailed reasoning\n            for step in response.reasoning_steps:\n                print(f\"{step.number}. {step.description}\")\n                if step.conclusion:\n                    print(f\"   Conclusion: {step.conclusion}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"ReasoningAgent\",\n        instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n        **kwargs\n    ):\n        \"\"\"Initialize ReasoningAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions (augmented with reasoning prompt)\n            **kwargs: Additional configuration passed to base Agent\n        \"\"\"\n        # Augment instructions to encourage step-by-step reasoning\n        reasoning_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n            \"For each step:\\n\"\n            \"1. State what you're doing\\n\"\n            \"2. Explain why\\n\"\n            \"3. Show any calculations or logic\\n\"\n            \"4. State your conclusion for that step\\n\\n\"\n            \"Format your response with clear sections:\\n\"\n            \"- REASONING: Your step-by-step thought process\\n\"\n            \"- ANSWER: Your final answer\\n\"\n        )\n\n        # Use Chain of Thought reasoning by default\n        if 'reasoning_pattern' not in kwargs:\n            kwargs['reasoning_pattern'] = ChainOfThought()\n\n        super().__init__(\n            name=name,\n            instructions=reasoning_instructions,\n            **kwargs\n        )\n\n        self.reasoning_history: List[ReasoningTrace] = []\n\n    async def think_and_act(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        expose_thinking: bool = True,\n        **kwargs\n    ) -&gt; 'ReasoningResponse':\n        \"\"\"Think through a problem step-by-step and act on it.\n\n        Args:\n            prompt: The problem or question to solve\n            context: Optional context\n            expose_thinking: Whether to expose internal reasoning\n            **kwargs: Additional arguments passed to LLM\n\n        Returns:\n            ReasoningResponse with detailed reasoning information\n        \"\"\"\n        # Start reasoning trace\n        trace = self._reasoning.start_trace(prompt)\n\n        # Add thinking step\n        trace.add_step(\"thinking\", {\n            \"approach\": \"step_by_step\",\n            \"expose_thinking\": expose_thinking\n        })\n\n        # If expose_thinking, add a special prompt\n        thinking_prompt = prompt\n        if expose_thinking:\n            thinking_prompt = (\n                f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n                f\"{prompt}\\n\\n\"\n                f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n            )\n\n        # Run the agent with thinking prompt\n        response = await self.arun(thinking_prompt, context, **kwargs)\n\n        # Parse the response to extract reasoning steps\n        reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n        # Store reasoning trace\n        self.reasoning_history.append(trace)\n\n        # Create enhanced response\n        return ReasoningResponse(\n            content=response.content,\n            reasoning=response.reasoning,\n            reasoning_steps=reasoning_steps,\n            reasoning_trace=trace,\n            tool_calls=response.tool_calls,\n            metadata=response.metadata,\n            agent_id=response.agent_id\n        )\n\n    def _parse_reasoning_steps(\n        self, \n        content: str, \n        trace: ReasoningTrace\n    ) -&gt; List['ReasoningStepDetail']:\n        \"\"\"Parse reasoning steps from the response content.\n\n        Args:\n            content: The response content\n            trace: The reasoning trace\n\n        Returns:\n            List of detailed reasoning steps\n        \"\"\"\n        steps = []\n\n        # Try to extract structured reasoning\n        lines = content.split('\\n')\n        current_step = None\n        step_number = 0\n        in_reasoning_section = False\n\n        for line in lines:\n            line = line.strip()\n\n            # Check for reasoning section\n            if line.upper().startswith('REASONING:'):\n                in_reasoning_section = True\n                continue\n            elif line.upper().startswith('ANSWER:'):\n                in_reasoning_section = False\n                continue\n\n            if in_reasoning_section and line:\n                # Look for numbered steps\n                if (line[0].isdigit() and '.' in line) or line.startswith('Step'):\n                    if current_step:\n                        steps.append(current_step)\n\n                    step_number += 1\n                    # Extract step description\n                    desc_start = line.find('.') + 1 if '.' in line else line.find(':') + 1\n                    description = line[desc_start:].strip()\n\n                    current_step = ReasoningStepDetail(\n                        number=step_number,\n                        description=description,\n                        details=[],\n                        conclusion=None\n                    )\n                elif current_step and line.startswith(('-', '\u2022', '*')):\n                    # Add as detail to current step\n                    current_step.details.append(line[1:].strip())\n                elif current_step and ('therefore' in line.lower() or \n                                     'conclusion:' in line.lower() or\n                                     'so,' in line.lower()):\n                    # This is a conclusion\n                    current_step.conclusion = line\n\n        # Add the last step\n        if current_step:\n            steps.append(current_step)\n\n        # If no structured steps found, create from trace\n        if not steps and trace.steps:\n            for i, trace_step in enumerate(trace.steps):\n                if trace_step.step_type not in ['analyzing_prompt', 'breakdown']:\n                    steps.append(ReasoningStepDetail(\n                        number=i + 1,\n                        description=trace_step.description,\n                        details=[f\"{k}: {v}\" for k, v in trace_step.data.items()],\n                        conclusion=None\n                    ))\n\n        return steps\n\n    async def analyze(\n        self,\n        prompt: str,\n        perspectives: List[str] = None,\n        **kwargs\n    ) -&gt; 'AnalysisResponse':\n        \"\"\"Analyze a topic from multiple perspectives.\n\n        Args:\n            prompt: The topic or question to analyze\n            perspectives: List of perspectives to consider\n            **kwargs: Additional arguments\n\n        Returns:\n            AnalysisResponse with multi-perspective analysis\n        \"\"\"\n        if perspectives is None:\n            perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n        # Build analysis prompt\n        analysis_prompt = (\n            f\"Please analyze the following from multiple perspectives:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Consider these perspectives:\\n\"\n        )\n        for perspective in perspectives:\n            analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n        analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n        # Get analysis\n        response = await self.think_and_act(analysis_prompt, **kwargs)\n\n        # Parse perspectives from response\n        perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n        return AnalysisResponse(\n            content=response.content,\n            perspectives=perspective_analyses,\n            reasoning_steps=response.reasoning_steps,\n            synthesis=self._synthesize_perspectives(perspective_analyses),\n            metadata=response.metadata\n        )\n\n    def _parse_perspectives(\n        self, \n        content: str, \n        perspectives: List[str]\n    ) -&gt; Dict[str, str]:\n        \"\"\"Parse perspective analyses from content.\"\"\"\n        analyses = {}\n        lines = content.split('\\n')\n        current_perspective = None\n        current_content = []\n\n        for line in lines:\n            # Check if this line starts a new perspective\n            for perspective in perspectives:\n                if perspective.lower() in line.lower() and 'perspective' in line.lower():\n                    if current_perspective:\n                        analyses[current_perspective] = '\\n'.join(current_content).strip()\n                    current_perspective = perspective\n                    current_content = []\n                    break\n            else:\n                if current_perspective:\n                    current_content.append(line)\n\n        # Add the last perspective\n        if current_perspective:\n            analyses[current_perspective] = '\\n'.join(current_content).strip()\n\n        return analyses\n\n    def _synthesize_perspectives(self, perspectives: Dict[str, str]) -&gt; str:\n        \"\"\"Create a synthesis of multiple perspectives.\"\"\"\n        if not perspectives:\n            return \"No perspectives to synthesize.\"\n\n        synthesis = \"Synthesis: Considering all perspectives, \"\n\n        # Simple synthesis based on perspective count\n        if len(perspectives) &gt; 1:\n            synthesis += \"this topic reveals multiple important dimensions. \"\n            synthesis += f\"The {', '.join(perspectives.keys())} perspectives \"\n            synthesis += \"each contribute valuable insights that should be balanced.\"\n        else:\n            key = list(perspectives.keys())[0]\n            synthesis += f\"the {key} perspective provides the primary framework for understanding.\"\n\n        return synthesis\n\n    def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n        \"\"\"Get recent reasoning history.\n\n        Args:\n            limit: Maximum number of traces to return\n\n        Returns:\n            List of recent reasoning traces\n        \"\"\"\n        return self.reasoning_history[-limit:]\n\n    def explain_last_response(self) -&gt; str:\n        \"\"\"Explain the reasoning behind the last response.\"\"\"\n        if not self.reasoning_history:\n            return \"No reasoning history available.\"\n\n        last_trace = self.reasoning_history[-1]\n        return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent.__init__","title":"<code>__init__(name='ReasoningAgent', instructions='You are a helpful assistant that explains your reasoning step-by-step.', **kwargs)</code>","text":"<p>Initialize ReasoningAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'ReasoningAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions (augmented with reasoning prompt)</p> <code>'You are a helpful assistant that explains your reasoning step-by-step.'</code> <code>**kwargs</code> <p>Additional configuration passed to base Agent</p> <code>{}</code> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"ReasoningAgent\",\n    instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n    **kwargs\n):\n    \"\"\"Initialize ReasoningAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions (augmented with reasoning prompt)\n        **kwargs: Additional configuration passed to base Agent\n    \"\"\"\n    # Augment instructions to encourage step-by-step reasoning\n    reasoning_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n        \"For each step:\\n\"\n        \"1. State what you're doing\\n\"\n        \"2. Explain why\\n\"\n        \"3. Show any calculations or logic\\n\"\n        \"4. State your conclusion for that step\\n\\n\"\n        \"Format your response with clear sections:\\n\"\n        \"- REASONING: Your step-by-step thought process\\n\"\n        \"- ANSWER: Your final answer\\n\"\n    )\n\n    # Use Chain of Thought reasoning by default\n    if 'reasoning_pattern' not in kwargs:\n        kwargs['reasoning_pattern'] = ChainOfThought()\n\n    super().__init__(\n        name=name,\n        instructions=reasoning_instructions,\n        **kwargs\n    )\n\n    self.reasoning_history: List[ReasoningTrace] = []\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent.think_and_act","title":"<code>think_and_act(prompt, context=None, expose_thinking=True, **kwargs)</code>  <code>async</code>","text":"<p>Think through a problem step-by-step and act on it.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The problem or question to solve</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context</p> <code>None</code> <code>expose_thinking</code> <code>bool</code> <p>Whether to expose internal reasoning</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>ReasoningResponse</code> <p>ReasoningResponse with detailed reasoning information</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def think_and_act(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    expose_thinking: bool = True,\n    **kwargs\n) -&gt; 'ReasoningResponse':\n    \"\"\"Think through a problem step-by-step and act on it.\n\n    Args:\n        prompt: The problem or question to solve\n        context: Optional context\n        expose_thinking: Whether to expose internal reasoning\n        **kwargs: Additional arguments passed to LLM\n\n    Returns:\n        ReasoningResponse with detailed reasoning information\n    \"\"\"\n    # Start reasoning trace\n    trace = self._reasoning.start_trace(prompt)\n\n    # Add thinking step\n    trace.add_step(\"thinking\", {\n        \"approach\": \"step_by_step\",\n        \"expose_thinking\": expose_thinking\n    })\n\n    # If expose_thinking, add a special prompt\n    thinking_prompt = prompt\n    if expose_thinking:\n        thinking_prompt = (\n            f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n        )\n\n    # Run the agent with thinking prompt\n    response = await self.arun(thinking_prompt, context, **kwargs)\n\n    # Parse the response to extract reasoning steps\n    reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n    # Store reasoning trace\n    self.reasoning_history.append(trace)\n\n    # Create enhanced response\n    return ReasoningResponse(\n        content=response.content,\n        reasoning=response.reasoning,\n        reasoning_steps=reasoning_steps,\n        reasoning_trace=trace,\n        tool_calls=response.tool_calls,\n        metadata=response.metadata,\n        agent_id=response.agent_id\n    )\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent.analyze","title":"<code>analyze(prompt, perspectives=None, **kwargs)</code>  <code>async</code>","text":"<p>Analyze a topic from multiple perspectives.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The topic or question to analyze</p> required <code>perspectives</code> <code>List[str]</code> <p>List of perspectives to consider</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnalysisResponse</code> <p>AnalysisResponse with multi-perspective analysis</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def analyze(\n    self,\n    prompt: str,\n    perspectives: List[str] = None,\n    **kwargs\n) -&gt; 'AnalysisResponse':\n    \"\"\"Analyze a topic from multiple perspectives.\n\n    Args:\n        prompt: The topic or question to analyze\n        perspectives: List of perspectives to consider\n        **kwargs: Additional arguments\n\n    Returns:\n        AnalysisResponse with multi-perspective analysis\n    \"\"\"\n    if perspectives is None:\n        perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n    # Build analysis prompt\n    analysis_prompt = (\n        f\"Please analyze the following from multiple perspectives:\\n\\n\"\n        f\"{prompt}\\n\\n\"\n        f\"Consider these perspectives:\\n\"\n    )\n    for perspective in perspectives:\n        analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n    analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n    # Get analysis\n    response = await self.think_and_act(analysis_prompt, **kwargs)\n\n    # Parse perspectives from response\n    perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n    return AnalysisResponse(\n        content=response.content,\n        perspectives=perspective_analyses,\n        reasoning_steps=response.reasoning_steps,\n        synthesis=self._synthesize_perspectives(perspective_analyses),\n        metadata=response.metadata\n    )\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent.get_reasoning_history","title":"<code>get_reasoning_history(limit=10)</code>","text":"<p>Get recent reasoning history.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of traces to return</p> <code>10</code> <p>Returns:</p> Type Description <code>List[ReasoningTrace]</code> <p>List of recent reasoning traces</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n    \"\"\"Get recent reasoning history.\n\n    Args:\n        limit: Maximum number of traces to return\n\n    Returns:\n        List of recent reasoning traces\n    \"\"\"\n    return self.reasoning_history[-limit:]\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningAgent.explain_last_response","title":"<code>explain_last_response()</code>","text":"<p>Explain the reasoning behind the last response.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def explain_last_response(self) -&gt; str:\n    \"\"\"Explain the reasoning behind the last response.\"\"\"\n    if not self.reasoning_history:\n        return \"No reasoning history available.\"\n\n    last_trace = self.reasoning_history[-1]\n    return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningResponse","title":"<code>ReasoningResponse</code>","text":"<p>               Bases: <code>AgentResponse</code></p> <p>Enhanced response with detailed reasoning information.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningResponse(AgentResponse):\n    \"\"\"Enhanced response with detailed reasoning information.\"\"\"\n\n    reasoning_steps: List[ReasoningStepDetail] = Field(default_factory=list)\n    reasoning_trace: Optional[ReasoningTrace] = None\n\n    @property\n    def step_count(self) -&gt; int:\n        \"\"\"Get the number of reasoning steps.\"\"\"\n        return len(self.reasoning_steps)\n\n    def get_step(self, number: int) -&gt; Optional[ReasoningStepDetail]:\n        \"\"\"Get a specific reasoning step by number.\"\"\"\n        for step in self.reasoning_steps:\n            if step.number == number:\n                return step\n        return None\n\n    def format_reasoning(self) -&gt; str:\n        \"\"\"Format reasoning steps as readable text.\"\"\"\n        if not self.reasoning_steps:\n            return \"No detailed reasoning steps available.\"\n\n        lines = [\"Reasoning Process:\"]\n        for step in self.reasoning_steps:\n            lines.append(f\"\\n{step.number}. {step.description}\")\n            for detail in step.details:\n                lines.append(f\"   - {detail}\")\n            if step.conclusion:\n                lines.append(f\"   \u2192 {step.conclusion}\")\n\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningResponse.step_count","title":"<code>step_count</code>  <code>property</code>","text":"<p>Get the number of reasoning steps.</p>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningResponse.get_step","title":"<code>get_step(number)</code>","text":"<p>Get a specific reasoning step by number.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_step(self, number: int) -&gt; Optional[ReasoningStepDetail]:\n    \"\"\"Get a specific reasoning step by number.\"\"\"\n    for step in self.reasoning_steps:\n        if step.number == number:\n            return step\n    return None\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningResponse.format_reasoning","title":"<code>format_reasoning()</code>","text":"<p>Format reasoning steps as readable text.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def format_reasoning(self) -&gt; str:\n    \"\"\"Format reasoning steps as readable text.\"\"\"\n    if not self.reasoning_steps:\n        return \"No detailed reasoning steps available.\"\n\n    lines = [\"Reasoning Process:\"]\n    for step in self.reasoning_steps:\n        lines.append(f\"\\n{step.number}. {step.description}\")\n        for detail in step.details:\n            lines.append(f\"   - {detail}\")\n        if step.conclusion:\n            lines.append(f\"   \u2192 {step.conclusion}\")\n\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningStepDetail","title":"<code>ReasoningStepDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Detailed information about a reasoning step.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningStepDetail(BaseModel):\n    \"\"\"Detailed information about a reasoning step.\"\"\"\n\n    number: int\n    description: str\n    details: List[str] = Field(default_factory=list)\n    conclusion: Optional[str] = None\n    confidence: float = Field(default=1.0, ge=0.0, le=1.0)\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the step.\"\"\"\n        s = f\"Step {self.number}: {self.description}\"\n        if self.details:\n            s += f\" (Details: {len(self.details)})\"\n        if self.conclusion:\n            s += f\" \u2192 {self.conclusion}\"\n        return s\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.ReasoningStepDetail.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the step.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the step.\"\"\"\n    s = f\"Step {self.number}: {self.description}\"\n    if self.details:\n        s += f\" (Details: {len(self.details)})\"\n    if self.conclusion:\n        s += f\" \u2192 {self.conclusion}\"\n    return s\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.AnalysisResponse","title":"<code>AnalysisResponse</code>","text":"<p>               Bases: <code>ReasoningResponse</code></p> <p>Response from multi-perspective analysis.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class AnalysisResponse(ReasoningResponse):\n    \"\"\"Response from multi-perspective analysis.\"\"\"\n\n    perspectives: Dict[str, str] = Field(default_factory=dict)\n    synthesis: str = \"\"\n\n    def get_perspective(self, name: str) -&gt; Optional[str]:\n        \"\"\"Get analysis for a specific perspective.\"\"\"\n        return self.perspectives.get(name)\n\n    def format_analysis(self) -&gt; str:\n        \"\"\"Format the complete analysis.\"\"\"\n        lines = [\"Multi-Perspective Analysis:\"]\n\n        for perspective, analysis in self.perspectives.items():\n            lines.append(f\"\\n{perspective.upper()} PERSPECTIVE:\")\n            lines.append(analysis)\n\n        if self.synthesis:\n            lines.append(f\"\\n{self.synthesis}\")\n\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.AnalysisResponse.get_perspective","title":"<code>get_perspective(name)</code>","text":"<p>Get analysis for a specific perspective.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_perspective(self, name: str) -&gt; Optional[str]:\n    \"\"\"Get analysis for a specific perspective.\"\"\"\n    return self.perspectives.get(name)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.AnalysisResponse.format_analysis","title":"<code>format_analysis()</code>","text":"<p>Format the complete analysis.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def format_analysis(self) -&gt; str:\n    \"\"\"Format the complete analysis.\"\"\"\n    lines = [\"Multi-Perspective Analysis:\"]\n\n    for perspective, analysis in self.perspectives.items():\n        lines.append(f\"\\n{perspective.upper()} PERSPECTIVE:\")\n        lines.append(analysis)\n\n    if self.synthesis:\n        lines.append(f\"\\n{self.synthesis}\")\n\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent","title":"<code>WorkflowAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent optimized for executing multi-step workflows.</p> <p>WorkflowAgent extends the base Agent to provide workflow execution capabilities including step dependencies, parallel execution, conditional logic, and error handling.</p> Example <p>Basic workflow::</p> <pre><code>agent = WorkflowAgent(name=\"DataProcessor\")\n\n# Define workflow\nworkflow = agent.create_workflow(\"data_pipeline\")\nworkflow.add_step(\"fetch\", \"Fetch data from the API\")\nworkflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\nworkflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\nworkflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n# Execute workflow\nresult = await agent.execute_workflow(workflow)\n\n# Check results\nfor step_name, step_result in result.step_results.items():\n    print(f\"{step_name}: {step_result.status}\")\n</code></pre> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowAgent(Agent):\n    \"\"\"An agent optimized for executing multi-step workflows.\n\n    WorkflowAgent extends the base Agent to provide workflow execution\n    capabilities including step dependencies, parallel execution,\n    conditional logic, and error handling.\n\n    Example:\n        Basic workflow::\n\n            agent = WorkflowAgent(name=\"DataProcessor\")\n\n            # Define workflow\n            workflow = agent.create_workflow(\"data_pipeline\")\n            workflow.add_step(\"fetch\", \"Fetch data from the API\")\n            workflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\n            workflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\n            workflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n            # Execute workflow\n            result = await agent.execute_workflow(workflow)\n\n            # Check results\n            for step_name, step_result in result.step_results.items():\n                print(f\"{step_name}: {step_result.status}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"WorkflowAgent\",\n        instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n        **kwargs\n    ):\n        \"\"\"Initialize WorkflowAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions\n            **kwargs: Additional configuration\n        \"\"\"\n        # Augment instructions for workflow execution\n        workflow_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"When executing workflow steps:\\n\"\n            \"1. Follow the exact instructions for each step\\n\"\n            \"2. Use the context from previous steps when needed\\n\"\n            \"3. Provide clear, actionable output\\n\"\n            \"4. Report any issues or blockers immediately\"\n        )\n\n        super().__init__(\n            name=name,\n            instructions=workflow_instructions,\n            **kwargs\n        )\n\n        self.workflows: Dict[str, Workflow] = {}\n        self.handlers: Dict[str, Callable] = {}\n        self.running_workflows: Dict[str, Workflow] = {}\n\n    def create_workflow(\n        self,\n        name: str,\n        description: str = \"\"\n    ) -&gt; Workflow:\n        \"\"\"Create a new workflow.\n\n        Args:\n            name: Workflow name\n            description: Workflow description\n\n        Returns:\n            The created Workflow\n        \"\"\"\n        workflow = Workflow(name=name, description=description)\n        self.workflows[workflow.id] = workflow\n        return workflow\n\n    def register_handler(\n        self,\n        name: str,\n        handler: Callable\n    ) -&gt; None:\n        \"\"\"Register a custom step handler.\n\n        Args:\n            name: Handler name\n            handler: Callable that takes (agent, step, context) and returns result\n        \"\"\"\n        self.handlers[name] = handler\n\n    async def execute_workflow(\n        self,\n        workflow: Union[Workflow, str],\n        context: Optional[Dict[str, Any]] = None,\n        parallel: bool = True\n    ) -&gt; 'WorkflowResult':\n        \"\"\"Execute a workflow.\n\n        Args:\n            workflow: Workflow instance or ID\n            context: Initial workflow context\n            parallel: Whether to run parallel steps concurrently\n\n        Returns:\n            WorkflowResult with execution details\n        \"\"\"\n        # Get workflow instance\n        if isinstance(workflow, str):\n            workflow = self.workflows.get(workflow)\n            if not workflow:\n                raise AgentError(f\"Workflow '{workflow}' not found\")\n\n        # Validate workflow\n        errors = workflow.validate()\n        if errors:\n            raise AgentError(f\"Workflow validation failed: {errors}\")\n\n        # Initialize execution\n        workflow.status = StepStatus.RUNNING\n        workflow.started_at = datetime.now()\n        workflow.context = context or {}\n        self.running_workflows[workflow.id] = workflow\n\n        try:\n            # Execute workflow\n            if parallel:\n                await self._execute_parallel(workflow)\n            else:\n                await self._execute_sequential(workflow)\n\n            # Mark as completed\n            workflow.status = StepStatus.COMPLETED\n            workflow.completed_at = datetime.now()\n\n        except Exception as e:\n            workflow.status = StepStatus.FAILED\n            workflow.completed_at = datetime.now()\n            raise\n        finally:\n            del self.running_workflows[workflow.id]\n\n        # Build result\n        return WorkflowResult(\n            workflow_id=workflow.id,\n            workflow_name=workflow.name,\n            status=workflow.status,\n            duration=self._calculate_duration(workflow),\n            step_results={\n                step.name: StepResult(\n                    name=step.name,\n                    status=step.status,\n                    result=step.result,\n                    error=step.error,\n                    duration=step.duration\n                )\n                for step in workflow.steps\n            },\n            context=workflow.context\n        )\n\n    async def _execute_sequential(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow steps sequentially.\"\"\"\n        completed_steps = []\n\n        while True:\n            # Get next ready step\n            ready_steps = workflow.get_ready_steps()\n            if not ready_steps:\n                break\n\n            # Execute first ready step\n            step = ready_steps[0]\n            await self._execute_step(step, workflow)\n\n            if step.status == StepStatus.COMPLETED:\n                completed_steps.append(step.name)\n\n    async def _execute_parallel(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow with parallel step support.\"\"\"\n        completed_steps = set()\n        pending_tasks = {}\n\n        while True:\n            # Get ready steps\n            ready_steps = workflow.get_ready_steps()\n\n            # Start tasks for ready steps\n            for step in ready_steps:\n                if step.name not in pending_tasks:\n                    task = asyncio.create_task(self._execute_step(step, workflow))\n                    pending_tasks[step.name] = (step, task)\n\n            # If no pending tasks, we're done\n            if not pending_tasks:\n                break\n\n            # Wait for any task to complete\n            done, pending = await asyncio.wait(\n                [task for _, task in pending_tasks.values()],\n                return_when=asyncio.FIRST_COMPLETED\n            )\n\n            # Process completed tasks\n            for task in done:\n                # Find which step this task belongs to\n                for step_name, (step, step_task) in list(pending_tasks.items()):\n                    if step_task == task:\n                        del pending_tasks[step_name]\n                        if step.status == StepStatus.COMPLETED:\n                            completed_steps.add(step_name)\n                        break\n\n    async def _execute_step(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; None:\n        \"\"\"Execute a single workflow step.\"\"\"\n        step.status = StepStatus.RUNNING\n        step.started_at = datetime.now()\n\n        try:\n            # Check condition if present\n            if step.condition and not self._evaluate_condition(step.condition, workflow.context):\n                step.status = StepStatus.SKIPPED\n                step.result = \"Skipped due to condition\"\n                return\n\n            # Execute with timeout if specified\n            if step.timeout:\n                result = await asyncio.wait_for(\n                    self._run_step_action(step, workflow),\n                    timeout=step.timeout\n                )\n            else:\n                result = await self._run_step_action(step, workflow)\n\n            # Store result\n            step.result = result\n            step.status = StepStatus.COMPLETED\n\n            # Update workflow context\n            workflow.context[f\"{step.name}_result\"] = result\n\n        except asyncio.TimeoutError:\n            step.error = f\"Step timed out after {step.timeout} seconds\"\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        except Exception as e:\n            step.error = str(e)\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        finally:\n            if step.status in [StepStatus.COMPLETED, StepStatus.FAILED, StepStatus.SKIPPED]:\n                step.completed_at = datetime.now()\n\n    async def _run_step_action(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; Any:\n        \"\"\"Run the action for a step.\"\"\"\n        # Use custom handler if specified\n        if step.handler and step.handler in self.handlers:\n            handler = self.handlers[step.handler]\n            if asyncio.iscoroutinefunction(handler):\n                return await handler(self, step, workflow.context)\n            else:\n                return handler(self, step, workflow.context)\n\n        # Use action prompt\n        if step.action:\n            # Build prompt with context\n            prompt = f\"Execute the following step: {step.action}\"\n\n            # Add relevant context\n            if workflow.context:\n                relevant_context = {\n                    k: v for k, v in workflow.context.items()\n                    if any(dep in k for dep in step.depends_on) or k in ['initial_input', 'user_request']\n                }\n                if relevant_context:\n                    prompt += f\"\\n\\nContext from previous steps:\\n{relevant_context}\"\n\n            # Execute with agent\n            response = await self.arun(prompt)\n            return response.content\n\n        # No action defined\n        return f\"Step '{step.name}' completed\"\n\n    def _evaluate_condition(\n        self,\n        condition: str,\n        context: Dict[str, Any]\n    ) -&gt; bool:\n        \"\"\"Evaluate a step condition.\n\n        Simple evaluation - in production, use a safe expression evaluator.\n        \"\"\"\n        try:\n            # Very basic condition evaluation\n            # In production, use a proper expression evaluator\n            if \"==\" in condition:\n                parts = condition.split(\"==\")\n                if len(parts) == 2:\n                    left = parts[0].strip()\n                    right = parts[1].strip().strip(\"'\\\"\")\n                    return str(context.get(left, \"\")) == right\n\n            # Default to True if we can't evaluate\n            return True\n\n        except Exception:\n            return True\n\n    def _calculate_duration(self, workflow: Workflow) -&gt; float:\n        \"\"\"Calculate total workflow duration.\"\"\"\n        if not workflow.started_at or not workflow.completed_at:\n            return 0.0\n        return (workflow.completed_at - workflow.started_at).total_seconds()\n\n    def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get the current status of a running workflow.\"\"\"\n        workflow = self.running_workflows.get(workflow_id)\n        if not workflow:\n            return None\n\n        return {\n            \"id\": workflow.id,\n            \"name\": workflow.name,\n            \"status\": workflow.status,\n            \"steps\": {\n                step.name: {\n                    \"status\": step.status,\n                    \"duration\": step.duration\n                }\n                for step in workflow.steps\n            }\n        }\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent.__init__","title":"<code>__init__(name='WorkflowAgent', instructions='You are a workflow execution agent. Follow the steps precisely.', **kwargs)</code>","text":"<p>Initialize WorkflowAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'WorkflowAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions</p> <code>'You are a workflow execution agent. Follow the steps precisely.'</code> <code>**kwargs</code> <p>Additional configuration</p> <code>{}</code> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"WorkflowAgent\",\n    instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n    **kwargs\n):\n    \"\"\"Initialize WorkflowAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions\n        **kwargs: Additional configuration\n    \"\"\"\n    # Augment instructions for workflow execution\n    workflow_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"When executing workflow steps:\\n\"\n        \"1. Follow the exact instructions for each step\\n\"\n        \"2. Use the context from previous steps when needed\\n\"\n        \"3. Provide clear, actionable output\\n\"\n        \"4. Report any issues or blockers immediately\"\n    )\n\n    super().__init__(\n        name=name,\n        instructions=workflow_instructions,\n        **kwargs\n    )\n\n    self.workflows: Dict[str, Workflow] = {}\n    self.handlers: Dict[str, Callable] = {}\n    self.running_workflows: Dict[str, Workflow] = {}\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent.create_workflow","title":"<code>create_workflow(name, description='')</code>","text":"<p>Create a new workflow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Workflow name</p> required <code>description</code> <code>str</code> <p>Workflow description</p> <code>''</code> <p>Returns:</p> Type Description <code>Workflow</code> <p>The created Workflow</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def create_workflow(\n    self,\n    name: str,\n    description: str = \"\"\n) -&gt; Workflow:\n    \"\"\"Create a new workflow.\n\n    Args:\n        name: Workflow name\n        description: Workflow description\n\n    Returns:\n        The created Workflow\n    \"\"\"\n    workflow = Workflow(name=name, description=description)\n    self.workflows[workflow.id] = workflow\n    return workflow\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent.register_handler","title":"<code>register_handler(name, handler)</code>","text":"<p>Register a custom step handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Handler name</p> required <code>handler</code> <code>Callable</code> <p>Callable that takes (agent, step, context) and returns result</p> required Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def register_handler(\n    self,\n    name: str,\n    handler: Callable\n) -&gt; None:\n    \"\"\"Register a custom step handler.\n\n    Args:\n        name: Handler name\n        handler: Callable that takes (agent, step, context) and returns result\n    \"\"\"\n    self.handlers[name] = handler\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent.execute_workflow","title":"<code>execute_workflow(workflow, context=None, parallel=True)</code>  <code>async</code>","text":"<p>Execute a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Union[Workflow, str]</code> <p>Workflow instance or ID</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Initial workflow context</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>Whether to run parallel steps concurrently</p> <code>True</code> <p>Returns:</p> Type Description <code>WorkflowResult</code> <p>WorkflowResult with execution details</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>async def execute_workflow(\n    self,\n    workflow: Union[Workflow, str],\n    context: Optional[Dict[str, Any]] = None,\n    parallel: bool = True\n) -&gt; 'WorkflowResult':\n    \"\"\"Execute a workflow.\n\n    Args:\n        workflow: Workflow instance or ID\n        context: Initial workflow context\n        parallel: Whether to run parallel steps concurrently\n\n    Returns:\n        WorkflowResult with execution details\n    \"\"\"\n    # Get workflow instance\n    if isinstance(workflow, str):\n        workflow = self.workflows.get(workflow)\n        if not workflow:\n            raise AgentError(f\"Workflow '{workflow}' not found\")\n\n    # Validate workflow\n    errors = workflow.validate()\n    if errors:\n        raise AgentError(f\"Workflow validation failed: {errors}\")\n\n    # Initialize execution\n    workflow.status = StepStatus.RUNNING\n    workflow.started_at = datetime.now()\n    workflow.context = context or {}\n    self.running_workflows[workflow.id] = workflow\n\n    try:\n        # Execute workflow\n        if parallel:\n            await self._execute_parallel(workflow)\n        else:\n            await self._execute_sequential(workflow)\n\n        # Mark as completed\n        workflow.status = StepStatus.COMPLETED\n        workflow.completed_at = datetime.now()\n\n    except Exception as e:\n        workflow.status = StepStatus.FAILED\n        workflow.completed_at = datetime.now()\n        raise\n    finally:\n        del self.running_workflows[workflow.id]\n\n    # Build result\n    return WorkflowResult(\n        workflow_id=workflow.id,\n        workflow_name=workflow.name,\n        status=workflow.status,\n        duration=self._calculate_duration(workflow),\n        step_results={\n            step.name: StepResult(\n                name=step.name,\n                status=step.status,\n                result=step.result,\n                error=step.error,\n                duration=step.duration\n            )\n            for step in workflow.steps\n        },\n        context=workflow.context\n    )\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowAgent.get_workflow_status","title":"<code>get_workflow_status(workflow_id)</code>","text":"<p>Get the current status of a running workflow.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get the current status of a running workflow.\"\"\"\n    workflow = self.running_workflows.get(workflow_id)\n    if not workflow:\n        return None\n\n    return {\n        \"id\": workflow.id,\n        \"name\": workflow.name,\n        \"status\": workflow.status,\n        \"steps\": {\n            step.name: {\n                \"status\": step.status,\n                \"duration\": step.duration\n            }\n            for step in workflow.steps\n        }\n    }\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.Workflow","title":"<code>Workflow</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A workflow definition.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class Workflow(BaseModel):\n    \"\"\"A workflow definition.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    name: str\n    description: str = \"\"\n    steps: List[WorkflowStep] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # Runtime state\n    status: StepStatus = StepStatus.PENDING\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    context: Dict[str, Any] = Field(default_factory=dict)\n\n    def add_step(\n        self,\n        name: str,\n        action: Optional[str] = None,\n        handler: Optional[str] = None,\n        depends_on: Optional[List[str]] = None,\n        **kwargs\n    ) -&gt; WorkflowStep:\n        \"\"\"Add a step to the workflow.\n\n        Args:\n            name: Step name\n            action: Prompt or action to execute\n            handler: Custom handler function name\n            depends_on: List of step names this depends on\n            **kwargs: Additional step configuration\n\n        Returns:\n            The created WorkflowStep\n        \"\"\"\n        step = WorkflowStep(\n            name=name,\n            action=action,\n            handler=handler,\n            depends_on=depends_on or [],\n            **kwargs\n        )\n        self.steps.append(step)\n        return step\n\n    def get_step(self, name: str) -&gt; Optional[WorkflowStep]:\n        \"\"\"Get a step by name.\"\"\"\n        for step in self.steps:\n            if step.name == name:\n                return step\n        return None\n\n    def get_ready_steps(self) -&gt; List[WorkflowStep]:\n        \"\"\"Get all steps that are ready to run.\"\"\"\n        completed = [s.name for s in self.steps if s.status == StepStatus.COMPLETED]\n        ready = []\n\n        for step in self.steps:\n            if step.status == StepStatus.PENDING and step.can_run(completed):\n                ready.append(step)\n\n        return ready\n\n    def validate(self) -&gt; List[str]:\n        \"\"\"Validate the workflow configuration.\n\n        Returns:\n            List of validation errors (empty if valid)\n        \"\"\"\n        errors = []\n        step_names = {step.name for step in self.steps}\n\n        # Check for duplicate names\n        if len(step_names) != len(self.steps):\n            errors.append(\"Duplicate step names found\")\n\n        # Check dependencies\n        for step in self.steps:\n            for dep in step.depends_on:\n                if dep not in step_names:\n                    errors.append(f\"Step '{step.name}' depends on unknown step '{dep}'\")\n\n        # Check for circular dependencies\n        for step in self.steps:\n            if self._has_circular_dependency(step, step_names):\n                errors.append(f\"Circular dependency detected for step '{step.name}'\")\n\n        return errors\n\n    def _has_circular_dependency(\n        self, \n        step: WorkflowStep, \n        all_steps: set,\n        visited: Optional[set] = None\n    ) -&gt; bool:\n        \"\"\"Check if a step has circular dependencies.\"\"\"\n        if visited is None:\n            visited = set()\n\n        if step.name in visited:\n            return True\n\n        visited.add(step.name)\n\n        for dep_name in step.depends_on:\n            dep_step = self.get_step(dep_name)\n            if dep_step and self._has_circular_dependency(dep_step, all_steps, visited.copy()):\n                return True\n\n        return False\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.Workflow.add_step","title":"<code>add_step(name, action=None, handler=None, depends_on=None, **kwargs)</code>","text":"<p>Add a step to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Step name</p> required <code>action</code> <code>Optional[str]</code> <p>Prompt or action to execute</p> <code>None</code> <code>handler</code> <code>Optional[str]</code> <p>Custom handler function name</p> <code>None</code> <code>depends_on</code> <code>Optional[List[str]]</code> <p>List of step names this depends on</p> <code>None</code> <code>**kwargs</code> <p>Additional step configuration</p> <code>{}</code> <p>Returns:</p> Type Description <code>WorkflowStep</code> <p>The created WorkflowStep</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def add_step(\n    self,\n    name: str,\n    action: Optional[str] = None,\n    handler: Optional[str] = None,\n    depends_on: Optional[List[str]] = None,\n    **kwargs\n) -&gt; WorkflowStep:\n    \"\"\"Add a step to the workflow.\n\n    Args:\n        name: Step name\n        action: Prompt or action to execute\n        handler: Custom handler function name\n        depends_on: List of step names this depends on\n        **kwargs: Additional step configuration\n\n    Returns:\n        The created WorkflowStep\n    \"\"\"\n    step = WorkflowStep(\n        name=name,\n        action=action,\n        handler=handler,\n        depends_on=depends_on or [],\n        **kwargs\n    )\n    self.steps.append(step)\n    return step\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.Workflow.get_step","title":"<code>get_step(name)</code>","text":"<p>Get a step by name.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_step(self, name: str) -&gt; Optional[WorkflowStep]:\n    \"\"\"Get a step by name.\"\"\"\n    for step in self.steps:\n        if step.name == name:\n            return step\n    return None\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.Workflow.get_ready_steps","title":"<code>get_ready_steps()</code>","text":"<p>Get all steps that are ready to run.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_ready_steps(self) -&gt; List[WorkflowStep]:\n    \"\"\"Get all steps that are ready to run.\"\"\"\n    completed = [s.name for s in self.steps if s.status == StepStatus.COMPLETED]\n    ready = []\n\n    for step in self.steps:\n        if step.status == StepStatus.PENDING and step.can_run(completed):\n            ready.append(step)\n\n    return ready\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.Workflow.validate","title":"<code>validate()</code>","text":"<p>Validate the workflow configuration.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of validation errors (empty if valid)</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def validate(self) -&gt; List[str]:\n    \"\"\"Validate the workflow configuration.\n\n    Returns:\n        List of validation errors (empty if valid)\n    \"\"\"\n    errors = []\n    step_names = {step.name for step in self.steps}\n\n    # Check for duplicate names\n    if len(step_names) != len(self.steps):\n        errors.append(\"Duplicate step names found\")\n\n    # Check dependencies\n    for step in self.steps:\n        for dep in step.depends_on:\n            if dep not in step_names:\n                errors.append(f\"Step '{step.name}' depends on unknown step '{dep}'\")\n\n    # Check for circular dependencies\n    for step in self.steps:\n        if self._has_circular_dependency(step, step_names):\n            errors.append(f\"Circular dependency detected for step '{step.name}'\")\n\n    return errors\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowStep","title":"<code>WorkflowStep</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single step in a workflow.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowStep(BaseModel):\n    \"\"\"A single step in a workflow.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    name: str\n    description: str = \"\"\n    action: Optional[str] = None  # Prompt or action to execute\n    handler: Optional[str] = None  # Name of custom handler function\n    depends_on: List[str] = Field(default_factory=list)\n    condition: Optional[str] = None  # Condition to evaluate\n    parallel: bool = False\n    retry_count: int = 0\n    max_retries: int = 3\n    timeout: Optional[float] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # Runtime state\n    status: StepStatus = StepStatus.PENDING\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n\n    @property\n    def duration(self) -&gt; Optional[float]:\n        \"\"\"Get step duration in seconds.\"\"\"\n        if not self.started_at or not self.completed_at:\n            return None\n        return (self.completed_at - self.started_at).total_seconds()\n\n    def can_run(self, completed_steps: List[str]) -&gt; bool:\n        \"\"\"Check if this step can run based on dependencies.\"\"\"\n        return all(dep in completed_steps for dep in self.depends_on)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowStep.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Get step duration in seconds.</p>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowStep.can_run","title":"<code>can_run(completed_steps)</code>","text":"<p>Check if this step can run based on dependencies.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def can_run(self, completed_steps: List[str]) -&gt; bool:\n    \"\"\"Check if this step can run based on dependencies.\"\"\"\n    return all(dep in completed_steps for dep in self.depends_on)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowResult","title":"<code>WorkflowResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from workflow execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowResult(BaseModel):\n    \"\"\"Result from workflow execution.\"\"\"\n\n    workflow_id: str\n    workflow_name: str\n    status: StepStatus\n    duration: float\n    step_results: Dict[str, StepResult]\n    context: Dict[str, Any] = Field(default_factory=dict)\n\n    @property\n    def successful(self) -&gt; bool:\n        \"\"\"Check if workflow completed successfully.\"\"\"\n        return self.status == StepStatus.COMPLETED\n\n    @property\n    def failed_steps(self) -&gt; List[str]:\n        \"\"\"Get list of failed step names.\"\"\"\n        return [\n            name for name, result in self.step_results.items()\n            if result.status == StepStatus.FAILED\n        ]\n\n    def get_step_result(self, step_name: str) -&gt; Optional[Any]:\n        \"\"\"Get the result of a specific step.\"\"\"\n        step = self.step_results.get(step_name)\n        return step.result if step else None\n\n    def format_summary(self) -&gt; str:\n        \"\"\"Format a summary of the workflow execution.\"\"\"\n        lines = [\n            f\"Workflow: {self.workflow_name}\",\n            f\"Status: {self.status}\",\n            f\"Duration: {self.duration:.2f}s\",\n            \"\\nStep Results:\"\n        ]\n\n        for name, result in self.step_results.items():\n            status_emoji = {\n                StepStatus.COMPLETED: \"\u2705\",\n                StepStatus.FAILED: \"\u274c\",\n                StepStatus.SKIPPED: \"\u23ed\ufe0f\",\n                StepStatus.PENDING: \"\u23f8\ufe0f\",\n                StepStatus.RUNNING: \"\ud83d\udd04\"\n            }.get(result.status, \"\u2753\")\n\n            line = f\"  {status_emoji} {name}: {result.status}\"\n            if result.duration:\n                line += f\" ({result.duration:.2f}s)\"\n            if result.error:\n                line += f\" - Error: {result.error}\"\n\n            lines.append(line)\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowResult.successful","title":"<code>successful</code>  <code>property</code>","text":"<p>Check if workflow completed successfully.</p>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowResult.failed_steps","title":"<code>failed_steps</code>  <code>property</code>","text":"<p>Get list of failed step names.</p>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowResult.get_step_result","title":"<code>get_step_result(step_name)</code>","text":"<p>Get the result of a specific step.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_step_result(self, step_name: str) -&gt; Optional[Any]:\n    \"\"\"Get the result of a specific step.\"\"\"\n    step = self.step_results.get(step_name)\n    return step.result if step else None\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.WorkflowResult.format_summary","title":"<code>format_summary()</code>","text":"<p>Format a summary of the workflow execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def format_summary(self) -&gt; str:\n    \"\"\"Format a summary of the workflow execution.\"\"\"\n    lines = [\n        f\"Workflow: {self.workflow_name}\",\n        f\"Status: {self.status}\",\n        f\"Duration: {self.duration:.2f}s\",\n        \"\\nStep Results:\"\n    ]\n\n    for name, result in self.step_results.items():\n        status_emoji = {\n            StepStatus.COMPLETED: \"\u2705\",\n            StepStatus.FAILED: \"\u274c\",\n            StepStatus.SKIPPED: \"\u23ed\ufe0f\",\n            StepStatus.PENDING: \"\u23f8\ufe0f\",\n            StepStatus.RUNNING: \"\ud83d\udd04\"\n        }.get(result.status, \"\u2753\")\n\n        line = f\"  {status_emoji} {name}: {result.status}\"\n        if result.duration:\n            line += f\" ({result.duration:.2f}s)\"\n        if result.error:\n            line += f\" - Error: {result.error}\"\n\n        lines.append(line)\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.StepResult","title":"<code>StepResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from a workflow step execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class StepResult(BaseModel):\n    \"\"\"Result from a workflow step execution.\"\"\"\n\n    name: str\n    status: StepStatus\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    duration: Optional[float] = None\n</code></pre>"},{"location":"reference/agents/__init__/#agenticraft.agents.StepStatus","title":"<code>StepStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a workflow step.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class StepStatus(str, Enum):\n    \"\"\"Status of a workflow step.\"\"\"\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    SKIPPED = \"skipped\"\n</code></pre>"},{"location":"reference/agents/reasoning/","title":"Reasoning","text":""},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning","title":"<code>reasoning</code>","text":"<p>ReasoningAgent implementation for AgentiCraft.</p> <p>The ReasoningAgent provides transparent reasoning capabilities, exposing its thought process step-by-step. This is ideal for educational purposes, debugging, and building trust through transparency.</p>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent","title":"<code>ReasoningAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent that exposes its reasoning process transparently.</p> <pre><code>ReasoningAgent extends the base Agent class to provide detailed\nvisibility into the reasoning process. It uses Chain of Thought\nby default and formats responses to include step-by-step thinking.\n\nExample:\n    Basic usage::\n\n        agent = ReasoningAgent(\n            name=\"Tutor\",\n            instructions=\"You are a helpful tutor who explains step-by-step.\"\n        )\n\n        response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n        print(\"Answer:\", response.content)\n        print(\"\n</code></pre> <p>Reasoning Process:\")             print(response.reasoning)</p> <pre><code>        # Access detailed reasoning\n        for step in response.reasoning_steps:\n            print(f\"{step.number}. {step.description}\")\n            if step.conclusion:\n                print(f\"   Conclusion: {step.conclusion}\")\n</code></pre> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningAgent(Agent):\n    \"\"\"An agent that exposes its reasoning process transparently.\n\n    ReasoningAgent extends the base Agent class to provide detailed\n    visibility into the reasoning process. It uses Chain of Thought\n    by default and formats responses to include step-by-step thinking.\n\n    Example:\n        Basic usage::\n\n            agent = ReasoningAgent(\n                name=\"Tutor\",\n                instructions=\"You are a helpful tutor who explains step-by-step.\"\n            )\n\n            response = await agent.think_and_act(\"How do I solve 2x + 5 = 13?\")\n\n            print(\"Answer:\", response.content)\n            print(\"\\nReasoning Process:\")\n            print(response.reasoning)\n\n            # Access detailed reasoning\n            for step in response.reasoning_steps:\n                print(f\"{step.number}. {step.description}\")\n                if step.conclusion:\n                    print(f\"   Conclusion: {step.conclusion}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"ReasoningAgent\",\n        instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n        **kwargs\n    ):\n        \"\"\"Initialize ReasoningAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions (augmented with reasoning prompt)\n            **kwargs: Additional configuration passed to base Agent\n        \"\"\"\n        # Augment instructions to encourage step-by-step reasoning\n        reasoning_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n            \"For each step:\\n\"\n            \"1. State what you're doing\\n\"\n            \"2. Explain why\\n\"\n            \"3. Show any calculations or logic\\n\"\n            \"4. State your conclusion for that step\\n\\n\"\n            \"Format your response with clear sections:\\n\"\n            \"- REASONING: Your step-by-step thought process\\n\"\n            \"- ANSWER: Your final answer\\n\"\n        )\n\n        # Use Chain of Thought reasoning by default\n        if 'reasoning_pattern' not in kwargs:\n            kwargs['reasoning_pattern'] = ChainOfThought()\n\n        super().__init__(\n            name=name,\n            instructions=reasoning_instructions,\n            **kwargs\n        )\n\n        self.reasoning_history: List[ReasoningTrace] = []\n\n    async def think_and_act(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        expose_thinking: bool = True,\n        **kwargs\n    ) -&gt; 'ReasoningResponse':\n        \"\"\"Think through a problem step-by-step and act on it.\n\n        Args:\n            prompt: The problem or question to solve\n            context: Optional context\n            expose_thinking: Whether to expose internal reasoning\n            **kwargs: Additional arguments passed to LLM\n\n        Returns:\n            ReasoningResponse with detailed reasoning information\n        \"\"\"\n        # Start reasoning trace\n        trace = self._reasoning.start_trace(prompt)\n\n        # Add thinking step\n        trace.add_step(\"thinking\", {\n            \"approach\": \"step_by_step\",\n            \"expose_thinking\": expose_thinking\n        })\n\n        # If expose_thinking, add a special prompt\n        thinking_prompt = prompt\n        if expose_thinking:\n            thinking_prompt = (\n                f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n                f\"{prompt}\\n\\n\"\n                f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n            )\n\n        # Run the agent with thinking prompt\n        response = await self.arun(thinking_prompt, context, **kwargs)\n\n        # Parse the response to extract reasoning steps\n        reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n        # Store reasoning trace\n        self.reasoning_history.append(trace)\n\n        # Create enhanced response\n        return ReasoningResponse(\n            content=response.content,\n            reasoning=response.reasoning,\n            reasoning_steps=reasoning_steps,\n            reasoning_trace=trace,\n            tool_calls=response.tool_calls,\n            metadata=response.metadata,\n            agent_id=response.agent_id\n        )\n\n    def _parse_reasoning_steps(\n        self, \n        content: str, \n        trace: ReasoningTrace\n    ) -&gt; List['ReasoningStepDetail']:\n        \"\"\"Parse reasoning steps from the response content.\n\n        Args:\n            content: The response content\n            trace: The reasoning trace\n\n        Returns:\n            List of detailed reasoning steps\n        \"\"\"\n        steps = []\n\n        # Try to extract structured reasoning\n        lines = content.split('\\n')\n        current_step = None\n        step_number = 0\n        in_reasoning_section = False\n\n        for line in lines:\n            line = line.strip()\n\n            # Check for reasoning section\n            if line.upper().startswith('REASONING:'):\n                in_reasoning_section = True\n                continue\n            elif line.upper().startswith('ANSWER:'):\n                in_reasoning_section = False\n                continue\n\n            if in_reasoning_section and line:\n                # Look for numbered steps\n                if (line[0].isdigit() and '.' in line) or line.startswith('Step'):\n                    if current_step:\n                        steps.append(current_step)\n\n                    step_number += 1\n                    # Extract step description\n                    desc_start = line.find('.') + 1 if '.' in line else line.find(':') + 1\n                    description = line[desc_start:].strip()\n\n                    current_step = ReasoningStepDetail(\n                        number=step_number,\n                        description=description,\n                        details=[],\n                        conclusion=None\n                    )\n                elif current_step and line.startswith(('-', '\u2022', '*')):\n                    # Add as detail to current step\n                    current_step.details.append(line[1:].strip())\n                elif current_step and ('therefore' in line.lower() or \n                                     'conclusion:' in line.lower() or\n                                     'so,' in line.lower()):\n                    # This is a conclusion\n                    current_step.conclusion = line\n\n        # Add the last step\n        if current_step:\n            steps.append(current_step)\n\n        # If no structured steps found, create from trace\n        if not steps and trace.steps:\n            for i, trace_step in enumerate(trace.steps):\n                if trace_step.step_type not in ['analyzing_prompt', 'breakdown']:\n                    steps.append(ReasoningStepDetail(\n                        number=i + 1,\n                        description=trace_step.description,\n                        details=[f\"{k}: {v}\" for k, v in trace_step.data.items()],\n                        conclusion=None\n                    ))\n\n        return steps\n\n    async def analyze(\n        self,\n        prompt: str,\n        perspectives: List[str] = None,\n        **kwargs\n    ) -&gt; 'AnalysisResponse':\n        \"\"\"Analyze a topic from multiple perspectives.\n\n        Args:\n            prompt: The topic or question to analyze\n            perspectives: List of perspectives to consider\n            **kwargs: Additional arguments\n\n        Returns:\n            AnalysisResponse with multi-perspective analysis\n        \"\"\"\n        if perspectives is None:\n            perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n        # Build analysis prompt\n        analysis_prompt = (\n            f\"Please analyze the following from multiple perspectives:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Consider these perspectives:\\n\"\n        )\n        for perspective in perspectives:\n            analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n        analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n        # Get analysis\n        response = await self.think_and_act(analysis_prompt, **kwargs)\n\n        # Parse perspectives from response\n        perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n        return AnalysisResponse(\n            content=response.content,\n            perspectives=perspective_analyses,\n            reasoning_steps=response.reasoning_steps,\n            synthesis=self._synthesize_perspectives(perspective_analyses),\n            metadata=response.metadata\n        )\n\n    def _parse_perspectives(\n        self, \n        content: str, \n        perspectives: List[str]\n    ) -&gt; Dict[str, str]:\n        \"\"\"Parse perspective analyses from content.\"\"\"\n        analyses = {}\n        lines = content.split('\\n')\n        current_perspective = None\n        current_content = []\n\n        for line in lines:\n            # Check if this line starts a new perspective\n            for perspective in perspectives:\n                if perspective.lower() in line.lower() and 'perspective' in line.lower():\n                    if current_perspective:\n                        analyses[current_perspective] = '\\n'.join(current_content).strip()\n                    current_perspective = perspective\n                    current_content = []\n                    break\n            else:\n                if current_perspective:\n                    current_content.append(line)\n\n        # Add the last perspective\n        if current_perspective:\n            analyses[current_perspective] = '\\n'.join(current_content).strip()\n\n        return analyses\n\n    def _synthesize_perspectives(self, perspectives: Dict[str, str]) -&gt; str:\n        \"\"\"Create a synthesis of multiple perspectives.\"\"\"\n        if not perspectives:\n            return \"No perspectives to synthesize.\"\n\n        synthesis = \"Synthesis: Considering all perspectives, \"\n\n        # Simple synthesis based on perspective count\n        if len(perspectives) &gt; 1:\n            synthesis += \"this topic reveals multiple important dimensions. \"\n            synthesis += f\"The {', '.join(perspectives.keys())} perspectives \"\n            synthesis += \"each contribute valuable insights that should be balanced.\"\n        else:\n            key = list(perspectives.keys())[0]\n            synthesis += f\"the {key} perspective provides the primary framework for understanding.\"\n\n        return synthesis\n\n    def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n        \"\"\"Get recent reasoning history.\n\n        Args:\n            limit: Maximum number of traces to return\n\n        Returns:\n            List of recent reasoning traces\n        \"\"\"\n        return self.reasoning_history[-limit:]\n\n    def explain_last_response(self) -&gt; str:\n        \"\"\"Explain the reasoning behind the last response.\"\"\"\n        if not self.reasoning_history:\n            return \"No reasoning history available.\"\n\n        last_trace = self.reasoning_history[-1]\n        return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent.__init__","title":"<code>__init__(name='ReasoningAgent', instructions='You are a helpful assistant that explains your reasoning step-by-step.', **kwargs)</code>","text":"<p>Initialize ReasoningAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'ReasoningAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions (augmented with reasoning prompt)</p> <code>'You are a helpful assistant that explains your reasoning step-by-step.'</code> <code>**kwargs</code> <p>Additional configuration passed to base Agent</p> <code>{}</code> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"ReasoningAgent\",\n    instructions: str = \"You are a helpful assistant that explains your reasoning step-by-step.\",\n    **kwargs\n):\n    \"\"\"Initialize ReasoningAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions (augmented with reasoning prompt)\n        **kwargs: Additional configuration passed to base Agent\n    \"\"\"\n    # Augment instructions to encourage step-by-step reasoning\n    reasoning_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"IMPORTANT: Always explain your reasoning process step-by-step. \"\n        \"For each step:\\n\"\n        \"1. State what you're doing\\n\"\n        \"2. Explain why\\n\"\n        \"3. Show any calculations or logic\\n\"\n        \"4. State your conclusion for that step\\n\\n\"\n        \"Format your response with clear sections:\\n\"\n        \"- REASONING: Your step-by-step thought process\\n\"\n        \"- ANSWER: Your final answer\\n\"\n    )\n\n    # Use Chain of Thought reasoning by default\n    if 'reasoning_pattern' not in kwargs:\n        kwargs['reasoning_pattern'] = ChainOfThought()\n\n    super().__init__(\n        name=name,\n        instructions=reasoning_instructions,\n        **kwargs\n    )\n\n    self.reasoning_history: List[ReasoningTrace] = []\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent.think_and_act","title":"<code>think_and_act(prompt, context=None, expose_thinking=True, **kwargs)</code>  <code>async</code>","text":"<p>Think through a problem step-by-step and act on it.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The problem or question to solve</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context</p> <code>None</code> <code>expose_thinking</code> <code>bool</code> <p>Whether to expose internal reasoning</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>ReasoningResponse</code> <p>ReasoningResponse with detailed reasoning information</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def think_and_act(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    expose_thinking: bool = True,\n    **kwargs\n) -&gt; 'ReasoningResponse':\n    \"\"\"Think through a problem step-by-step and act on it.\n\n    Args:\n        prompt: The problem or question to solve\n        context: Optional context\n        expose_thinking: Whether to expose internal reasoning\n        **kwargs: Additional arguments passed to LLM\n\n    Returns:\n        ReasoningResponse with detailed reasoning information\n    \"\"\"\n    # Start reasoning trace\n    trace = self._reasoning.start_trace(prompt)\n\n    # Add thinking step\n    trace.add_step(\"thinking\", {\n        \"approach\": \"step_by_step\",\n        \"expose_thinking\": expose_thinking\n    })\n\n    # If expose_thinking, add a special prompt\n    thinking_prompt = prompt\n    if expose_thinking:\n        thinking_prompt = (\n            f\"Please think through this step-by-step, showing all your reasoning:\\n\\n\"\n            f\"{prompt}\\n\\n\"\n            f\"Remember to clearly separate your REASONING from your final ANSWER.\"\n        )\n\n    # Run the agent with thinking prompt\n    response = await self.arun(thinking_prompt, context, **kwargs)\n\n    # Parse the response to extract reasoning steps\n    reasoning_steps = self._parse_reasoning_steps(response.content, trace)\n\n    # Store reasoning trace\n    self.reasoning_history.append(trace)\n\n    # Create enhanced response\n    return ReasoningResponse(\n        content=response.content,\n        reasoning=response.reasoning,\n        reasoning_steps=reasoning_steps,\n        reasoning_trace=trace,\n        tool_calls=response.tool_calls,\n        metadata=response.metadata,\n        agent_id=response.agent_id\n    )\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent.analyze","title":"<code>analyze(prompt, perspectives=None, **kwargs)</code>  <code>async</code>","text":"<p>Analyze a topic from multiple perspectives.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The topic or question to analyze</p> required <code>perspectives</code> <code>List[str]</code> <p>List of perspectives to consider</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnalysisResponse</code> <p>AnalysisResponse with multi-perspective analysis</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>async def analyze(\n    self,\n    prompt: str,\n    perspectives: List[str] = None,\n    **kwargs\n) -&gt; 'AnalysisResponse':\n    \"\"\"Analyze a topic from multiple perspectives.\n\n    Args:\n        prompt: The topic or question to analyze\n        perspectives: List of perspectives to consider\n        **kwargs: Additional arguments\n\n    Returns:\n        AnalysisResponse with multi-perspective analysis\n    \"\"\"\n    if perspectives is None:\n        perspectives = [\"practical\", \"theoretical\", \"ethical\", \"economic\"]\n\n    # Build analysis prompt\n    analysis_prompt = (\n        f\"Please analyze the following from multiple perspectives:\\n\\n\"\n        f\"{prompt}\\n\\n\"\n        f\"Consider these perspectives:\\n\"\n    )\n    for perspective in perspectives:\n        analysis_prompt += f\"- {perspective.capitalize()} perspective\\n\"\n\n    analysis_prompt += \"\\nProvide a thorough analysis for each perspective.\"\n\n    # Get analysis\n    response = await self.think_and_act(analysis_prompt, **kwargs)\n\n    # Parse perspectives from response\n    perspective_analyses = self._parse_perspectives(response.content, perspectives)\n\n    return AnalysisResponse(\n        content=response.content,\n        perspectives=perspective_analyses,\n        reasoning_steps=response.reasoning_steps,\n        synthesis=self._synthesize_perspectives(perspective_analyses),\n        metadata=response.metadata\n    )\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent.get_reasoning_history","title":"<code>get_reasoning_history(limit=10)</code>","text":"<p>Get recent reasoning history.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of traces to return</p> <code>10</code> <p>Returns:</p> Type Description <code>List[ReasoningTrace]</code> <p>List of recent reasoning traces</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_reasoning_history(self, limit: int = 10) -&gt; List[ReasoningTrace]:\n    \"\"\"Get recent reasoning history.\n\n    Args:\n        limit: Maximum number of traces to return\n\n    Returns:\n        List of recent reasoning traces\n    \"\"\"\n    return self.reasoning_history[-limit:]\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningAgent.explain_last_response","title":"<code>explain_last_response()</code>","text":"<p>Explain the reasoning behind the last response.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def explain_last_response(self) -&gt; str:\n    \"\"\"Explain the reasoning behind the last response.\"\"\"\n    if not self.reasoning_history:\n        return \"No reasoning history available.\"\n\n    last_trace = self.reasoning_history[-1]\n    return self._reasoning.format_trace(last_trace)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningStepDetail","title":"<code>ReasoningStepDetail</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Detailed information about a reasoning step.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningStepDetail(BaseModel):\n    \"\"\"Detailed information about a reasoning step.\"\"\"\n\n    number: int\n    description: str\n    details: List[str] = Field(default_factory=list)\n    conclusion: Optional[str] = None\n    confidence: float = Field(default=1.0, ge=0.0, le=1.0)\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the step.\"\"\"\n        s = f\"Step {self.number}: {self.description}\"\n        if self.details:\n            s += f\" (Details: {len(self.details)})\"\n        if self.conclusion:\n            s += f\" \u2192 {self.conclusion}\"\n        return s\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningStepDetail.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the step.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the step.\"\"\"\n    s = f\"Step {self.number}: {self.description}\"\n    if self.details:\n        s += f\" (Details: {len(self.details)})\"\n    if self.conclusion:\n        s += f\" \u2192 {self.conclusion}\"\n    return s\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningResponse","title":"<code>ReasoningResponse</code>","text":"<p>               Bases: <code>AgentResponse</code></p> <p>Enhanced response with detailed reasoning information.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class ReasoningResponse(AgentResponse):\n    \"\"\"Enhanced response with detailed reasoning information.\"\"\"\n\n    reasoning_steps: List[ReasoningStepDetail] = Field(default_factory=list)\n    reasoning_trace: Optional[ReasoningTrace] = None\n\n    @property\n    def step_count(self) -&gt; int:\n        \"\"\"Get the number of reasoning steps.\"\"\"\n        return len(self.reasoning_steps)\n\n    def get_step(self, number: int) -&gt; Optional[ReasoningStepDetail]:\n        \"\"\"Get a specific reasoning step by number.\"\"\"\n        for step in self.reasoning_steps:\n            if step.number == number:\n                return step\n        return None\n\n    def format_reasoning(self) -&gt; str:\n        \"\"\"Format reasoning steps as readable text.\"\"\"\n        if not self.reasoning_steps:\n            return \"No detailed reasoning steps available.\"\n\n        lines = [\"Reasoning Process:\"]\n        for step in self.reasoning_steps:\n            lines.append(f\"\\n{step.number}. {step.description}\")\n            for detail in step.details:\n                lines.append(f\"   - {detail}\")\n            if step.conclusion:\n                lines.append(f\"   \u2192 {step.conclusion}\")\n\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningResponse.step_count","title":"<code>step_count</code>  <code>property</code>","text":"<p>Get the number of reasoning steps.</p>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningResponse.get_step","title":"<code>get_step(number)</code>","text":"<p>Get a specific reasoning step by number.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_step(self, number: int) -&gt; Optional[ReasoningStepDetail]:\n    \"\"\"Get a specific reasoning step by number.\"\"\"\n    for step in self.reasoning_steps:\n        if step.number == number:\n            return step\n    return None\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.ReasoningResponse.format_reasoning","title":"<code>format_reasoning()</code>","text":"<p>Format reasoning steps as readable text.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def format_reasoning(self) -&gt; str:\n    \"\"\"Format reasoning steps as readable text.\"\"\"\n    if not self.reasoning_steps:\n        return \"No detailed reasoning steps available.\"\n\n    lines = [\"Reasoning Process:\"]\n    for step in self.reasoning_steps:\n        lines.append(f\"\\n{step.number}. {step.description}\")\n        for detail in step.details:\n            lines.append(f\"   - {detail}\")\n        if step.conclusion:\n            lines.append(f\"   \u2192 {step.conclusion}\")\n\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.AnalysisResponse","title":"<code>AnalysisResponse</code>","text":"<p>               Bases: <code>ReasoningResponse</code></p> <p>Response from multi-perspective analysis.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>class AnalysisResponse(ReasoningResponse):\n    \"\"\"Response from multi-perspective analysis.\"\"\"\n\n    perspectives: Dict[str, str] = Field(default_factory=dict)\n    synthesis: str = \"\"\n\n    def get_perspective(self, name: str) -&gt; Optional[str]:\n        \"\"\"Get analysis for a specific perspective.\"\"\"\n        return self.perspectives.get(name)\n\n    def format_analysis(self) -&gt; str:\n        \"\"\"Format the complete analysis.\"\"\"\n        lines = [\"Multi-Perspective Analysis:\"]\n\n        for perspective, analysis in self.perspectives.items():\n            lines.append(f\"\\n{perspective.upper()} PERSPECTIVE:\")\n            lines.append(analysis)\n\n        if self.synthesis:\n            lines.append(f\"\\n{self.synthesis}\")\n\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.AnalysisResponse.get_perspective","title":"<code>get_perspective(name)</code>","text":"<p>Get analysis for a specific perspective.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def get_perspective(self, name: str) -&gt; Optional[str]:\n    \"\"\"Get analysis for a specific perspective.\"\"\"\n    return self.perspectives.get(name)\n</code></pre>"},{"location":"reference/agents/reasoning/#agenticraft.agents.reasoning.AnalysisResponse.format_analysis","title":"<code>format_analysis()</code>","text":"<p>Format the complete analysis.</p> Source code in <code>agenticraft/agents/reasoning.py</code> <pre><code>def format_analysis(self) -&gt; str:\n    \"\"\"Format the complete analysis.\"\"\"\n    lines = [\"Multi-Perspective Analysis:\"]\n\n    for perspective, analysis in self.perspectives.items():\n        lines.append(f\"\\n{perspective.upper()} PERSPECTIVE:\")\n        lines.append(analysis)\n\n    if self.synthesis:\n        lines.append(f\"\\n{self.synthesis}\")\n\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"reference/agents/workflow/","title":"Workflow","text":""},{"location":"reference/agents/workflow/#agenticraft.agents.workflow","title":"<code>workflow</code>","text":"<p>WorkflowAgent implementation for AgentiCraft.</p> <p>The WorkflowAgent provides capabilities for executing multi-step workflows, with support for sequential execution, conditional logic, parallel tasks, and error handling.</p>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.StepStatus","title":"<code>StepStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of a workflow step.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class StepStatus(str, Enum):\n    \"\"\"Status of a workflow step.\"\"\"\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    SKIPPED = \"skipped\"\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowStep","title":"<code>WorkflowStep</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single step in a workflow.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowStep(BaseModel):\n    \"\"\"A single step in a workflow.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    name: str\n    description: str = \"\"\n    action: Optional[str] = None  # Prompt or action to execute\n    handler: Optional[str] = None  # Name of custom handler function\n    depends_on: List[str] = Field(default_factory=list)\n    condition: Optional[str] = None  # Condition to evaluate\n    parallel: bool = False\n    retry_count: int = 0\n    max_retries: int = 3\n    timeout: Optional[float] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # Runtime state\n    status: StepStatus = StepStatus.PENDING\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n\n    @property\n    def duration(self) -&gt; Optional[float]:\n        \"\"\"Get step duration in seconds.\"\"\"\n        if not self.started_at or not self.completed_at:\n            return None\n        return (self.completed_at - self.started_at).total_seconds()\n\n    def can_run(self, completed_steps: List[str]) -&gt; bool:\n        \"\"\"Check if this step can run based on dependencies.\"\"\"\n        return all(dep in completed_steps for dep in self.depends_on)\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowStep.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Get step duration in seconds.</p>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowStep.can_run","title":"<code>can_run(completed_steps)</code>","text":"<p>Check if this step can run based on dependencies.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def can_run(self, completed_steps: List[str]) -&gt; bool:\n    \"\"\"Check if this step can run based on dependencies.\"\"\"\n    return all(dep in completed_steps for dep in self.depends_on)\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.Workflow","title":"<code>Workflow</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A workflow definition.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class Workflow(BaseModel):\n    \"\"\"A workflow definition.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    name: str\n    description: str = \"\"\n    steps: List[WorkflowStep] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # Runtime state\n    status: StepStatus = StepStatus.PENDING\n    started_at: Optional[datetime] = None\n    completed_at: Optional[datetime] = None\n    context: Dict[str, Any] = Field(default_factory=dict)\n\n    def add_step(\n        self,\n        name: str,\n        action: Optional[str] = None,\n        handler: Optional[str] = None,\n        depends_on: Optional[List[str]] = None,\n        **kwargs\n    ) -&gt; WorkflowStep:\n        \"\"\"Add a step to the workflow.\n\n        Args:\n            name: Step name\n            action: Prompt or action to execute\n            handler: Custom handler function name\n            depends_on: List of step names this depends on\n            **kwargs: Additional step configuration\n\n        Returns:\n            The created WorkflowStep\n        \"\"\"\n        step = WorkflowStep(\n            name=name,\n            action=action,\n            handler=handler,\n            depends_on=depends_on or [],\n            **kwargs\n        )\n        self.steps.append(step)\n        return step\n\n    def get_step(self, name: str) -&gt; Optional[WorkflowStep]:\n        \"\"\"Get a step by name.\"\"\"\n        for step in self.steps:\n            if step.name == name:\n                return step\n        return None\n\n    def get_ready_steps(self) -&gt; List[WorkflowStep]:\n        \"\"\"Get all steps that are ready to run.\"\"\"\n        completed = [s.name for s in self.steps if s.status == StepStatus.COMPLETED]\n        ready = []\n\n        for step in self.steps:\n            if step.status == StepStatus.PENDING and step.can_run(completed):\n                ready.append(step)\n\n        return ready\n\n    def validate(self) -&gt; List[str]:\n        \"\"\"Validate the workflow configuration.\n\n        Returns:\n            List of validation errors (empty if valid)\n        \"\"\"\n        errors = []\n        step_names = {step.name for step in self.steps}\n\n        # Check for duplicate names\n        if len(step_names) != len(self.steps):\n            errors.append(\"Duplicate step names found\")\n\n        # Check dependencies\n        for step in self.steps:\n            for dep in step.depends_on:\n                if dep not in step_names:\n                    errors.append(f\"Step '{step.name}' depends on unknown step '{dep}'\")\n\n        # Check for circular dependencies\n        for step in self.steps:\n            if self._has_circular_dependency(step, step_names):\n                errors.append(f\"Circular dependency detected for step '{step.name}'\")\n\n        return errors\n\n    def _has_circular_dependency(\n        self, \n        step: WorkflowStep, \n        all_steps: set,\n        visited: Optional[set] = None\n    ) -&gt; bool:\n        \"\"\"Check if a step has circular dependencies.\"\"\"\n        if visited is None:\n            visited = set()\n\n        if step.name in visited:\n            return True\n\n        visited.add(step.name)\n\n        for dep_name in step.depends_on:\n            dep_step = self.get_step(dep_name)\n            if dep_step and self._has_circular_dependency(dep_step, all_steps, visited.copy()):\n                return True\n\n        return False\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.Workflow.add_step","title":"<code>add_step(name, action=None, handler=None, depends_on=None, **kwargs)</code>","text":"<p>Add a step to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Step name</p> required <code>action</code> <code>Optional[str]</code> <p>Prompt or action to execute</p> <code>None</code> <code>handler</code> <code>Optional[str]</code> <p>Custom handler function name</p> <code>None</code> <code>depends_on</code> <code>Optional[List[str]]</code> <p>List of step names this depends on</p> <code>None</code> <code>**kwargs</code> <p>Additional step configuration</p> <code>{}</code> <p>Returns:</p> Type Description <code>WorkflowStep</code> <p>The created WorkflowStep</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def add_step(\n    self,\n    name: str,\n    action: Optional[str] = None,\n    handler: Optional[str] = None,\n    depends_on: Optional[List[str]] = None,\n    **kwargs\n) -&gt; WorkflowStep:\n    \"\"\"Add a step to the workflow.\n\n    Args:\n        name: Step name\n        action: Prompt or action to execute\n        handler: Custom handler function name\n        depends_on: List of step names this depends on\n        **kwargs: Additional step configuration\n\n    Returns:\n        The created WorkflowStep\n    \"\"\"\n    step = WorkflowStep(\n        name=name,\n        action=action,\n        handler=handler,\n        depends_on=depends_on or [],\n        **kwargs\n    )\n    self.steps.append(step)\n    return step\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.Workflow.get_step","title":"<code>get_step(name)</code>","text":"<p>Get a step by name.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_step(self, name: str) -&gt; Optional[WorkflowStep]:\n    \"\"\"Get a step by name.\"\"\"\n    for step in self.steps:\n        if step.name == name:\n            return step\n    return None\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.Workflow.get_ready_steps","title":"<code>get_ready_steps()</code>","text":"<p>Get all steps that are ready to run.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_ready_steps(self) -&gt; List[WorkflowStep]:\n    \"\"\"Get all steps that are ready to run.\"\"\"\n    completed = [s.name for s in self.steps if s.status == StepStatus.COMPLETED]\n    ready = []\n\n    for step in self.steps:\n        if step.status == StepStatus.PENDING and step.can_run(completed):\n            ready.append(step)\n\n    return ready\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.Workflow.validate","title":"<code>validate()</code>","text":"<p>Validate the workflow configuration.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of validation errors (empty if valid)</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def validate(self) -&gt; List[str]:\n    \"\"\"Validate the workflow configuration.\n\n    Returns:\n        List of validation errors (empty if valid)\n    \"\"\"\n    errors = []\n    step_names = {step.name for step in self.steps}\n\n    # Check for duplicate names\n    if len(step_names) != len(self.steps):\n        errors.append(\"Duplicate step names found\")\n\n    # Check dependencies\n    for step in self.steps:\n        for dep in step.depends_on:\n            if dep not in step_names:\n                errors.append(f\"Step '{step.name}' depends on unknown step '{dep}'\")\n\n    # Check for circular dependencies\n    for step in self.steps:\n        if self._has_circular_dependency(step, step_names):\n            errors.append(f\"Circular dependency detected for step '{step.name}'\")\n\n    return errors\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent","title":"<code>WorkflowAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>An agent optimized for executing multi-step workflows.</p> <p>WorkflowAgent extends the base Agent to provide workflow execution capabilities including step dependencies, parallel execution, conditional logic, and error handling.</p> Example <p>Basic workflow::</p> <pre><code>agent = WorkflowAgent(name=\"DataProcessor\")\n\n# Define workflow\nworkflow = agent.create_workflow(\"data_pipeline\")\nworkflow.add_step(\"fetch\", \"Fetch data from the API\")\nworkflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\nworkflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\nworkflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n# Execute workflow\nresult = await agent.execute_workflow(workflow)\n\n# Check results\nfor step_name, step_result in result.step_results.items():\n    print(f\"{step_name}: {step_result.status}\")\n</code></pre> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowAgent(Agent):\n    \"\"\"An agent optimized for executing multi-step workflows.\n\n    WorkflowAgent extends the base Agent to provide workflow execution\n    capabilities including step dependencies, parallel execution,\n    conditional logic, and error handling.\n\n    Example:\n        Basic workflow::\n\n            agent = WorkflowAgent(name=\"DataProcessor\")\n\n            # Define workflow\n            workflow = agent.create_workflow(\"data_pipeline\")\n            workflow.add_step(\"fetch\", \"Fetch data from the API\")\n            workflow.add_step(\"validate\", \"Validate the data format\", depends_on=[\"fetch\"])\n            workflow.add_step(\"transform\", \"Transform data to new format\", depends_on=[\"validate\"])\n            workflow.add_step(\"save\", \"Save to database\", depends_on=[\"transform\"])\n\n            # Execute workflow\n            result = await agent.execute_workflow(workflow)\n\n            # Check results\n            for step_name, step_result in result.step_results.items():\n                print(f\"{step_name}: {step_result.status}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"WorkflowAgent\",\n        instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n        **kwargs\n    ):\n        \"\"\"Initialize WorkflowAgent.\n\n        Args:\n            name: Agent name\n            instructions: System instructions\n            **kwargs: Additional configuration\n        \"\"\"\n        # Augment instructions for workflow execution\n        workflow_instructions = (\n            f\"{instructions}\\n\\n\"\n            \"When executing workflow steps:\\n\"\n            \"1. Follow the exact instructions for each step\\n\"\n            \"2. Use the context from previous steps when needed\\n\"\n            \"3. Provide clear, actionable output\\n\"\n            \"4. Report any issues or blockers immediately\"\n        )\n\n        super().__init__(\n            name=name,\n            instructions=workflow_instructions,\n            **kwargs\n        )\n\n        self.workflows: Dict[str, Workflow] = {}\n        self.handlers: Dict[str, Callable] = {}\n        self.running_workflows: Dict[str, Workflow] = {}\n\n    def create_workflow(\n        self,\n        name: str,\n        description: str = \"\"\n    ) -&gt; Workflow:\n        \"\"\"Create a new workflow.\n\n        Args:\n            name: Workflow name\n            description: Workflow description\n\n        Returns:\n            The created Workflow\n        \"\"\"\n        workflow = Workflow(name=name, description=description)\n        self.workflows[workflow.id] = workflow\n        return workflow\n\n    def register_handler(\n        self,\n        name: str,\n        handler: Callable\n    ) -&gt; None:\n        \"\"\"Register a custom step handler.\n\n        Args:\n            name: Handler name\n            handler: Callable that takes (agent, step, context) and returns result\n        \"\"\"\n        self.handlers[name] = handler\n\n    async def execute_workflow(\n        self,\n        workflow: Union[Workflow, str],\n        context: Optional[Dict[str, Any]] = None,\n        parallel: bool = True\n    ) -&gt; 'WorkflowResult':\n        \"\"\"Execute a workflow.\n\n        Args:\n            workflow: Workflow instance or ID\n            context: Initial workflow context\n            parallel: Whether to run parallel steps concurrently\n\n        Returns:\n            WorkflowResult with execution details\n        \"\"\"\n        # Get workflow instance\n        if isinstance(workflow, str):\n            workflow = self.workflows.get(workflow)\n            if not workflow:\n                raise AgentError(f\"Workflow '{workflow}' not found\")\n\n        # Validate workflow\n        errors = workflow.validate()\n        if errors:\n            raise AgentError(f\"Workflow validation failed: {errors}\")\n\n        # Initialize execution\n        workflow.status = StepStatus.RUNNING\n        workflow.started_at = datetime.now()\n        workflow.context = context or {}\n        self.running_workflows[workflow.id] = workflow\n\n        try:\n            # Execute workflow\n            if parallel:\n                await self._execute_parallel(workflow)\n            else:\n                await self._execute_sequential(workflow)\n\n            # Mark as completed\n            workflow.status = StepStatus.COMPLETED\n            workflow.completed_at = datetime.now()\n\n        except Exception as e:\n            workflow.status = StepStatus.FAILED\n            workflow.completed_at = datetime.now()\n            raise\n        finally:\n            del self.running_workflows[workflow.id]\n\n        # Build result\n        return WorkflowResult(\n            workflow_id=workflow.id,\n            workflow_name=workflow.name,\n            status=workflow.status,\n            duration=self._calculate_duration(workflow),\n            step_results={\n                step.name: StepResult(\n                    name=step.name,\n                    status=step.status,\n                    result=step.result,\n                    error=step.error,\n                    duration=step.duration\n                )\n                for step in workflow.steps\n            },\n            context=workflow.context\n        )\n\n    async def _execute_sequential(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow steps sequentially.\"\"\"\n        completed_steps = []\n\n        while True:\n            # Get next ready step\n            ready_steps = workflow.get_ready_steps()\n            if not ready_steps:\n                break\n\n            # Execute first ready step\n            step = ready_steps[0]\n            await self._execute_step(step, workflow)\n\n            if step.status == StepStatus.COMPLETED:\n                completed_steps.append(step.name)\n\n    async def _execute_parallel(self, workflow: Workflow) -&gt; None:\n        \"\"\"Execute workflow with parallel step support.\"\"\"\n        completed_steps = set()\n        pending_tasks = {}\n\n        while True:\n            # Get ready steps\n            ready_steps = workflow.get_ready_steps()\n\n            # Start tasks for ready steps\n            for step in ready_steps:\n                if step.name not in pending_tasks:\n                    task = asyncio.create_task(self._execute_step(step, workflow))\n                    pending_tasks[step.name] = (step, task)\n\n            # If no pending tasks, we're done\n            if not pending_tasks:\n                break\n\n            # Wait for any task to complete\n            done, pending = await asyncio.wait(\n                [task for _, task in pending_tasks.values()],\n                return_when=asyncio.FIRST_COMPLETED\n            )\n\n            # Process completed tasks\n            for task in done:\n                # Find which step this task belongs to\n                for step_name, (step, step_task) in list(pending_tasks.items()):\n                    if step_task == task:\n                        del pending_tasks[step_name]\n                        if step.status == StepStatus.COMPLETED:\n                            completed_steps.add(step_name)\n                        break\n\n    async def _execute_step(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; None:\n        \"\"\"Execute a single workflow step.\"\"\"\n        step.status = StepStatus.RUNNING\n        step.started_at = datetime.now()\n\n        try:\n            # Check condition if present\n            if step.condition and not self._evaluate_condition(step.condition, workflow.context):\n                step.status = StepStatus.SKIPPED\n                step.result = \"Skipped due to condition\"\n                return\n\n            # Execute with timeout if specified\n            if step.timeout:\n                result = await asyncio.wait_for(\n                    self._run_step_action(step, workflow),\n                    timeout=step.timeout\n                )\n            else:\n                result = await self._run_step_action(step, workflow)\n\n            # Store result\n            step.result = result\n            step.status = StepStatus.COMPLETED\n\n            # Update workflow context\n            workflow.context[f\"{step.name}_result\"] = result\n\n        except asyncio.TimeoutError:\n            step.error = f\"Step timed out after {step.timeout} seconds\"\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        except Exception as e:\n            step.error = str(e)\n            step.status = StepStatus.FAILED\n\n            # Retry if allowed\n            if step.retry_count &lt; step.max_retries:\n                step.retry_count += 1\n                step.status = StepStatus.PENDING\n\n        finally:\n            if step.status in [StepStatus.COMPLETED, StepStatus.FAILED, StepStatus.SKIPPED]:\n                step.completed_at = datetime.now()\n\n    async def _run_step_action(\n        self,\n        step: WorkflowStep,\n        workflow: Workflow\n    ) -&gt; Any:\n        \"\"\"Run the action for a step.\"\"\"\n        # Use custom handler if specified\n        if step.handler and step.handler in self.handlers:\n            handler = self.handlers[step.handler]\n            if asyncio.iscoroutinefunction(handler):\n                return await handler(self, step, workflow.context)\n            else:\n                return handler(self, step, workflow.context)\n\n        # Use action prompt\n        if step.action:\n            # Build prompt with context\n            prompt = f\"Execute the following step: {step.action}\"\n\n            # Add relevant context\n            if workflow.context:\n                relevant_context = {\n                    k: v for k, v in workflow.context.items()\n                    if any(dep in k for dep in step.depends_on) or k in ['initial_input', 'user_request']\n                }\n                if relevant_context:\n                    prompt += f\"\\n\\nContext from previous steps:\\n{relevant_context}\"\n\n            # Execute with agent\n            response = await self.arun(prompt)\n            return response.content\n\n        # No action defined\n        return f\"Step '{step.name}' completed\"\n\n    def _evaluate_condition(\n        self,\n        condition: str,\n        context: Dict[str, Any]\n    ) -&gt; bool:\n        \"\"\"Evaluate a step condition.\n\n        Simple evaluation - in production, use a safe expression evaluator.\n        \"\"\"\n        try:\n            # Very basic condition evaluation\n            # In production, use a proper expression evaluator\n            if \"==\" in condition:\n                parts = condition.split(\"==\")\n                if len(parts) == 2:\n                    left = parts[0].strip()\n                    right = parts[1].strip().strip(\"'\\\"\")\n                    return str(context.get(left, \"\")) == right\n\n            # Default to True if we can't evaluate\n            return True\n\n        except Exception:\n            return True\n\n    def _calculate_duration(self, workflow: Workflow) -&gt; float:\n        \"\"\"Calculate total workflow duration.\"\"\"\n        if not workflow.started_at or not workflow.completed_at:\n            return 0.0\n        return (workflow.completed_at - workflow.started_at).total_seconds()\n\n    def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get the current status of a running workflow.\"\"\"\n        workflow = self.running_workflows.get(workflow_id)\n        if not workflow:\n            return None\n\n        return {\n            \"id\": workflow.id,\n            \"name\": workflow.name,\n            \"status\": workflow.status,\n            \"steps\": {\n                step.name: {\n                    \"status\": step.status,\n                    \"duration\": step.duration\n                }\n                for step in workflow.steps\n            }\n        }\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent.__init__","title":"<code>__init__(name='WorkflowAgent', instructions='You are a workflow execution agent. Follow the steps precisely.', **kwargs)</code>","text":"<p>Initialize WorkflowAgent.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name</p> <code>'WorkflowAgent'</code> <code>instructions</code> <code>str</code> <p>System instructions</p> <code>'You are a workflow execution agent. Follow the steps precisely.'</code> <code>**kwargs</code> <p>Additional configuration</p> <code>{}</code> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"WorkflowAgent\",\n    instructions: str = \"You are a workflow execution agent. Follow the steps precisely.\",\n    **kwargs\n):\n    \"\"\"Initialize WorkflowAgent.\n\n    Args:\n        name: Agent name\n        instructions: System instructions\n        **kwargs: Additional configuration\n    \"\"\"\n    # Augment instructions for workflow execution\n    workflow_instructions = (\n        f\"{instructions}\\n\\n\"\n        \"When executing workflow steps:\\n\"\n        \"1. Follow the exact instructions for each step\\n\"\n        \"2. Use the context from previous steps when needed\\n\"\n        \"3. Provide clear, actionable output\\n\"\n        \"4. Report any issues or blockers immediately\"\n    )\n\n    super().__init__(\n        name=name,\n        instructions=workflow_instructions,\n        **kwargs\n    )\n\n    self.workflows: Dict[str, Workflow] = {}\n    self.handlers: Dict[str, Callable] = {}\n    self.running_workflows: Dict[str, Workflow] = {}\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent.create_workflow","title":"<code>create_workflow(name, description='')</code>","text":"<p>Create a new workflow.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Workflow name</p> required <code>description</code> <code>str</code> <p>Workflow description</p> <code>''</code> <p>Returns:</p> Type Description <code>Workflow</code> <p>The created Workflow</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def create_workflow(\n    self,\n    name: str,\n    description: str = \"\"\n) -&gt; Workflow:\n    \"\"\"Create a new workflow.\n\n    Args:\n        name: Workflow name\n        description: Workflow description\n\n    Returns:\n        The created Workflow\n    \"\"\"\n    workflow = Workflow(name=name, description=description)\n    self.workflows[workflow.id] = workflow\n    return workflow\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent.register_handler","title":"<code>register_handler(name, handler)</code>","text":"<p>Register a custom step handler.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Handler name</p> required <code>handler</code> <code>Callable</code> <p>Callable that takes (agent, step, context) and returns result</p> required Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def register_handler(\n    self,\n    name: str,\n    handler: Callable\n) -&gt; None:\n    \"\"\"Register a custom step handler.\n\n    Args:\n        name: Handler name\n        handler: Callable that takes (agent, step, context) and returns result\n    \"\"\"\n    self.handlers[name] = handler\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent.execute_workflow","title":"<code>execute_workflow(workflow, context=None, parallel=True)</code>  <code>async</code>","text":"<p>Execute a workflow.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Union[Workflow, str]</code> <p>Workflow instance or ID</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Initial workflow context</p> <code>None</code> <code>parallel</code> <code>bool</code> <p>Whether to run parallel steps concurrently</p> <code>True</code> <p>Returns:</p> Type Description <code>WorkflowResult</code> <p>WorkflowResult with execution details</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>async def execute_workflow(\n    self,\n    workflow: Union[Workflow, str],\n    context: Optional[Dict[str, Any]] = None,\n    parallel: bool = True\n) -&gt; 'WorkflowResult':\n    \"\"\"Execute a workflow.\n\n    Args:\n        workflow: Workflow instance or ID\n        context: Initial workflow context\n        parallel: Whether to run parallel steps concurrently\n\n    Returns:\n        WorkflowResult with execution details\n    \"\"\"\n    # Get workflow instance\n    if isinstance(workflow, str):\n        workflow = self.workflows.get(workflow)\n        if not workflow:\n            raise AgentError(f\"Workflow '{workflow}' not found\")\n\n    # Validate workflow\n    errors = workflow.validate()\n    if errors:\n        raise AgentError(f\"Workflow validation failed: {errors}\")\n\n    # Initialize execution\n    workflow.status = StepStatus.RUNNING\n    workflow.started_at = datetime.now()\n    workflow.context = context or {}\n    self.running_workflows[workflow.id] = workflow\n\n    try:\n        # Execute workflow\n        if parallel:\n            await self._execute_parallel(workflow)\n        else:\n            await self._execute_sequential(workflow)\n\n        # Mark as completed\n        workflow.status = StepStatus.COMPLETED\n        workflow.completed_at = datetime.now()\n\n    except Exception as e:\n        workflow.status = StepStatus.FAILED\n        workflow.completed_at = datetime.now()\n        raise\n    finally:\n        del self.running_workflows[workflow.id]\n\n    # Build result\n    return WorkflowResult(\n        workflow_id=workflow.id,\n        workflow_name=workflow.name,\n        status=workflow.status,\n        duration=self._calculate_duration(workflow),\n        step_results={\n            step.name: StepResult(\n                name=step.name,\n                status=step.status,\n                result=step.result,\n                error=step.error,\n                duration=step.duration\n            )\n            for step in workflow.steps\n        },\n        context=workflow.context\n    )\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowAgent.get_workflow_status","title":"<code>get_workflow_status(workflow_id)</code>","text":"<p>Get the current status of a running workflow.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_workflow_status(self, workflow_id: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get the current status of a running workflow.\"\"\"\n    workflow = self.running_workflows.get(workflow_id)\n    if not workflow:\n        return None\n\n    return {\n        \"id\": workflow.id,\n        \"name\": workflow.name,\n        \"status\": workflow.status,\n        \"steps\": {\n            step.name: {\n                \"status\": step.status,\n                \"duration\": step.duration\n            }\n            for step in workflow.steps\n        }\n    }\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.StepResult","title":"<code>StepResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from a workflow step execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class StepResult(BaseModel):\n    \"\"\"Result from a workflow step execution.\"\"\"\n\n    name: str\n    status: StepStatus\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    duration: Optional[float] = None\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowResult","title":"<code>WorkflowResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from workflow execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>class WorkflowResult(BaseModel):\n    \"\"\"Result from workflow execution.\"\"\"\n\n    workflow_id: str\n    workflow_name: str\n    status: StepStatus\n    duration: float\n    step_results: Dict[str, StepResult]\n    context: Dict[str, Any] = Field(default_factory=dict)\n\n    @property\n    def successful(self) -&gt; bool:\n        \"\"\"Check if workflow completed successfully.\"\"\"\n        return self.status == StepStatus.COMPLETED\n\n    @property\n    def failed_steps(self) -&gt; List[str]:\n        \"\"\"Get list of failed step names.\"\"\"\n        return [\n            name for name, result in self.step_results.items()\n            if result.status == StepStatus.FAILED\n        ]\n\n    def get_step_result(self, step_name: str) -&gt; Optional[Any]:\n        \"\"\"Get the result of a specific step.\"\"\"\n        step = self.step_results.get(step_name)\n        return step.result if step else None\n\n    def format_summary(self) -&gt; str:\n        \"\"\"Format a summary of the workflow execution.\"\"\"\n        lines = [\n            f\"Workflow: {self.workflow_name}\",\n            f\"Status: {self.status}\",\n            f\"Duration: {self.duration:.2f}s\",\n            \"\\nStep Results:\"\n        ]\n\n        for name, result in self.step_results.items():\n            status_emoji = {\n                StepStatus.COMPLETED: \"\u2705\",\n                StepStatus.FAILED: \"\u274c\",\n                StepStatus.SKIPPED: \"\u23ed\ufe0f\",\n                StepStatus.PENDING: \"\u23f8\ufe0f\",\n                StepStatus.RUNNING: \"\ud83d\udd04\"\n            }.get(result.status, \"\u2753\")\n\n            line = f\"  {status_emoji} {name}: {result.status}\"\n            if result.duration:\n                line += f\" ({result.duration:.2f}s)\"\n            if result.error:\n                line += f\" - Error: {result.error}\"\n\n            lines.append(line)\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowResult.successful","title":"<code>successful</code>  <code>property</code>","text":"<p>Check if workflow completed successfully.</p>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowResult.failed_steps","title":"<code>failed_steps</code>  <code>property</code>","text":"<p>Get list of failed step names.</p>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowResult.get_step_result","title":"<code>get_step_result(step_name)</code>","text":"<p>Get the result of a specific step.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def get_step_result(self, step_name: str) -&gt; Optional[Any]:\n    \"\"\"Get the result of a specific step.\"\"\"\n    step = self.step_results.get(step_name)\n    return step.result if step else None\n</code></pre>"},{"location":"reference/agents/workflow/#agenticraft.agents.workflow.WorkflowResult.format_summary","title":"<code>format_summary()</code>","text":"<p>Format a summary of the workflow execution.</p> Source code in <code>agenticraft/agents/workflow.py</code> <pre><code>def format_summary(self) -&gt; str:\n    \"\"\"Format a summary of the workflow execution.\"\"\"\n    lines = [\n        f\"Workflow: {self.workflow_name}\",\n        f\"Status: {self.status}\",\n        f\"Duration: {self.duration:.2f}s\",\n        \"\\nStep Results:\"\n    ]\n\n    for name, result in self.step_results.items():\n        status_emoji = {\n            StepStatus.COMPLETED: \"\u2705\",\n            StepStatus.FAILED: \"\u274c\",\n            StepStatus.SKIPPED: \"\u23ed\ufe0f\",\n            StepStatus.PENDING: \"\u23f8\ufe0f\",\n            StepStatus.RUNNING: \"\ud83d\udd04\"\n        }.get(result.status, \"\u2753\")\n\n        line = f\"  {status_emoji} {name}: {result.status}\"\n        if result.duration:\n            line += f\" ({result.duration:.2f}s)\"\n        if result.error:\n            line += f\" - Error: {result.error}\"\n\n        lines.append(line)\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/cli/main/","title":"Main","text":""},{"location":"reference/cli/main/#agenticraft.cli.main","title":"<code>main</code>","text":"<p>AgentiCraft CLI - Command line interface for AgentiCraft.</p> <p>This module provides the main entry point for the AgentiCraft command-line tool.</p>"},{"location":"reference/cli/main/#agenticraft.cli.main.cli","title":"<code>cli(ctx)</code>","text":"<p>AgentiCraft - The AI Agent Framework.</p> <p>Build production-ready AI agents with ease.</p> Source code in <code>agenticraft/cli/main.py</code> <pre><code>@click.group(invoke_without_command=True)\n@click.version_option(version=__version__, prog_name=\"agenticraft\")\n@click.pass_context\ndef cli(ctx):\n    \"\"\"\n    AgentiCraft - The AI Agent Framework.\n\n    Build production-ready AI agents with ease.\n    \"\"\"\n    # Ensure that ctx.obj exists and is a dict\n    ctx.ensure_object(dict)\n\n    # If no command was provided, show a welcome message\n    if ctx.invoked_subcommand is None:\n        click.echo(\"AgentiCraft - The AI Agent Framework\")\n        click.echo(\"Build production-ready AI agents with ease.\")\n        click.echo(\"\\nUse 'agenticraft --help' for more information.\")\n</code></pre>"},{"location":"reference/cli/main/#agenticraft.cli.main.version","title":"<code>version()</code>","text":"<p>Show the AgentiCraft version.</p> Source code in <code>agenticraft/cli/main.py</code> <pre><code>@cli.command()\ndef version():\n    \"\"\"Show the AgentiCraft version.\"\"\"\n    click.echo(f\"AgentiCraft {__version__}\")\n</code></pre>"},{"location":"reference/cli/main/#agenticraft.cli.main.info","title":"<code>info()</code>","text":"<p>Show information about AgentiCraft installation.</p> Source code in <code>agenticraft/cli/main.py</code> <pre><code>@cli.command()\ndef info():\n    \"\"\"Show information about AgentiCraft installation.\"\"\"\n    import platform\n    import os\n\n    click.echo(f\"AgentiCraft {__version__}\")\n    click.echo(f\"Python {platform.python_version()}\")\n    click.echo(f\"Platform: {platform.platform()}\")\n    click.echo(f\"Installation: {os.path.dirname(os.path.dirname(__file__))}\")\n\n    # Check available providers\n    click.echo(\"\\nAvailable Providers:\")\n    try:\n        from agenticraft.providers import list_providers\n        for provider in list_providers():\n            click.echo(f\"  - {provider}\")\n    except:\n        click.echo(\"  - Unable to load providers\")\n\n    # Check available tools\n    click.echo(\"\\nCore Tools:\")\n    tools = [\"search\", \"calculator\", \"files\", \"http\", \"text\"]\n    for tool in tools:\n        click.echo(f\"  - {tool}\")\n</code></pre>"},{"location":"reference/cli/main/#agenticraft.cli.main.main","title":"<code>main()</code>","text":"<p>Main entry point for the CLI.</p> Source code in <code>agenticraft/cli/main.py</code> <pre><code>def main():\n    \"\"\"Main entry point for the CLI.\"\"\"\n    try:\n        cli()\n    except Exception as e:\n        click.echo(f\"Error: {str(e)}\", err=True)\n        sys.exit(1)\n</code></pre>"},{"location":"reference/cli/commands/new/","title":"New","text":""},{"location":"reference/cli/commands/new/#agenticraft.cli.commands.new","title":"<code>new</code>","text":"<p>New command - Create new AgentiCraft projects from templates.</p>"},{"location":"reference/cli/commands/new/#agenticraft.cli.commands.new.new","title":"<code>new(name, template, directory, no_git)</code>","text":"<p>Create a new AgentiCraft project.</p> Example <p>agenticraft new my-api --template fastapi</p> Source code in <code>agenticraft/cli/commands/new.py</code> <pre><code>@click.command()\n@click.argument(\"name\")\n@click.option(\n    \"--template\",\n    \"-t\",\n    type=click.Choice(list(AVAILABLE_TEMPLATES.keys())),\n    default=\"basic\",\n    help=\"Template to use for the new project\",\n)\n@click.option(\n    \"--directory\",\n    \"-d\",\n    type=click.Path(),\n    help=\"Directory to create the project in (default: current directory)\",\n)\n@click.option(\n    \"--no-git\",\n    is_flag=True,\n    help=\"Don't initialize a git repository\",\n)\ndef new(name: str, template: str, directory: Optional[str], no_git: bool):\n    \"\"\"\n    Create a new AgentiCraft project.\n\n    Example:\n        agenticraft new my-api --template fastapi\n    \"\"\"\n    # Determine project path\n    if directory:\n        project_path = Path(directory) / name\n    else:\n        project_path = Path.cwd() / name\n\n    # Check if directory already exists\n    if project_path.exists():\n        click.echo(f\"Error: Directory '{project_path}' already exists\", err=True)\n        raise click.Abort()\n\n    # Get template path\n    template_path = _get_template_path(template)\n\n    if not template_path.exists():\n        click.echo(f\"Error: Template '{template}' not found\", err=True)\n        click.echo(f\"Available templates: {', '.join(AVAILABLE_TEMPLATES.keys())}\")\n        raise click.Abort()\n\n    # Create project directory\n    click.echo(f\"Creating new {template} project: {name}\")\n    project_path.mkdir(parents=True, exist_ok=True)\n\n    try:\n        # Copy template files\n        _copy_template(template_path, project_path, name)\n\n        # Initialize git repository\n        if not no_git:\n            _init_git(project_path)\n\n        # Update project files with name\n        _update_project_files(project_path, name, template)\n\n        # Success message\n        click.echo(f\"\\n\u2728 Project '{name}' created successfully!\")\n        click.echo(f\"\\nNext steps:\")\n\n        # Try to get relative path, but fall back to absolute if not possible\n        try:\n            display_path = project_path.relative_to(Path.cwd())\n        except ValueError:\n            # Paths are not relative to each other, use absolute path\n            display_path = project_path\n\n        click.echo(f\"  cd {display_path}\")\n\n        if template == \"fastapi\":\n            click.echo(\"  cp .env.example .env\")\n            click.echo(\"  # Edit .env with your API keys\")\n            click.echo(\"  docker-compose up\")\n        elif template == \"cli\":\n            click.echo(\"  python -m venv venv\")\n            click.echo(\"  source venv/bin/activate\")\n            click.echo(\"  pip install -e .\")\n            click.echo(f\"  {name} --help\")\n        else:\n            click.echo(\"  pip install -r requirements.txt\")\n            click.echo(\"  python main.py\")\n\n    except Exception as e:\n        # Clean up on error\n        click.echo(f\"Error creating project: {str(e)}\", err=True)\n        if project_path.exists():\n            shutil.rmtree(project_path)\n        raise click.Abort()\n</code></pre>"},{"location":"reference/cli/commands/plugin/","title":"Plugin","text":""},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin","title":"<code>plugin</code>","text":"<p>Plugin command - Manage AgentiCraft plugins.</p>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.plugin","title":"<code>plugin()</code>","text":"<p>Manage AgentiCraft plugins.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@click.group()\ndef plugin():\n    \"\"\"Manage AgentiCraft plugins.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.list","title":"<code>list()</code>","text":"<p>List installed plugins.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\ndef list():\n    \"\"\"List installed plugins.\"\"\"\n    from agenticraft.plugins.registry import PluginRegistry\n\n    registry = PluginRegistry()\n    plugins = registry.list_plugins()\n\n    if not plugins:\n        click.echo(\"No plugins installed.\")\n        click.echo(\"\\nInstall plugins with: agenticraft plugin install &lt;name&gt;\")\n        return\n\n    click.echo(\"Installed AgentiCraft plugins:\\n\")\n\n    for plugin_info in plugins:\n        status = \"\u2713\" if plugin_info.get(\"enabled\", True) else \"\u2717\"\n        name = plugin_info[\"name\"]\n        version = plugin_info.get(\"version\", \"unknown\")\n        description = plugin_info.get(\"description\", \"No description\")\n\n        click.echo(f\"  {status} {name} v{version}\")\n        click.echo(f\"     {description}\")\n\n        # Show what the plugin provides\n        provides = []\n        if plugin_info.get(\"tools\"):\n            provides.append(f\"{len(plugin_info['tools'])} tools\")\n        if plugin_info.get(\"agents\"):\n            provides.append(f\"{len(plugin_info['agents'])} agents\")\n        if plugin_info.get(\"providers\"):\n            provides.append(f\"{len(plugin_info['providers'])} providers\")\n\n        if provides:\n            click.echo(f\"     Provides: {', '.join(provides)}\")\n\n        click.echo()\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.info","title":"<code>info(name)</code>","text":"<p>Show detailed information about a plugin.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"name\")\ndef info(name: str):\n    \"\"\"Show detailed information about a plugin.\"\"\"\n    from agenticraft.plugins.registry import PluginRegistry\n\n    registry = PluginRegistry()\n    plugin_info = registry.get_plugin_info(name)\n\n    if not plugin_info:\n        click.echo(f\"Error: Plugin '{name}' not found\", err=True)\n        raise click.Abort()\n\n    click.echo(f\"Plugin: {plugin_info['name']}\")\n    click.echo(f\"Version: {plugin_info.get('version', 'unknown')}\")\n    click.echo(f\"Description: {plugin_info.get('description', 'No description')}\")\n\n    if plugin_info.get(\"author\"):\n        click.echo(f\"Author: {plugin_info['author']}\")\n\n    if plugin_info.get(\"homepage\"):\n        click.echo(f\"Homepage: {plugin_info['homepage']}\")\n\n    # Configuration\n    if plugin_info.get(\"config_schema\"):\n        click.echo(\"\\nConfiguration Schema:\")\n        import json\n        click.echo(json.dumps(plugin_info[\"config_schema\"], indent=2))\n\n    # Tools\n    if plugin_info.get(\"tools\"):\n        click.echo(f\"\\nTools ({len(plugin_info['tools'])}):\")\n        for tool in plugin_info[\"tools\"]:\n            click.echo(f\"  - {tool['name']}: {tool.get('description', 'No description')}\")\n\n    # Agents\n    if plugin_info.get(\"agents\"):\n        click.echo(f\"\\nAgents ({len(plugin_info['agents'])}):\")\n        for agent in plugin_info[\"agents\"]:\n            click.echo(f\"  - {agent['name']}: {agent.get('description', 'No description')}\")\n\n    # Dependencies\n    if plugin_info.get(\"dependencies\"):\n        click.echo(f\"\\nDependencies:\")\n        for dep in plugin_info[\"dependencies\"]:\n            click.echo(f\"  - {dep}\")\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.install","title":"<code>install(name, source, version)</code>","text":"<p>Install a plugin.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"name\")\n@click.option(\"--source\", help=\"Plugin source (GitHub URL, PyPI, or local path)\")\n@click.option(\"--version\", help=\"Specific version to install\")\ndef install(name: str, source: Optional[str], version: Optional[str]):\n    \"\"\"Install a plugin.\"\"\"\n    click.echo(f\"Installing plugin: {name}\")\n\n    if source:\n        click.echo(f\"From: {source}\")\n    else:\n        click.echo(\"From: Plugin Hub (default)\")\n\n    if version:\n        click.echo(f\"Version: {version}\")\n\n    # TODO: Implement actual plugin installation\n    click.echo(\"\\n\u26a0\ufe0f  Plugin installation coming soon!\")\n    click.echo(\"\\nFor now, manually install plugins by:\")\n    click.echo(\"1. pip install &lt;plugin-package&gt;\")\n    click.echo(\"2. Add to your agent configuration\")\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.uninstall","title":"<code>uninstall(name)</code>","text":"<p>Uninstall a plugin.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"name\")\ndef uninstall(name: str):\n    \"\"\"Uninstall a plugin.\"\"\"\n    if click.confirm(f\"Uninstall plugin '{name}'?\"):\n        click.echo(f\"Uninstalling {name}...\")\n        # TODO: Implement actual uninstallation\n        click.echo(\"\u26a0\ufe0f  Plugin uninstallation coming soon!\")\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.enable","title":"<code>enable(name)</code>","text":"<p>Enable a plugin.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"name\")\ndef enable(name: str):\n    \"\"\"Enable a plugin.\"\"\"\n    from agenticraft.plugins.registry import PluginRegistry\n\n    registry = PluginRegistry()\n\n    if registry.enable_plugin(name):\n        click.echo(f\"\u2713 Plugin '{name}' enabled\")\n    else:\n        click.echo(f\"Error: Failed to enable plugin '{name}'\", err=True)\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.disable","title":"<code>disable(name)</code>","text":"<p>Disable a plugin.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"name\")\ndef disable(name: str):\n    \"\"\"Disable a plugin.\"\"\"\n    from agenticraft.plugins.registry import PluginRegistry\n\n    registry = PluginRegistry()\n\n    if registry.disable_plugin(name):\n        click.echo(f\"\u2713 Plugin '{name}' disabled\")\n    else:\n        click.echo(f\"Error: Failed to disable plugin '{name}'\", err=True)\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.update","title":"<code>update(check)</code>","text":"<p>Update installed plugins.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.option(\"--check\", is_flag=True, help=\"Check for updates\")\ndef update(check: bool):\n    \"\"\"Update installed plugins.\"\"\"\n    from agenticraft.plugins.registry import PluginRegistry\n\n    registry = PluginRegistry()\n    plugins = registry.list_plugins()\n\n    if not plugins:\n        click.echo(\"No plugins installed.\")\n        return\n\n    if check:\n        click.echo(\"Checking for plugin updates...\")\n        # TODO: Implement update checking\n        click.echo(\"\u26a0\ufe0f  Update checking coming soon!\")\n    else:\n        click.echo(\"Updating all plugins...\")\n        # TODO: Implement plugin updates\n        click.echo(\"\u26a0\ufe0f  Plugin updates coming soon!\")\n</code></pre>"},{"location":"reference/cli/commands/plugin/#agenticraft.cli.commands.plugin.develop","title":"<code>develop(directory)</code>","text":"<p>Install a plugin in development mode.</p> Source code in <code>agenticraft/cli/commands/plugin.py</code> <pre><code>@plugin.command()\n@click.argument(\"directory\", type=click.Path(exists=True))\ndef develop(directory: str):\n    \"\"\"Install a plugin in development mode.\"\"\"\n    plugin_path = Path(directory).resolve()\n\n    # Check if it's a valid plugin directory\n    if not (plugin_path / \"plugin.yaml\").exists() and not (plugin_path / \"pyproject.toml\").exists():\n        click.echo(\"Error: Not a valid plugin directory\", err=True)\n        click.echo(\"Plugin directory must contain plugin.yaml or pyproject.toml\")\n        raise click.Abort()\n\n    click.echo(f\"Installing plugin in development mode from: {plugin_path}\")\n\n    # TODO: Implement development mode installation\n    click.echo(\"\\n\u26a0\ufe0f  Development mode coming soon!\")\n    click.echo(\"\\nFor now, add the plugin directory to your PYTHONPATH\")\n</code></pre>"},{"location":"reference/cli/commands/run/","title":"Run","text":""},{"location":"reference/cli/commands/run/#agenticraft.cli.commands.run","title":"<code>run</code>","text":"<p>Run command - Run agents from configuration or scripts.</p>"},{"location":"reference/cli/commands/run/#agenticraft.cli.commands.run.run","title":"<code>run(agent_file, prompt, interactive, config, provider)</code>","text":"<p>Run an agent from a Python file or configuration.</p> <p>Examples:</p> <p>agenticraft run agent.py --prompt \"Hello\" agenticraft run config.yaml --interactive</p> Source code in <code>agenticraft/cli/commands/run.py</code> <pre><code>@click.command()\n@click.argument(\"agent_file\", type=click.Path(exists=True))\n@click.option(\n    \"--prompt\",\n    \"-p\",\n    help=\"Initial prompt for the agent\",\n)\n@click.option(\n    \"--interactive\",\n    \"-i\",\n    is_flag=True,\n    help=\"Run in interactive mode\",\n)\n@click.option(\n    \"--config\",\n    \"-c\",\n    type=click.Path(exists=True),\n    help=\"Configuration file\",\n)\n@click.option(\n    \"--provider\",\n    type=click.Choice([\"openai\", \"anthropic\", \"ollama\"]),\n    help=\"LLM provider to use\",\n)\ndef run(agent_file: str, prompt: Optional[str], interactive: bool, config: Optional[str], provider: Optional[str]):\n    \"\"\"\n    Run an agent from a Python file or configuration.\n\n    Examples:\n        agenticraft run agent.py --prompt \"Hello\"\n        agenticraft run config.yaml --interactive\n    \"\"\"\n    file_path = Path(agent_file)\n\n    if file_path.suffix == \".py\":\n        _run_python_agent(file_path, prompt, interactive, config, provider)\n    elif file_path.suffix in [\".yaml\", \".yml\"]:\n        _run_yaml_agent(file_path, prompt, interactive, provider)\n    else:\n        click.echo(f\"Error: Unsupported file type: {file_path.suffix}\", err=True)\n        click.echo(\"Supported types: .py, .yaml, .yml\")\n        raise click.Abort()\n</code></pre>"},{"location":"reference/cli/commands/templates/","title":"Templates","text":""},{"location":"reference/cli/commands/templates/#agenticraft.cli.commands.templates","title":"<code>templates</code>","text":"<p>Templates command - Manage AgentiCraft templates.</p>"},{"location":"reference/cli/commands/templates/#agenticraft.cli.commands.templates.templates","title":"<code>templates()</code>","text":"<p>Manage AgentiCraft templates.</p> Source code in <code>agenticraft/cli/commands/templates.py</code> <pre><code>@click.group()\ndef templates():\n    \"\"\"Manage AgentiCraft templates.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cli/commands/templates/#agenticraft.cli.commands.templates.list","title":"<code>list()</code>","text":"<p>List available templates.</p> Source code in <code>agenticraft/cli/commands/templates.py</code> <pre><code>@templates.command()\ndef list():\n    \"\"\"List available templates.\"\"\"\n    click.echo(\"Available AgentiCraft templates:\\n\")\n\n    for name, description in AVAILABLE_TEMPLATES.items():\n        # Check if template exists\n        template_path = _get_template_path(name)\n        status = \"\u2713\" if template_path.exists() else \"\u2717\"\n\n        click.echo(f\"  {status} {name:12} - {description}\")\n\n    click.echo(\"\\nUse 'agenticraft new &lt;project&gt; --template &lt;name&gt;' to create a project\")\n</code></pre>"},{"location":"reference/cli/commands/templates/#agenticraft.cli.commands.templates.info","title":"<code>info(name)</code>","text":"<p>Show information about a template.</p> Source code in <code>agenticraft/cli/commands/templates.py</code> <pre><code>@templates.command()\n@click.argument(\"name\")\ndef info(name: str):\n    \"\"\"Show information about a template.\"\"\"\n    if name not in AVAILABLE_TEMPLATES:\n        click.echo(f\"Error: Unknown template '{name}'\", err=True)\n        click.echo(f\"Available templates: {', '.join(AVAILABLE_TEMPLATES.keys())}\")\n        raise click.Abort()\n\n    template_path = _get_template_path(name)\n\n    if not template_path.exists():\n        click.echo(f\"Error: Template '{name}' not installed\", err=True)\n        raise click.Abort()\n\n    click.echo(f\"Template: {name}\")\n    click.echo(f\"Description: {AVAILABLE_TEMPLATES[name]}\")\n    click.echo(f\"Location: {template_path}\")\n\n    # Show README preview if available\n    readme_path = template_path / \"README.md\"\n    if readme_path.exists():\n        click.echo(\"\\nREADME Preview:\")\n        click.echo(\"-\" * 50)\n\n        # Show first 20 lines\n        with open(readme_path) as f:\n            lines = f.readlines()[:20]\n            for line in lines:\n                click.echo(line.rstrip())\n\n        if len(lines) == 20:\n            click.echo(\"...\")\n            click.echo(f\"\\nFull README at: {readme_path}\")\n</code></pre>"},{"location":"reference/cli/commands/templates/#agenticraft.cli.commands.templates.install","title":"<code>install(url, name)</code>","text":"<p>Install a template from a URL or GitHub repo.</p> Source code in <code>agenticraft/cli/commands/templates.py</code> <pre><code>@templates.command()\n@click.argument(\"url\")\n@click.option(\"--name\", help=\"Template name (default: derived from URL)\")\ndef install(url: str, name: str):\n    \"\"\"Install a template from a URL or GitHub repo.\"\"\"\n    click.echo(\"Template installation coming soon!\")\n    click.echo(f\"Would install: {url}\")\n    if name:\n        click.echo(f\"As: {name}\")\n</code></pre>"},{"location":"reference/core/__init__/","title":"init","text":""},{"location":"reference/core/__init__/#agenticraft.core","title":"<code>core</code>","text":"<p>Core components of the AgentiCraft framework.</p> <p>This module contains the fundamental building blocks: - Agent: Base agent class with reasoning capabilities - Tool: Tool abstraction for agent capabilities - Workflow: Simple step-based workflow engine - Memory: Memory interfaces for agents - Provider: LLM provider abstraction - Plugin: Plugin architecture for extensions</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent","title":"<code>Agent</code>","text":"<p>Base Agent class for AgentiCraft.</p> <p>The Agent class is the core abstraction in AgentiCraft. It combines an LLM provider, tools, memory, and reasoning patterns to create an intelligent agent capable of complex tasks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent's name</p> <code>'Agent'</code> <code>instructions</code> <code>str</code> <p>System instructions for the agent</p> <code>'You are a helpful AI assistant.'</code> <code>model</code> <code>str</code> <p>LLM model to use</p> <code>'gpt-4'</code> <code>**kwargs</code> <code>Any</code> <p>Additional configuration options</p> <code>{}</code> Example <p>Creating a simple agent::</p> <pre><code>agent = Agent(\n    name=\"MathTutor\",\n    instructions=\"You are a patient math tutor.\",\n    model=\"gpt-4\"\n)\n</code></pre> <p>Creating an agent with tools::</p> <pre><code>from agenticraft import tool\n\n@tool\ndef calculate(expr: str) -&gt; float:\n    return eval(expr)\n\nagent = Agent(\n    name=\"Calculator\",\n    tools=[calculate]\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>class Agent:\n    \"\"\"Base Agent class for AgentiCraft.\n\n    The Agent class is the core abstraction in AgentiCraft. It combines\n    an LLM provider, tools, memory, and reasoning patterns to create\n    an intelligent agent capable of complex tasks.\n\n    Args:\n        name: The agent's name\n        instructions: System instructions for the agent\n        model: LLM model to use\n        **kwargs: Additional configuration options\n\n    Example:\n        Creating a simple agent::\n\n            agent = Agent(\n                name=\"MathTutor\",\n                instructions=\"You are a patient math tutor.\",\n                model=\"gpt-4\"\n            )\n\n        Creating an agent with tools::\n\n            from agenticraft import tool\n\n            @tool\n            def calculate(expr: str) -&gt; float:\n                return eval(expr)\n\n            agent = Agent(\n                name=\"Calculator\",\n                tools=[calculate]\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Agent\",\n        instructions: str = \"You are a helpful AI assistant.\",\n        model: str = \"gpt-4\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize an Agent.\"\"\"\n        # Create config\n        self.config = AgentConfig(\n            name=name,\n            instructions=instructions,\n            model=model,\n            **kwargs\n        )\n\n        # Generate unique ID\n        self.id = uuid4()\n\n        # Initialize components\n        self._provider: Optional[BaseProvider] = None\n        self._tool_registry = ToolRegistry()\n        self._memory_store = MemoryStore()\n        self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n        # Register tools\n        for tool in self.config.tools:\n            self._tool_registry.register(tool)\n\n        # Initialize memory\n        for memory in self.config.memory:\n            self._memory_store.add_memory(memory)\n\n        # Message history\n        self._messages: List[Message] = []\n\n        logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the agent's name.\"\"\"\n        return self.config.name\n\n    @property\n    def provider(self) -&gt; BaseProvider:\n        \"\"\"Get or create the LLM provider.\"\"\"\n        if self._provider is None:\n            # Use explicit provider if specified in config\n            if self.config.provider:\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    provider=self.config.provider,  # Pass explicit provider\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n            else:\n                # Auto-detect from model name\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n        return self._provider\n\n    def run(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent synchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n\n        Example:\n            Basic usage::\n\n                response = agent.run(\"What's the weather?\")\n                print(response.content)\n\n            With context::\n\n                response = agent.run(\n                    \"Summarize this\",\n                    context={\"document\": \"Long text...\"}\n                )\n        \"\"\"\n        return asyncio.run(self.arun(prompt, context, **kwargs))\n\n    async def arun(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent asynchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n        \"\"\"\n        try:\n            # Start reasoning\n            reasoning_trace = self._reasoning.start_trace(prompt)\n\n            # Add user message\n            user_message = Message(\n                role=MessageRole.USER,\n                content=prompt,\n                metadata={\"context\": context} if context else {}\n            )\n            self._messages.append(user_message)\n\n            # Get memory context\n            memory_context = await self._memory_store.get_context(\n                query=prompt,\n                max_items=10\n            )\n\n            # Build conversation\n            messages = self._build_messages(memory_context, context)\n\n            # Get available tools\n            tools_schema = self._tool_registry.get_tools_schema()\n\n            # Call LLM\n            reasoning_trace.add_step(\"calling_llm\", {\n                \"model\": self.config.model,\n                \"temperature\": self.config.temperature\n            })\n\n            response = await self.provider.complete(\n                messages=messages,\n                tools=tools_schema if tools_schema else None,\n                temperature=self.config.temperature,\n                max_tokens=self.config.max_tokens,\n                **kwargs\n            )\n\n            # Process tool calls if any\n            tool_results = []\n            executed_tool_calls = []  # Track the tool calls we executed\n            if response.tool_calls:\n                executed_tool_calls = response.tool_calls  # Save for later\n                tool_results = await self._execute_tools(\n                    response.tool_calls,\n                    reasoning_trace\n                )\n\n                # If tools were called, we need another LLM call with results\n                if tool_results:\n                    tool_message = Message(\n                        role=MessageRole.ASSISTANT,\n                        content=response.content,\n                        tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                    )\n                    self._messages.append(tool_message)\n\n                    # Add tool results\n                    for result in tool_results:\n                        result_message = Message(\n                            role=MessageRole.TOOL,\n                            content=json.dumps(result.result),\n                            metadata={\"tool_call_id\": result.tool_call_id}\n                        )\n                        messages.append(result_message)\n\n                    # Get final response\n                    response = await self.provider.complete(\n                        messages=messages,\n                        temperature=self.config.temperature,\n                        max_tokens=self.config.max_tokens,\n                        **kwargs\n                    )\n\n            # Add assistant message\n            assistant_message = Message(\n                role=MessageRole.ASSISTANT,\n                content=response.content,\n                metadata=response.metadata\n            )\n            self._messages.append(assistant_message)\n\n            # Store in memory\n            await self._memory_store.store(\n                user_message=user_message,\n                assistant_message=assistant_message\n            )\n\n            # Complete reasoning\n            reasoning_trace.complete({\"response\": response.content})\n\n            # Build response\n            return AgentResponse(\n                content=response.content,\n                reasoning=self._reasoning.format_trace(reasoning_trace),\n                tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n                metadata={\n                    \"model\": self.config.model,\n                    \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                    **response.metadata\n                },\n                agent_id=self.id\n            )\n\n        except Exception as e:\n            logger.error(f\"Agent execution failed: {e}\")\n            raise AgentError(f\"Agent execution failed: {e}\") from e\n\n    def _build_messages(\n        self,\n        memory_context: List[Message],\n        user_context: Optional[Dict[str, Any]] = None\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Build the message list for the LLM.\"\"\"\n        messages = []\n\n        # System message\n        system_content = self.config.instructions\n        if user_context:\n            context_str = \"\\n\".join(\n                f\"{k}: {v}\" for k, v in user_context.items()\n            )\n            system_content += f\"\\n\\nContext:\\n{context_str}\"\n\n        messages.append({\n            \"role\": \"system\",\n            \"content\": system_content\n        })\n\n        # Add memory context\n        for msg in memory_context:\n            messages.append(msg.to_dict())\n\n        # Add recent messages\n        for msg in self._messages[-10:]:  # Last 10 messages\n            messages.append(msg.to_dict())\n\n        return messages\n\n    async def _execute_tools(\n        self,\n        tool_calls: List[ToolCall],\n        reasoning_trace: ReasoningTrace\n    ) -&gt; List[ToolResult]:\n        \"\"\"Execute tool calls.\"\"\"\n        results = []\n\n        for tool_call in tool_calls:\n            reasoning_trace.add_step(\"executing_tool\", {\n                \"tool\": tool_call.name,\n                \"arguments\": tool_call.arguments\n            })\n\n            try:\n                result = await self._tool_registry.execute(\n                    tool_call.name,\n                    **tool_call.arguments\n                )\n\n                results.append(ToolResult(\n                    tool_call_id=tool_call.id,\n                    result=result\n                ))\n\n                reasoning_trace.add_step(\"tool_result\", {\n                    \"tool\": tool_call.name,\n                    \"result\": result\n                })\n\n            except Exception as e:\n                logger.error(f\"Tool execution failed: {e}\")\n                error_result = ToolResult(\n                    tool_call_id=tool_call.id,\n                    result={\"error\": str(e)},\n                    error=str(e)\n                )\n                results.append(error_result)\n\n                reasoning_trace.add_step(\"tool_error\", {\n                    \"tool\": tool_call.name,\n                    \"error\": str(e)\n                })\n\n        return results\n\n    def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n        \"\"\"Add a tool to the agent dynamically.\n\n        Args:\n            tool: Tool instance or callable to add\n\n        Example:\n            Adding a tool after creation::\n\n                @tool\n                def search(query: str) -&gt; str:\n                    return f\"Results for {query}\"\n\n                agent.add_tool(search)\n        \"\"\"\n        self._tool_registry.register(tool)\n        self.config.tools.append(tool)\n\n    def clear_memory(self) -&gt; None:\n        \"\"\"Clear the agent's memory.\"\"\"\n        self._memory_store.clear()\n        self._messages.clear()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the agent.\"\"\"\n        return (\n            f\"Agent(name='{self.name}', \"\n            f\"model='{self.config.model}', \"\n            f\"tools={len(self.config.tools)})\"\n        )\n\n    def set_provider(\n        self, \n        provider_name: str,\n        model: Optional[str] = None,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Switch the agent's LLM provider dynamically.\n\n        This method allows switching between different LLM providers while\n        preserving the agent's configuration, tools, memory, and state.\n\n        Args:\n            provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n            model: Optional model override for the new provider\n            api_key: Optional API key for the new provider\n            base_url: Optional base URL (mainly for Ollama)\n            **kwargs: Additional provider-specific parameters\n\n        Raises:\n            ProviderError: If the provider name is invalid or setup fails\n\n        Example:\n            &gt;&gt;&gt; # Switch to Anthropic\n            &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch to local Ollama\n            &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch back to OpenAI with specific model\n            &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n        Note:\n            When switching providers, the agent will:\n            - Preserve all configuration except model and API settings\n            - Maintain tool registrations and functionality\n            - Keep conversation memory intact\n            - Continue with the same reasoning patterns\n        \"\"\"\n        # Map of provider names to their default models\n        provider_defaults = {\n            \"openai\": \"gpt-4\",\n            \"anthropic\": \"claude-3-opus-20240229\",\n            \"ollama\": \"llama2\"\n        }\n\n        # Validate provider name\n        if provider_name not in provider_defaults:\n            raise ProviderError(\n                f\"Unknown provider: {provider_name}. \"\n                f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n            )\n\n        # Determine model to use\n        if model is None:\n            # If no model specified, use provider default\n            model = provider_defaults[provider_name]\n        else:\n            # For Ollama, strip \"ollama/\" prefix if present\n            if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n                model = model[7:]  # Remove \"ollama/\" prefix\n\n        # Store current state for rollback\n        old_provider = self._provider\n        old_model = self.config.model\n        old_api_key = self.config.api_key\n        old_base_url = self.config.base_url\n\n        try:\n            # Update configuration\n            self.config.model = model\n            self.config.provider = provider_name\n            if api_key is not None:\n                self.config.api_key = api_key\n            if base_url is not None:\n                self.config.base_url = base_url\n\n            # Clear current provider to force recreation\n            self._provider = None\n\n            # Access provider property to trigger creation with new settings\n            new_provider = self.provider\n\n            # Validate the new provider works\n            new_provider.validate_auth()\n\n            logger.info(\n                f\"Agent '{self.name}' switched to {provider_name} \"\n                f\"(model: {model})\"\n            )\n\n        except Exception as e:\n            # Rollback on failure\n            self._provider = old_provider\n            self.config.model = old_model\n            self.config.api_key = old_api_key\n            self.config.base_url = old_base_url\n\n            logger.error(f\"Failed to switch provider: {e}\")\n            raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n\n\n    def get_provider_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get information about the current provider.\n\n        Returns:\n            Dict containing provider name, model, and capabilities\n\n        Example:\n            &gt;&gt;&gt; info = agent.get_provider_info()\n            &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n        \"\"\"\n        provider = self.provider\n        provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n        return {\n            \"provider\": provider_name,\n            \"model\": self.config.model,\n            \"supports_streaming\": hasattr(provider, 'stream'),\n            \"supports_tools\": True,  # All providers support tools via adaptation\n            \"timeout\": self.config.timeout,\n            \"max_retries\": self.config.max_retries,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_tokens\n        }\n\n\n    def list_available_providers(self) -&gt; List[str]:\n        \"\"\"List available LLM providers.\n\n        Returns:\n            List of provider names that can be used with set_provider\n\n        Example:\n            &gt;&gt;&gt; providers = agent.list_available_providers()\n            &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n        \"\"\"\n        # Import here to avoid circular imports\n        from .provider import ProviderFactory\n\n        # Ensure providers are loaded\n        ProviderFactory._lazy_load_providers()\n\n        return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the agent's name.</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.provider","title":"<code>provider</code>  <code>property</code>","text":"<p>Get or create the LLM provider.</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.__init__","title":"<code>__init__(name='Agent', instructions='You are a helpful AI assistant.', model='gpt-4', **kwargs)</code>","text":"<p>Initialize an Agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Agent\",\n    instructions: str = \"You are a helpful AI assistant.\",\n    model: str = \"gpt-4\",\n    **kwargs: Any\n):\n    \"\"\"Initialize an Agent.\"\"\"\n    # Create config\n    self.config = AgentConfig(\n        name=name,\n        instructions=instructions,\n        model=model,\n        **kwargs\n    )\n\n    # Generate unique ID\n    self.id = uuid4()\n\n    # Initialize components\n    self._provider: Optional[BaseProvider] = None\n    self._tool_registry = ToolRegistry()\n    self._memory_store = MemoryStore()\n    self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n    # Register tools\n    for tool in self.config.tools:\n        self._tool_registry.register(tool)\n\n    # Initialize memory\n    for memory in self.config.memory:\n        self._memory_store.add_memory(memory)\n\n    # Message history\n    self._messages: List[Message] = []\n\n    logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.run","title":"<code>run(prompt, context=None, **kwargs)</code>","text":"<p>Run the agent synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Example <p>Basic usage::</p> <pre><code>response = agent.run(\"What's the weather?\")\nprint(response.content)\n</code></pre> <p>With context::</p> <pre><code>response = agent.run(\n    \"Summarize this\",\n    context={\"document\": \"Long text...\"}\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def run(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent synchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n\n    Example:\n        Basic usage::\n\n            response = agent.run(\"What's the weather?\")\n            print(response.content)\n\n        With context::\n\n            response = agent.run(\n                \"Summarize this\",\n                context={\"document\": \"Long text...\"}\n            )\n    \"\"\"\n    return asyncio.run(self.arun(prompt, context, **kwargs))\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.arun","title":"<code>arun(prompt, context=None, **kwargs)</code>  <code>async</code>","text":"<p>Run the agent asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>async def arun(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent asynchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n    \"\"\"\n    try:\n        # Start reasoning\n        reasoning_trace = self._reasoning.start_trace(prompt)\n\n        # Add user message\n        user_message = Message(\n            role=MessageRole.USER,\n            content=prompt,\n            metadata={\"context\": context} if context else {}\n        )\n        self._messages.append(user_message)\n\n        # Get memory context\n        memory_context = await self._memory_store.get_context(\n            query=prompt,\n            max_items=10\n        )\n\n        # Build conversation\n        messages = self._build_messages(memory_context, context)\n\n        # Get available tools\n        tools_schema = self._tool_registry.get_tools_schema()\n\n        # Call LLM\n        reasoning_trace.add_step(\"calling_llm\", {\n            \"model\": self.config.model,\n            \"temperature\": self.config.temperature\n        })\n\n        response = await self.provider.complete(\n            messages=messages,\n            tools=tools_schema if tools_schema else None,\n            temperature=self.config.temperature,\n            max_tokens=self.config.max_tokens,\n            **kwargs\n        )\n\n        # Process tool calls if any\n        tool_results = []\n        executed_tool_calls = []  # Track the tool calls we executed\n        if response.tool_calls:\n            executed_tool_calls = response.tool_calls  # Save for later\n            tool_results = await self._execute_tools(\n                response.tool_calls,\n                reasoning_trace\n            )\n\n            # If tools were called, we need another LLM call with results\n            if tool_results:\n                tool_message = Message(\n                    role=MessageRole.ASSISTANT,\n                    content=response.content,\n                    tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                )\n                self._messages.append(tool_message)\n\n                # Add tool results\n                for result in tool_results:\n                    result_message = Message(\n                        role=MessageRole.TOOL,\n                        content=json.dumps(result.result),\n                        metadata={\"tool_call_id\": result.tool_call_id}\n                    )\n                    messages.append(result_message)\n\n                # Get final response\n                response = await self.provider.complete(\n                    messages=messages,\n                    temperature=self.config.temperature,\n                    max_tokens=self.config.max_tokens,\n                    **kwargs\n                )\n\n        # Add assistant message\n        assistant_message = Message(\n            role=MessageRole.ASSISTANT,\n            content=response.content,\n            metadata=response.metadata\n        )\n        self._messages.append(assistant_message)\n\n        # Store in memory\n        await self._memory_store.store(\n            user_message=user_message,\n            assistant_message=assistant_message\n        )\n\n        # Complete reasoning\n        reasoning_trace.complete({\"response\": response.content})\n\n        # Build response\n        return AgentResponse(\n            content=response.content,\n            reasoning=self._reasoning.format_trace(reasoning_trace),\n            tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n            metadata={\n                \"model\": self.config.model,\n                \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                **response.metadata\n            },\n            agent_id=self.id\n        )\n\n    except Exception as e:\n        logger.error(f\"Agent execution failed: {e}\")\n        raise AgentError(f\"Agent execution failed: {e}\") from e\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.add_tool","title":"<code>add_tool(tool)</code>","text":"<p>Add a tool to the agent dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, callable]</code> <p>Tool instance or callable to add</p> required Example <p>Adding a tool after creation::</p> <pre><code>@tool\ndef search(query: str) -&gt; str:\n    return f\"Results for {query}\"\n\nagent.add_tool(search)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n    \"\"\"Add a tool to the agent dynamically.\n\n    Args:\n        tool: Tool instance or callable to add\n\n    Example:\n        Adding a tool after creation::\n\n            @tool\n            def search(query: str) -&gt; str:\n                return f\"Results for {query}\"\n\n            agent.add_tool(search)\n    \"\"\"\n    self._tool_registry.register(tool)\n    self.config.tools.append(tool)\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.clear_memory","title":"<code>clear_memory()</code>","text":"<p>Clear the agent's memory.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def clear_memory(self) -&gt; None:\n    \"\"\"Clear the agent's memory.\"\"\"\n    self._memory_store.clear()\n    self._messages.clear()\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the agent.\"\"\"\n    return (\n        f\"Agent(name='{self.name}', \"\n        f\"model='{self.config.model}', \"\n        f\"tools={len(self.config.tools)})\"\n    )\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.set_provider","title":"<code>set_provider(provider_name, model=None, api_key=None, base_url=None, **kwargs)</code>","text":"<p>Switch the agent's LLM provider dynamically.</p> <p>This method allows switching between different LLM providers while preserving the agent's configuration, tools, memory, and state.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Name of the provider (\"openai\", \"anthropic\", \"ollama\")</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override for the new provider</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for the new provider</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL (mainly for Ollama)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters</p> <code>{}</code> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If the provider name is invalid or setup fails</p> Example Note <p>When switching providers, the agent will: - Preserve all configuration except model and API settings - Maintain tool registrations and functionality - Keep conversation memory intact - Continue with the same reasoning patterns</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def set_provider(\n    self, \n    provider_name: str,\n    model: Optional[str] = None,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"Switch the agent's LLM provider dynamically.\n\n    This method allows switching between different LLM providers while\n    preserving the agent's configuration, tools, memory, and state.\n\n    Args:\n        provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n        model: Optional model override for the new provider\n        api_key: Optional API key for the new provider\n        base_url: Optional base URL (mainly for Ollama)\n        **kwargs: Additional provider-specific parameters\n\n    Raises:\n        ProviderError: If the provider name is invalid or setup fails\n\n    Example:\n        &gt;&gt;&gt; # Switch to Anthropic\n        &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch to local Ollama\n        &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch back to OpenAI with specific model\n        &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n    Note:\n        When switching providers, the agent will:\n        - Preserve all configuration except model and API settings\n        - Maintain tool registrations and functionality\n        - Keep conversation memory intact\n        - Continue with the same reasoning patterns\n    \"\"\"\n    # Map of provider names to their default models\n    provider_defaults = {\n        \"openai\": \"gpt-4\",\n        \"anthropic\": \"claude-3-opus-20240229\",\n        \"ollama\": \"llama2\"\n    }\n\n    # Validate provider name\n    if provider_name not in provider_defaults:\n        raise ProviderError(\n            f\"Unknown provider: {provider_name}. \"\n            f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n        )\n\n    # Determine model to use\n    if model is None:\n        # If no model specified, use provider default\n        model = provider_defaults[provider_name]\n    else:\n        # For Ollama, strip \"ollama/\" prefix if present\n        if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n            model = model[7:]  # Remove \"ollama/\" prefix\n\n    # Store current state for rollback\n    old_provider = self._provider\n    old_model = self.config.model\n    old_api_key = self.config.api_key\n    old_base_url = self.config.base_url\n\n    try:\n        # Update configuration\n        self.config.model = model\n        self.config.provider = provider_name\n        if api_key is not None:\n            self.config.api_key = api_key\n        if base_url is not None:\n            self.config.base_url = base_url\n\n        # Clear current provider to force recreation\n        self._provider = None\n\n        # Access provider property to trigger creation with new settings\n        new_provider = self.provider\n\n        # Validate the new provider works\n        new_provider.validate_auth()\n\n        logger.info(\n            f\"Agent '{self.name}' switched to {provider_name} \"\n            f\"(model: {model})\"\n        )\n\n    except Exception as e:\n        # Rollback on failure\n        self._provider = old_provider\n        self.config.model = old_model\n        self.config.api_key = old_api_key\n        self.config.base_url = old_base_url\n\n        logger.error(f\"Failed to switch provider: {e}\")\n        raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.set_provider--switch-to-anthropic","title":"Switch to Anthropic","text":"<p>agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.set_provider--switch-to-local-ollama","title":"Switch to local Ollama","text":"<p>agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.set_provider--switch-back-to-openai-with-specific-model","title":"Switch back to OpenAI with specific model","text":"<p>agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")</p>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.get_provider_info","title":"<code>get_provider_info()</code>","text":"<p>Get information about the current provider.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing provider name, model, and capabilities</p> Example <p>info = agent.get_provider_info() print(f\"Using {info['provider']} with model {info['model']}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def get_provider_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the current provider.\n\n    Returns:\n        Dict containing provider name, model, and capabilities\n\n    Example:\n        &gt;&gt;&gt; info = agent.get_provider_info()\n        &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n    \"\"\"\n    provider = self.provider\n    provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n    return {\n        \"provider\": provider_name,\n        \"model\": self.config.model,\n        \"supports_streaming\": hasattr(provider, 'stream'),\n        \"supports_tools\": True,  # All providers support tools via adaptation\n        \"timeout\": self.config.timeout,\n        \"max_retries\": self.config.max_retries,\n        \"temperature\": self.config.temperature,\n        \"max_tokens\": self.config.max_tokens\n    }\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.Agent.list_available_providers","title":"<code>list_available_providers()</code>","text":"<p>List available LLM providers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of provider names that can be used with set_provider</p> Example <p>providers = agent.list_available_providers() print(f\"Available providers: {', '.join(providers)}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def list_available_providers(self) -&gt; List[str]:\n    \"\"\"List available LLM providers.\n\n    Returns:\n        List of provider names that can be used with set_provider\n\n    Example:\n        &gt;&gt;&gt; providers = agent.list_available_providers()\n        &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n    \"\"\"\n    # Import here to avoid circular imports\n    from .provider import ProviderFactory\n\n    # Ensure providers are loaded\n    ProviderFactory._lazy_load_providers()\n\n    return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.AgenticraftError","title":"<code>AgenticraftError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all AgentiCraft errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgenticraftError(Exception):\n    \"\"\"Base exception for all AgentiCraft errors.\"\"\"\n\n    def __init__(self, message: str, **kwargs):\n        super().__init__(message)\n        self.message = message\n        self.details = kwargs\n        # Store any additional context as attributes\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.AgentError","title":"<code>AgentError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Raised when an agent operation fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgentError(AgenticraftError):\n    \"\"\"Raised when an agent operation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.ToolError","title":"<code>ToolError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for tool-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolError(AgenticraftError):\n    \"\"\"Base exception for tool-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.ToolNotFoundError","title":"<code>ToolNotFoundError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when a requested tool is not found.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolNotFoundError(ToolError):\n    \"\"\"Raised when a requested tool is not found.\"\"\"\n\n    def __init__(self, tool_name: str):\n        super().__init__(f\"Tool '{tool_name}' not found in registry\")\n        self.tool_name = tool_name\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.ToolExecutionError","title":"<code>ToolExecutionError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when tool execution fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolExecutionError(ToolError):\n    \"\"\"Raised when tool execution fails.\"\"\"\n\n    def __init__(self, message: str, tool_name: str, **kwargs):\n        super().__init__(message, tool_name=tool_name, **kwargs)\n        self.tool_name = tool_name\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.ToolValidationError","title":"<code>ToolValidationError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when tool arguments are invalid.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolValidationError(ToolError):\n    \"\"\"Raised when tool arguments are invalid.\"\"\"\n\n    def __init__(self, tool_name: str, error: str):\n        super().__init__(f\"Tool '{tool_name}' validation failed: {error}\")\n        self.tool_name = tool_name\n        self.error = error\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool","title":"<code>BaseTool</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all tools.</p> <p>Tools extend agent capabilities by providing specific functions that can be called during agent execution.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class BaseTool(ABC):\n    \"\"\"Base class for all tools.\n\n    Tools extend agent capabilities by providing specific functions\n    that can be called during agent execution.\n    \"\"\"\n\n    def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n        \"\"\"Initialize a tool.\n\n        Args:\n            name: Override the tool name\n            description: Override the tool description\n        \"\"\"\n        # Check if class has a name attribute first\n        if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n            self.name = self.__class__.name\n        else:\n            self.name = name or self.__class__.__name__\n\n        # Check if class has a description attribute first\n        if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n            self.description = self.__class__.description\n        else:\n            self.description = description or self.__class__.__doc__ or \"No description\"\n\n    @abstractmethod\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool asynchronously.\"\"\"\n        pass\n\n    def run(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool synchronously.\"\"\"\n        return asyncio.run(self.arun(**kwargs))\n\n    @abstractmethod\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get the tool definition for LLM providers.\"\"\"\n        pass\n\n    async def __call__(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Make the tool callable.\"\"\"\n        return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool.__init__","title":"<code>__init__(name=None, description=None)</code>","text":"<p>Initialize a tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override the tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override the tool description</p> <code>None</code> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n    \"\"\"Initialize a tool.\n\n    Args:\n        name: Override the tool name\n        description: Override the tool description\n    \"\"\"\n    # Check if class has a name attribute first\n    if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n        self.name = self.__class__.name\n    else:\n        self.name = name or self.__class__.__name__\n\n    # Check if class has a description attribute first\n    if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n        self.description = self.__class__.description\n    else:\n        self.description = description or self.__class__.__doc__ or \"No description\"\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool.arun","title":"<code>arun(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Run the tool asynchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\nasync def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool asynchronously.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool.run","title":"<code>run(**kwargs)</code>","text":"<p>Run the tool synchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool synchronously.\"\"\"\n    return asyncio.run(self.arun(**kwargs))\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool.get_definition","title":"<code>get_definition()</code>  <code>abstractmethod</code>","text":"<p>Get the tool definition for LLM providers.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\ndef get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get the tool definition for LLM providers.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.BaseTool.__call__","title":"<code>__call__(**kwargs)</code>  <code>async</code>","text":"<p>Make the tool callable.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def __call__(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Make the tool callable.\"\"\"\n    return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/core/__init__/#agenticraft.core.get_settings","title":"<code>get_settings()</code>  <code>cached</code>","text":"<p>Get the global settings instance (cached).</p> <p>Returns:</p> Type Description <code>AgentiCraftSettings</code> <p>AgentiCraftSettings instance</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>@lru_cache()\ndef get_settings() -&gt; AgentiCraftSettings:\n    \"\"\"Get the global settings instance (cached).\n\n    Returns:\n        AgentiCraftSettings instance\n    \"\"\"\n    return AgentiCraftSettings()\n</code></pre>"},{"location":"reference/core/agent/","title":"Agent","text":""},{"location":"reference/core/agent/#agenticraft.core.agent","title":"<code>agent</code>","text":"<p>Base Agent class for AgentiCraft.</p> <p>This module provides the core Agent class that all agents in AgentiCraft are built upon. The Agent class handles LLM interactions, tool execution, memory management, and reasoning patterns.</p> Example <p>Basic agent creation and usage::</p> <pre><code>from agenticraft import Agent\n\nagent = Agent(\n    name=\"Assistant\",\n    instructions=\"You are a helpful AI assistant.\"\n)\n\nresponse = agent.run(\"Hello, how are you?\")\nprint(response.content)\nprint(response.reasoning)\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.AgentResponse","title":"<code>AgentResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response from an agent execution.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The main response content</p> <code>reasoning</code> <code>Optional[str]</code> <p>The reasoning trace showing how the agent thought</p> <code>tool_calls</code> <code>List[Dict[str, Any]]</code> <p>List of tools called during execution</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata about the response</p> <code>agent_id</code> <code>Optional[UUID]</code> <p>ID of the agent that generated this response</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when response was created</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>class AgentResponse(BaseModel):\n    \"\"\"Response from an agent execution.\n\n    Attributes:\n        content: The main response content\n        reasoning: The reasoning trace showing how the agent thought\n        tool_calls: List of tools called during execution\n        metadata: Additional metadata about the response\n        agent_id: ID of the agent that generated this response\n        created_at: Timestamp when response was created\n    \"\"\"\n\n    content: str\n    reasoning: Optional[str] = None\n    tool_calls: List[Dict[str, Any]] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    agent_id: Optional[UUID] = None\n    created_at: datetime = Field(default_factory=datetime.now)\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.AgentConfig","title":"<code>AgentConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an Agent.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The agent's name</p> <code>instructions</code> <code>str</code> <p>System instructions defining the agent's behavior</p> <code>provider</code> <code>Optional[str]</code> <p>Explicit provider name (optional, auto-detected if not specified)</p> <code>model</code> <code>str</code> <p>LLM model to use (e.g., \"gpt-4\", \"claude-3-opus\")</p> <code>temperature</code> <code>float</code> <p>Sampling temperature (0.0 to 1.0)</p> <code>max_tokens</code> <code>Optional[int]</code> <p>Maximum tokens in response</p> <code>tools</code> <code>List[Any]</code> <p>List of tools available to the agent</p> <code>memory</code> <code>List[Any]</code> <p>Memory configuration</p> <code>reasoning_pattern</code> <code>Optional[Any]</code> <p>Reasoning pattern to use</p> <code>api_key</code> <code>Optional[str]</code> <p>API key for the LLM provider</p> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL for the LLM provider</p> <code>timeout</code> <code>int</code> <p>Request timeout in seconds</p> <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>class AgentConfig(BaseModel):\n    \"\"\"Configuration for an Agent.\n\n    Attributes:\n        name: The agent's name\n        instructions: System instructions defining the agent's behavior\n        provider: Explicit provider name (optional, auto-detected if not specified)\n        model: LLM model to use (e.g., \"gpt-4\", \"claude-3-opus\")\n        temperature: Sampling temperature (0.0 to 1.0)\n        max_tokens: Maximum tokens in response\n        tools: List of tools available to the agent\n        memory: Memory configuration\n        reasoning_pattern: Reasoning pattern to use\n        api_key: API key for the LLM provider\n        base_url: Optional base URL for the LLM provider\n        timeout: Request timeout in seconds\n        max_retries: Maximum number of retry attempts\n        metadata: Additional metadata\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    name: str = Field(default=\"Agent\")\n    instructions: str = Field(\n        default=\"You are a helpful AI assistant.\",\n        description=\"System instructions defining agent behavior\"\n    )\n    provider: Optional[str] = Field(\n        default=None,\n        description=\"Explicit provider name (e.g., 'openai', 'anthropic', 'ollama'). If not specified, auto-detected from model name.\"\n    )\n    model: str = Field(default_factory=lambda: settings.default_model, description=\"LLM model to use\")\n    temperature: float = Field(default_factory=lambda: settings.default_temperature, ge=0.0, le=2.0)\n    max_tokens: Optional[int] = Field(default_factory=lambda: settings.default_max_tokens, gt=0)\n    tools: List[Any] = Field(default_factory=list)\n    memory: List[Any] = Field(default_factory=list)\n    reasoning_pattern: Optional[Any] = None\n    api_key: Optional[str] = Field(default=None, exclude=True)\n    base_url: Optional[str] = None\n    timeout: int = Field(default_factory=lambda: settings.default_timeout, gt=0)\n    max_retries: int = Field(default_factory=lambda: settings.default_max_retries, ge=0)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    @field_validator('provider')\n    def validate_provider(cls, provider: Optional[str]) -&gt; Optional[str]:\n        \"\"\"Validate provider name if specified.\"\"\"\n        if provider is not None:\n            valid_providers = [\"openai\", \"anthropic\", \"ollama\", \"google\"]\n            if provider not in valid_providers:\n                raise ValueError(\n                    f\"Invalid provider: {provider}. \"\n                    f\"Valid providers are: {', '.join(valid_providers)}\"\n                )\n        return provider\n\n    @field_validator('tools')\n    def validate_tools(cls, tools: List[Any]) -&gt; List[Any]:\n        \"\"\"Validate tools are proper type.\"\"\"\n        from .tool import BaseTool\n        for tool in tools:\n            if not (isinstance(tool, BaseTool) or callable(tool)):\n                raise ValueError(f\"Invalid tool type: {type(tool)}\")\n        return tools\n\n    @field_validator('memory')\n    def validate_memory(cls, memory: List[Any]) -&gt; List[Any]:\n        \"\"\"Validate memory instances.\"\"\"\n        from .memory import BaseMemory\n        for mem in memory:\n            if not isinstance(mem, BaseMemory):\n                raise ValueError(f\"Invalid memory type: {type(mem)}\")\n        return memory\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.AgentConfig.validate_provider","title":"<code>validate_provider(provider)</code>","text":"<p>Validate provider name if specified.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>@field_validator('provider')\ndef validate_provider(cls, provider: Optional[str]) -&gt; Optional[str]:\n    \"\"\"Validate provider name if specified.\"\"\"\n    if provider is not None:\n        valid_providers = [\"openai\", \"anthropic\", \"ollama\", \"google\"]\n        if provider not in valid_providers:\n            raise ValueError(\n                f\"Invalid provider: {provider}. \"\n                f\"Valid providers are: {', '.join(valid_providers)}\"\n            )\n    return provider\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.AgentConfig.validate_tools","title":"<code>validate_tools(tools)</code>","text":"<p>Validate tools are proper type.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>@field_validator('tools')\ndef validate_tools(cls, tools: List[Any]) -&gt; List[Any]:\n    \"\"\"Validate tools are proper type.\"\"\"\n    from .tool import BaseTool\n    for tool in tools:\n        if not (isinstance(tool, BaseTool) or callable(tool)):\n            raise ValueError(f\"Invalid tool type: {type(tool)}\")\n    return tools\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.AgentConfig.validate_memory","title":"<code>validate_memory(memory)</code>","text":"<p>Validate memory instances.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>@field_validator('memory')\ndef validate_memory(cls, memory: List[Any]) -&gt; List[Any]:\n    \"\"\"Validate memory instances.\"\"\"\n    from .memory import BaseMemory\n    for mem in memory:\n        if not isinstance(mem, BaseMemory):\n            raise ValueError(f\"Invalid memory type: {type(mem)}\")\n    return memory\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent","title":"<code>Agent</code>","text":"<p>Base Agent class for AgentiCraft.</p> <p>The Agent class is the core abstraction in AgentiCraft. It combines an LLM provider, tools, memory, and reasoning patterns to create an intelligent agent capable of complex tasks.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The agent's name</p> <code>'Agent'</code> <code>instructions</code> <code>str</code> <p>System instructions for the agent</p> <code>'You are a helpful AI assistant.'</code> <code>model</code> <code>str</code> <p>LLM model to use</p> <code>'gpt-4'</code> <code>**kwargs</code> <code>Any</code> <p>Additional configuration options</p> <code>{}</code> Example <p>Creating a simple agent::</p> <pre><code>agent = Agent(\n    name=\"MathTutor\",\n    instructions=\"You are a patient math tutor.\",\n    model=\"gpt-4\"\n)\n</code></pre> <p>Creating an agent with tools::</p> <pre><code>from agenticraft import tool\n\n@tool\ndef calculate(expr: str) -&gt; float:\n    return eval(expr)\n\nagent = Agent(\n    name=\"Calculator\",\n    tools=[calculate]\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>class Agent:\n    \"\"\"Base Agent class for AgentiCraft.\n\n    The Agent class is the core abstraction in AgentiCraft. It combines\n    an LLM provider, tools, memory, and reasoning patterns to create\n    an intelligent agent capable of complex tasks.\n\n    Args:\n        name: The agent's name\n        instructions: System instructions for the agent\n        model: LLM model to use\n        **kwargs: Additional configuration options\n\n    Example:\n        Creating a simple agent::\n\n            agent = Agent(\n                name=\"MathTutor\",\n                instructions=\"You are a patient math tutor.\",\n                model=\"gpt-4\"\n            )\n\n        Creating an agent with tools::\n\n            from agenticraft import tool\n\n            @tool\n            def calculate(expr: str) -&gt; float:\n                return eval(expr)\n\n            agent = Agent(\n                name=\"Calculator\",\n                tools=[calculate]\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str = \"Agent\",\n        instructions: str = \"You are a helpful AI assistant.\",\n        model: str = \"gpt-4\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize an Agent.\"\"\"\n        # Create config\n        self.config = AgentConfig(\n            name=name,\n            instructions=instructions,\n            model=model,\n            **kwargs\n        )\n\n        # Generate unique ID\n        self.id = uuid4()\n\n        # Initialize components\n        self._provider: Optional[BaseProvider] = None\n        self._tool_registry = ToolRegistry()\n        self._memory_store = MemoryStore()\n        self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n        # Register tools\n        for tool in self.config.tools:\n            self._tool_registry.register(tool)\n\n        # Initialize memory\n        for memory in self.config.memory:\n            self._memory_store.add_memory(memory)\n\n        # Message history\n        self._messages: List[Message] = []\n\n        logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the agent's name.\"\"\"\n        return self.config.name\n\n    @property\n    def provider(self) -&gt; BaseProvider:\n        \"\"\"Get or create the LLM provider.\"\"\"\n        if self._provider is None:\n            # Use explicit provider if specified in config\n            if self.config.provider:\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    provider=self.config.provider,  # Pass explicit provider\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n            else:\n                # Auto-detect from model name\n                self._provider = ProviderFactory.create(\n                    model=self.config.model,\n                    api_key=self.config.api_key,\n                    base_url=self.config.base_url,\n                    timeout=self.config.timeout,\n                    max_retries=self.config.max_retries\n                )\n        return self._provider\n\n    def run(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent synchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n\n        Example:\n            Basic usage::\n\n                response = agent.run(\"What's the weather?\")\n                print(response.content)\n\n            With context::\n\n                response = agent.run(\n                    \"Summarize this\",\n                    context={\"document\": \"Long text...\"}\n                )\n        \"\"\"\n        return asyncio.run(self.arun(prompt, context, **kwargs))\n\n    async def arun(\n        self,\n        prompt: str,\n        context: Optional[Dict[str, Any]] = None,\n        **kwargs: Any\n    ) -&gt; AgentResponse:\n        \"\"\"Run the agent asynchronously.\n\n        Args:\n            prompt: The user's prompt/question\n            context: Optional context to provide to the agent\n            **kwargs: Additional arguments passed to the LLM\n\n        Returns:\n            AgentResponse containing the result\n        \"\"\"\n        try:\n            # Start reasoning\n            reasoning_trace = self._reasoning.start_trace(prompt)\n\n            # Add user message\n            user_message = Message(\n                role=MessageRole.USER,\n                content=prompt,\n                metadata={\"context\": context} if context else {}\n            )\n            self._messages.append(user_message)\n\n            # Get memory context\n            memory_context = await self._memory_store.get_context(\n                query=prompt,\n                max_items=10\n            )\n\n            # Build conversation\n            messages = self._build_messages(memory_context, context)\n\n            # Get available tools\n            tools_schema = self._tool_registry.get_tools_schema()\n\n            # Call LLM\n            reasoning_trace.add_step(\"calling_llm\", {\n                \"model\": self.config.model,\n                \"temperature\": self.config.temperature\n            })\n\n            response = await self.provider.complete(\n                messages=messages,\n                tools=tools_schema if tools_schema else None,\n                temperature=self.config.temperature,\n                max_tokens=self.config.max_tokens,\n                **kwargs\n            )\n\n            # Process tool calls if any\n            tool_results = []\n            executed_tool_calls = []  # Track the tool calls we executed\n            if response.tool_calls:\n                executed_tool_calls = response.tool_calls  # Save for later\n                tool_results = await self._execute_tools(\n                    response.tool_calls,\n                    reasoning_trace\n                )\n\n                # If tools were called, we need another LLM call with results\n                if tool_results:\n                    tool_message = Message(\n                        role=MessageRole.ASSISTANT,\n                        content=response.content,\n                        tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                    )\n                    self._messages.append(tool_message)\n\n                    # Add tool results\n                    for result in tool_results:\n                        result_message = Message(\n                            role=MessageRole.TOOL,\n                            content=json.dumps(result.result),\n                            metadata={\"tool_call_id\": result.tool_call_id}\n                        )\n                        messages.append(result_message)\n\n                    # Get final response\n                    response = await self.provider.complete(\n                        messages=messages,\n                        temperature=self.config.temperature,\n                        max_tokens=self.config.max_tokens,\n                        **kwargs\n                    )\n\n            # Add assistant message\n            assistant_message = Message(\n                role=MessageRole.ASSISTANT,\n                content=response.content,\n                metadata=response.metadata\n            )\n            self._messages.append(assistant_message)\n\n            # Store in memory\n            await self._memory_store.store(\n                user_message=user_message,\n                assistant_message=assistant_message\n            )\n\n            # Complete reasoning\n            reasoning_trace.complete({\"response\": response.content})\n\n            # Build response\n            return AgentResponse(\n                content=response.content,\n                reasoning=self._reasoning.format_trace(reasoning_trace),\n                tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n                metadata={\n                    \"model\": self.config.model,\n                    \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                    **response.metadata\n                },\n                agent_id=self.id\n            )\n\n        except Exception as e:\n            logger.error(f\"Agent execution failed: {e}\")\n            raise AgentError(f\"Agent execution failed: {e}\") from e\n\n    def _build_messages(\n        self,\n        memory_context: List[Message],\n        user_context: Optional[Dict[str, Any]] = None\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Build the message list for the LLM.\"\"\"\n        messages = []\n\n        # System message\n        system_content = self.config.instructions\n        if user_context:\n            context_str = \"\\n\".join(\n                f\"{k}: {v}\" for k, v in user_context.items()\n            )\n            system_content += f\"\\n\\nContext:\\n{context_str}\"\n\n        messages.append({\n            \"role\": \"system\",\n            \"content\": system_content\n        })\n\n        # Add memory context\n        for msg in memory_context:\n            messages.append(msg.to_dict())\n\n        # Add recent messages\n        for msg in self._messages[-10:]:  # Last 10 messages\n            messages.append(msg.to_dict())\n\n        return messages\n\n    async def _execute_tools(\n        self,\n        tool_calls: List[ToolCall],\n        reasoning_trace: ReasoningTrace\n    ) -&gt; List[ToolResult]:\n        \"\"\"Execute tool calls.\"\"\"\n        results = []\n\n        for tool_call in tool_calls:\n            reasoning_trace.add_step(\"executing_tool\", {\n                \"tool\": tool_call.name,\n                \"arguments\": tool_call.arguments\n            })\n\n            try:\n                result = await self._tool_registry.execute(\n                    tool_call.name,\n                    **tool_call.arguments\n                )\n\n                results.append(ToolResult(\n                    tool_call_id=tool_call.id,\n                    result=result\n                ))\n\n                reasoning_trace.add_step(\"tool_result\", {\n                    \"tool\": tool_call.name,\n                    \"result\": result\n                })\n\n            except Exception as e:\n                logger.error(f\"Tool execution failed: {e}\")\n                error_result = ToolResult(\n                    tool_call_id=tool_call.id,\n                    result={\"error\": str(e)},\n                    error=str(e)\n                )\n                results.append(error_result)\n\n                reasoning_trace.add_step(\"tool_error\", {\n                    \"tool\": tool_call.name,\n                    \"error\": str(e)\n                })\n\n        return results\n\n    def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n        \"\"\"Add a tool to the agent dynamically.\n\n        Args:\n            tool: Tool instance or callable to add\n\n        Example:\n            Adding a tool after creation::\n\n                @tool\n                def search(query: str) -&gt; str:\n                    return f\"Results for {query}\"\n\n                agent.add_tool(search)\n        \"\"\"\n        self._tool_registry.register(tool)\n        self.config.tools.append(tool)\n\n    def clear_memory(self) -&gt; None:\n        \"\"\"Clear the agent's memory.\"\"\"\n        self._memory_store.clear()\n        self._messages.clear()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the agent.\"\"\"\n        return (\n            f\"Agent(name='{self.name}', \"\n            f\"model='{self.config.model}', \"\n            f\"tools={len(self.config.tools)})\"\n        )\n\n    def set_provider(\n        self, \n        provider_name: str,\n        model: Optional[str] = None,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; None:\n        \"\"\"Switch the agent's LLM provider dynamically.\n\n        This method allows switching between different LLM providers while\n        preserving the agent's configuration, tools, memory, and state.\n\n        Args:\n            provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n            model: Optional model override for the new provider\n            api_key: Optional API key for the new provider\n            base_url: Optional base URL (mainly for Ollama)\n            **kwargs: Additional provider-specific parameters\n\n        Raises:\n            ProviderError: If the provider name is invalid or setup fails\n\n        Example:\n            &gt;&gt;&gt; # Switch to Anthropic\n            &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch to local Ollama\n            &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n            &gt;&gt;&gt; \n            &gt;&gt;&gt; # Switch back to OpenAI with specific model\n            &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n        Note:\n            When switching providers, the agent will:\n            - Preserve all configuration except model and API settings\n            - Maintain tool registrations and functionality\n            - Keep conversation memory intact\n            - Continue with the same reasoning patterns\n        \"\"\"\n        # Map of provider names to their default models\n        provider_defaults = {\n            \"openai\": \"gpt-4\",\n            \"anthropic\": \"claude-3-opus-20240229\",\n            \"ollama\": \"llama2\"\n        }\n\n        # Validate provider name\n        if provider_name not in provider_defaults:\n            raise ProviderError(\n                f\"Unknown provider: {provider_name}. \"\n                f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n            )\n\n        # Determine model to use\n        if model is None:\n            # If no model specified, use provider default\n            model = provider_defaults[provider_name]\n        else:\n            # For Ollama, strip \"ollama/\" prefix if present\n            if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n                model = model[7:]  # Remove \"ollama/\" prefix\n\n        # Store current state for rollback\n        old_provider = self._provider\n        old_model = self.config.model\n        old_api_key = self.config.api_key\n        old_base_url = self.config.base_url\n\n        try:\n            # Update configuration\n            self.config.model = model\n            self.config.provider = provider_name\n            if api_key is not None:\n                self.config.api_key = api_key\n            if base_url is not None:\n                self.config.base_url = base_url\n\n            # Clear current provider to force recreation\n            self._provider = None\n\n            # Access provider property to trigger creation with new settings\n            new_provider = self.provider\n\n            # Validate the new provider works\n            new_provider.validate_auth()\n\n            logger.info(\n                f\"Agent '{self.name}' switched to {provider_name} \"\n                f\"(model: {model})\"\n            )\n\n        except Exception as e:\n            # Rollback on failure\n            self._provider = old_provider\n            self.config.model = old_model\n            self.config.api_key = old_api_key\n            self.config.base_url = old_base_url\n\n            logger.error(f\"Failed to switch provider: {e}\")\n            raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n\n\n    def get_provider_info(self) -&gt; Dict[str, Any]:\n        \"\"\"Get information about the current provider.\n\n        Returns:\n            Dict containing provider name, model, and capabilities\n\n        Example:\n            &gt;&gt;&gt; info = agent.get_provider_info()\n            &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n        \"\"\"\n        provider = self.provider\n        provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n        return {\n            \"provider\": provider_name,\n            \"model\": self.config.model,\n            \"supports_streaming\": hasattr(provider, 'stream'),\n            \"supports_tools\": True,  # All providers support tools via adaptation\n            \"timeout\": self.config.timeout,\n            \"max_retries\": self.config.max_retries,\n            \"temperature\": self.config.temperature,\n            \"max_tokens\": self.config.max_tokens\n        }\n\n\n    def list_available_providers(self) -&gt; List[str]:\n        \"\"\"List available LLM providers.\n\n        Returns:\n            List of provider names that can be used with set_provider\n\n        Example:\n            &gt;&gt;&gt; providers = agent.list_available_providers()\n            &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n        \"\"\"\n        # Import here to avoid circular imports\n        from .provider import ProviderFactory\n\n        # Ensure providers are loaded\n        ProviderFactory._lazy_load_providers()\n\n        return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the agent's name.</p>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.provider","title":"<code>provider</code>  <code>property</code>","text":"<p>Get or create the LLM provider.</p>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.__init__","title":"<code>__init__(name='Agent', instructions='You are a helpful AI assistant.', model='gpt-4', **kwargs)</code>","text":"<p>Initialize an Agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"Agent\",\n    instructions: str = \"You are a helpful AI assistant.\",\n    model: str = \"gpt-4\",\n    **kwargs: Any\n):\n    \"\"\"Initialize an Agent.\"\"\"\n    # Create config\n    self.config = AgentConfig(\n        name=name,\n        instructions=instructions,\n        model=model,\n        **kwargs\n    )\n\n    # Generate unique ID\n    self.id = uuid4()\n\n    # Initialize components\n    self._provider: Optional[BaseProvider] = None\n    self._tool_registry = ToolRegistry()\n    self._memory_store = MemoryStore()\n    self._reasoning = self.config.reasoning_pattern or SimpleReasoning()\n\n    # Register tools\n    for tool in self.config.tools:\n        self._tool_registry.register(tool)\n\n    # Initialize memory\n    for memory in self.config.memory:\n        self._memory_store.add_memory(memory)\n\n    # Message history\n    self._messages: List[Message] = []\n\n    logger.info(f\"Initialized agent '{self.name}' with ID {self.id}\")\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.run","title":"<code>run(prompt, context=None, **kwargs)</code>","text":"<p>Run the agent synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Example <p>Basic usage::</p> <pre><code>response = agent.run(\"What's the weather?\")\nprint(response.content)\n</code></pre> <p>With context::</p> <pre><code>response = agent.run(\n    \"Summarize this\",\n    context={\"document\": \"Long text...\"}\n)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def run(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent synchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n\n    Example:\n        Basic usage::\n\n            response = agent.run(\"What's the weather?\")\n            print(response.content)\n\n        With context::\n\n            response = agent.run(\n                \"Summarize this\",\n                context={\"document\": \"Long text...\"}\n            )\n    \"\"\"\n    return asyncio.run(self.arun(prompt, context, **kwargs))\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.arun","title":"<code>arun(prompt, context=None, **kwargs)</code>  <code>async</code>","text":"<p>Run the agent asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user's prompt/question</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context to provide to the agent</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the LLM</p> <code>{}</code> <p>Returns:</p> Type Description <code>AgentResponse</code> <p>AgentResponse containing the result</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>async def arun(\n    self,\n    prompt: str,\n    context: Optional[Dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; AgentResponse:\n    \"\"\"Run the agent asynchronously.\n\n    Args:\n        prompt: The user's prompt/question\n        context: Optional context to provide to the agent\n        **kwargs: Additional arguments passed to the LLM\n\n    Returns:\n        AgentResponse containing the result\n    \"\"\"\n    try:\n        # Start reasoning\n        reasoning_trace = self._reasoning.start_trace(prompt)\n\n        # Add user message\n        user_message = Message(\n            role=MessageRole.USER,\n            content=prompt,\n            metadata={\"context\": context} if context else {}\n        )\n        self._messages.append(user_message)\n\n        # Get memory context\n        memory_context = await self._memory_store.get_context(\n            query=prompt,\n            max_items=10\n        )\n\n        # Build conversation\n        messages = self._build_messages(memory_context, context)\n\n        # Get available tools\n        tools_schema = self._tool_registry.get_tools_schema()\n\n        # Call LLM\n        reasoning_trace.add_step(\"calling_llm\", {\n            \"model\": self.config.model,\n            \"temperature\": self.config.temperature\n        })\n\n        response = await self.provider.complete(\n            messages=messages,\n            tools=tools_schema if tools_schema else None,\n            temperature=self.config.temperature,\n            max_tokens=self.config.max_tokens,\n            **kwargs\n        )\n\n        # Process tool calls if any\n        tool_results = []\n        executed_tool_calls = []  # Track the tool calls we executed\n        if response.tool_calls:\n            executed_tool_calls = response.tool_calls  # Save for later\n            tool_results = await self._execute_tools(\n                response.tool_calls,\n                reasoning_trace\n            )\n\n            # If tools were called, we need another LLM call with results\n            if tool_results:\n                tool_message = Message(\n                    role=MessageRole.ASSISTANT,\n                    content=response.content,\n                    tool_calls=[tc.model_dump() for tc in response.tool_calls]\n                )\n                self._messages.append(tool_message)\n\n                # Add tool results\n                for result in tool_results:\n                    result_message = Message(\n                        role=MessageRole.TOOL,\n                        content=json.dumps(result.result),\n                        metadata={\"tool_call_id\": result.tool_call_id}\n                    )\n                    messages.append(result_message)\n\n                # Get final response\n                response = await self.provider.complete(\n                    messages=messages,\n                    temperature=self.config.temperature,\n                    max_tokens=self.config.max_tokens,\n                    **kwargs\n                )\n\n        # Add assistant message\n        assistant_message = Message(\n            role=MessageRole.ASSISTANT,\n            content=response.content,\n            metadata=response.metadata\n        )\n        self._messages.append(assistant_message)\n\n        # Store in memory\n        await self._memory_store.store(\n            user_message=user_message,\n            assistant_message=assistant_message\n        )\n\n        # Complete reasoning\n        reasoning_trace.complete({\"response\": response.content})\n\n        # Build response\n        return AgentResponse(\n            content=response.content,\n            reasoning=self._reasoning.format_trace(reasoning_trace),\n            tool_calls=[tc.model_dump() for tc in executed_tool_calls],  # Use the saved tool calls\n            metadata={\n                \"model\": self.config.model,\n                \"reasoning_pattern\": self._reasoning.__class__.__name__,\n                **response.metadata\n            },\n            agent_id=self.id\n        )\n\n    except Exception as e:\n        logger.error(f\"Agent execution failed: {e}\")\n        raise AgentError(f\"Agent execution failed: {e}\") from e\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.add_tool","title":"<code>add_tool(tool)</code>","text":"<p>Add a tool to the agent dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, callable]</code> <p>Tool instance or callable to add</p> required Example <p>Adding a tool after creation::</p> <pre><code>@tool\ndef search(query: str) -&gt; str:\n    return f\"Results for {query}\"\n\nagent.add_tool(search)\n</code></pre> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def add_tool(self, tool: Union[BaseTool, callable]) -&gt; None:\n    \"\"\"Add a tool to the agent dynamically.\n\n    Args:\n        tool: Tool instance or callable to add\n\n    Example:\n        Adding a tool after creation::\n\n            @tool\n            def search(query: str) -&gt; str:\n                return f\"Results for {query}\"\n\n            agent.add_tool(search)\n    \"\"\"\n    self._tool_registry.register(tool)\n    self.config.tools.append(tool)\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.clear_memory","title":"<code>clear_memory()</code>","text":"<p>Clear the agent's memory.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def clear_memory(self) -&gt; None:\n    \"\"\"Clear the agent's memory.\"\"\"\n    self._memory_store.clear()\n    self._messages.clear()\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the agent.</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the agent.\"\"\"\n    return (\n        f\"Agent(name='{self.name}', \"\n        f\"model='{self.config.model}', \"\n        f\"tools={len(self.config.tools)})\"\n    )\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.set_provider","title":"<code>set_provider(provider_name, model=None, api_key=None, base_url=None, **kwargs)</code>","text":"<p>Switch the agent's LLM provider dynamically.</p> <p>This method allows switching between different LLM providers while preserving the agent's configuration, tools, memory, and state.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Name of the provider (\"openai\", \"anthropic\", \"ollama\")</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override for the new provider</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for the new provider</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL (mainly for Ollama)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters</p> <code>{}</code> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If the provider name is invalid or setup fails</p> Example Note <p>When switching providers, the agent will: - Preserve all configuration except model and API settings - Maintain tool registrations and functionality - Keep conversation memory intact - Continue with the same reasoning patterns</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def set_provider(\n    self, \n    provider_name: str,\n    model: Optional[str] = None,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"Switch the agent's LLM provider dynamically.\n\n    This method allows switching between different LLM providers while\n    preserving the agent's configuration, tools, memory, and state.\n\n    Args:\n        provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n        model: Optional model override for the new provider\n        api_key: Optional API key for the new provider\n        base_url: Optional base URL (mainly for Ollama)\n        **kwargs: Additional provider-specific parameters\n\n    Raises:\n        ProviderError: If the provider name is invalid or setup fails\n\n    Example:\n        &gt;&gt;&gt; # Switch to Anthropic\n        &gt;&gt;&gt; agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch to local Ollama\n        &gt;&gt;&gt; agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; # Switch back to OpenAI with specific model\n        &gt;&gt;&gt; agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")\n\n    Note:\n        When switching providers, the agent will:\n        - Preserve all configuration except model and API settings\n        - Maintain tool registrations and functionality\n        - Keep conversation memory intact\n        - Continue with the same reasoning patterns\n    \"\"\"\n    # Map of provider names to their default models\n    provider_defaults = {\n        \"openai\": \"gpt-4\",\n        \"anthropic\": \"claude-3-opus-20240229\",\n        \"ollama\": \"llama2\"\n    }\n\n    # Validate provider name\n    if provider_name not in provider_defaults:\n        raise ProviderError(\n            f\"Unknown provider: {provider_name}. \"\n            f\"Valid providers are: {', '.join(provider_defaults.keys())}\"\n        )\n\n    # Determine model to use\n    if model is None:\n        # If no model specified, use provider default\n        model = provider_defaults[provider_name]\n    else:\n        # For Ollama, strip \"ollama/\" prefix if present\n        if provider_name == \"ollama\" and model.startswith(\"ollama/\"):\n            model = model[7:]  # Remove \"ollama/\" prefix\n\n    # Store current state for rollback\n    old_provider = self._provider\n    old_model = self.config.model\n    old_api_key = self.config.api_key\n    old_base_url = self.config.base_url\n\n    try:\n        # Update configuration\n        self.config.model = model\n        self.config.provider = provider_name\n        if api_key is not None:\n            self.config.api_key = api_key\n        if base_url is not None:\n            self.config.base_url = base_url\n\n        # Clear current provider to force recreation\n        self._provider = None\n\n        # Access provider property to trigger creation with new settings\n        new_provider = self.provider\n\n        # Validate the new provider works\n        new_provider.validate_auth()\n\n        logger.info(\n            f\"Agent '{self.name}' switched to {provider_name} \"\n            f\"(model: {model})\"\n        )\n\n    except Exception as e:\n        # Rollback on failure\n        self._provider = old_provider\n        self.config.model = old_model\n        self.config.api_key = old_api_key\n        self.config.base_url = old_base_url\n\n        logger.error(f\"Failed to switch provider: {e}\")\n        raise ProviderError(f\"Failed to switch to {provider_name}: {e}\") from e\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.set_provider--switch-to-anthropic","title":"Switch to Anthropic","text":"<p>agent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")</p>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.set_provider--switch-to-local-ollama","title":"Switch to local Ollama","text":"<p>agent.set_provider(\"ollama\", model=\"llama2\", base_url=\"http://localhost:11434\")</p>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.set_provider--switch-back-to-openai-with-specific-model","title":"Switch back to OpenAI with specific model","text":"<p>agent.set_provider(\"openai\", model=\"gpt-3.5-turbo\")</p>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.get_provider_info","title":"<code>get_provider_info()</code>","text":"<p>Get information about the current provider.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict containing provider name, model, and capabilities</p> Example <p>info = agent.get_provider_info() print(f\"Using {info['provider']} with model {info['model']}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def get_provider_info(self) -&gt; Dict[str, Any]:\n    \"\"\"Get information about the current provider.\n\n    Returns:\n        Dict containing provider name, model, and capabilities\n\n    Example:\n        &gt;&gt;&gt; info = agent.get_provider_info()\n        &gt;&gt;&gt; print(f\"Using {info['provider']} with model {info['model']}\")\n    \"\"\"\n    provider = self.provider\n    provider_name = provider.__class__.__name__.replace(\"Provider\", \"\").lower()\n\n    return {\n        \"provider\": provider_name,\n        \"model\": self.config.model,\n        \"supports_streaming\": hasattr(provider, 'stream'),\n        \"supports_tools\": True,  # All providers support tools via adaptation\n        \"timeout\": self.config.timeout,\n        \"max_retries\": self.config.max_retries,\n        \"temperature\": self.config.temperature,\n        \"max_tokens\": self.config.max_tokens\n    }\n</code></pre>"},{"location":"reference/core/agent/#agenticraft.core.agent.Agent.list_available_providers","title":"<code>list_available_providers()</code>","text":"<p>List available LLM providers.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of provider names that can be used with set_provider</p> Example <p>providers = agent.list_available_providers() print(f\"Available providers: {', '.join(providers)}\")</p> Source code in <code>agenticraft/core/agent.py</code> <pre><code>def list_available_providers(self) -&gt; List[str]:\n    \"\"\"List available LLM providers.\n\n    Returns:\n        List of provider names that can be used with set_provider\n\n    Example:\n        &gt;&gt;&gt; providers = agent.list_available_providers()\n        &gt;&gt;&gt; print(f\"Available providers: {', '.join(providers)}\")\n    \"\"\"\n    # Import here to avoid circular imports\n    from .provider import ProviderFactory\n\n    # Ensure providers are loaded\n    ProviderFactory._lazy_load_providers()\n\n    return list(ProviderFactory._providers.keys())\n</code></pre>"},{"location":"reference/core/config/","title":"Config","text":""},{"location":"reference/core/config/#agenticraft.core.config","title":"<code>config</code>","text":"<p>Configuration management for AgentiCraft.</p> <p>This module provides centralized configuration management using pydantic-settings. Configuration can be loaded from environment variables, .env files, or set programmatically.</p> Example <p>Loading configuration::</p> <pre><code>from agenticraft.core.config import settings\n\n# Access configuration\nprint(settings.openai_api_key)\nprint(settings.default_model)\n\n# Override configuration\nsettings.default_temperature = 0.5\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings","title":"<code>AgentiCraftSettings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Global settings for AgentiCraft.</p> <p>Settings are loaded from (in order of priority): 1. Environment variables 2. .env file in current directory 3. .env file in parent directories 4. Default values</p> <p>All settings can be overridden using environment variables with the AGENTICRAFT_ prefix.</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>class AgentiCraftSettings(BaseSettings):\n    \"\"\"Global settings for AgentiCraft.\n\n    Settings are loaded from (in order of priority):\n    1. Environment variables\n    2. .env file in current directory\n    3. .env file in parent directories\n    4. Default values\n\n    All settings can be overridden using environment variables\n    with the AGENTICRAFT_ prefix.\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"AGENTICRAFT_\",\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"allow\"\n    )\n\n    # General settings\n    environment: str = Field(\n        default=\"development\",\n        description=\"Environment (development, staging, production)\"\n    )\n    debug: bool = Field(\n        default=False,\n        description=\"Enable debug mode\"\n    )\n    log_level: str = Field(\n        default=\"INFO\",\n        description=\"Logging level\"\n    )\n\n    # API Keys\n    openai_api_key: Optional[str] = Field(\n        default=None,\n        description=\"OpenAI API key\"\n    )\n    anthropic_api_key: Optional[str] = Field(\n        default=None,\n        description=\"Anthropic API key\"\n    )\n    google_api_key: Optional[str] = Field(\n        default=None,\n        description=\"Google API key\"\n    )\n\n    # Model defaults\n    default_model: str = Field(\n        default=\"gpt-4\",\n        description=\"Default LLM model\"\n    )\n    default_temperature: float = Field(\n        default=0.7,\n        ge=0.0,\n        le=2.0,\n        description=\"Default temperature for LLM\"\n    )\n    default_max_tokens: Optional[int] = Field(\n        default=None,\n        gt=0,\n        description=\"Default max tokens for LLM\"\n    )\n    default_timeout: int = Field(\n        default=30,\n        gt=0,\n        description=\"Default timeout in seconds\"\n    )\n    default_max_retries: int = Field(\n        default=3,\n        ge=0,\n        description=\"Default max retries\"\n    )\n\n    # Provider settings\n    openai_base_url: str = Field(\n        default=\"https://api.openai.com/v1\",\n        description=\"OpenAI API base URL\"\n    )\n    anthropic_base_url: str = Field(\n        default=\"https://api.anthropic.com\",\n        description=\"Anthropic API base URL\"\n    )\n    ollama_base_url: str = Field(\n        default=\"http://localhost:11434\",\n        description=\"Ollama base URL\"\n    )\n\n    # Memory settings\n    memory_backend: str = Field(\n        default=\"sqlite\",\n        description=\"Memory backend (sqlite, json, redis)\"\n    )\n    memory_path: Path = Field(\n        default=Path(\"./memory\"),\n        description=\"Path for memory storage\"\n    )\n    conversation_memory_size: int = Field(\n        default=10,\n        gt=0,\n        description=\"Number of conversation turns to keep\"\n    )\n\n    # Telemetry settings\n    telemetry_enabled: bool = Field(\n        default=True,\n        description=\"Enable telemetry\"\n    )\n    telemetry_service_name: str = Field(\n        default=\"agenticraft\",\n        description=\"Service name for telemetry\"\n    )\n    telemetry_export_endpoint: Optional[str] = Field(\n        default=None,\n        description=\"OTLP endpoint for telemetry export\"\n    )\n    telemetry_sample_rate: float = Field(\n        default=1.0,\n        ge=0.0,\n        le=1.0,\n        description=\"Telemetry sampling rate\"\n    )\n\n    # Plugin settings\n    plugins_enabled: bool = Field(\n        default=True,\n        description=\"Enable plugin system\"\n    )\n    plugin_dirs: List[Path] = Field(\n        default_factory=lambda: [Path(\"./plugins\")],\n        description=\"Directories to load plugins from\"\n    )\n\n    # MCP settings\n    mcp_enabled: bool = Field(\n        default=True,\n        description=\"Enable Model Context Protocol\"\n    )\n    mcp_servers: List[str] = Field(\n        default_factory=list,\n        description=\"MCP server URLs to connect to\"\n    )\n\n    # Tool settings\n    tool_execution_timeout: int = Field(\n        default=10,\n        gt=0,\n        description=\"Timeout for tool execution in seconds\"\n    )\n    tool_retry_attempts: int = Field(\n        default=2,\n        ge=0,\n        description=\"Number of retry attempts for failed tools\"\n    )\n\n    # Workflow settings\n    workflow_step_timeout: int = Field(\n        default=60,\n        gt=0,\n        description=\"Default timeout for workflow steps in seconds\"\n    )\n    workflow_max_parallel_steps: int = Field(\n        default=5,\n        gt=0,\n        description=\"Maximum parallel steps in workflows\"\n    )\n\n    # Security settings\n    allow_code_execution: bool = Field(\n        default=False,\n        description=\"Allow execution of arbitrary code in tools\"\n    )\n    allowed_domains: Set[str] = Field(\n        default_factory=set,\n        description=\"Allowed domains for web requests\"\n    )\n\n    @field_validator('log_level')\n    def validate_log_level(cls, v: str) -&gt; str:\n        \"\"\"Validate log level.\"\"\"\n        valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n        v_upper = v.upper()\n        if v_upper not in valid_levels:\n            raise ValueError(f\"Invalid log level: {v}. Must be one of {valid_levels}\")\n        return v_upper\n\n    @field_validator('environment')\n    def validate_environment(cls, v: str) -&gt; str:\n        \"\"\"Validate environment.\"\"\"\n        valid_envs = {\"development\", \"staging\", \"production\", \"test\"}\n        v_lower = v.lower()\n        if v_lower not in valid_envs:\n            raise ValueError(f\"Invalid environment: {v}. Must be one of {valid_envs}\")\n        return v_lower\n\n    @field_validator('memory_backend')\n    def validate_memory_backend(cls, v: str) -&gt; str:\n        \"\"\"Validate memory backend.\"\"\"\n        valid_backends = {\"sqlite\", \"json\", \"redis\"}\n        v_lower = v.lower()\n        if v_lower not in valid_backends:\n            raise ValueError(f\"Invalid memory backend: {v}. Must be one of {valid_backends}\")\n        return v_lower\n\n    def get_api_key(self, provider: str) -&gt; Optional[str]:\n        \"\"\"Get API key for a provider.\n\n        Args:\n            provider: Provider name (openai, anthropic, google)\n\n        Returns:\n            API key if available\n        \"\"\"\n        key_map = {\n            \"openai\": self.openai_api_key,\n            \"anthropic\": self.anthropic_api_key,\n            \"google\": self.google_api_key,\n        }\n        return key_map.get(provider.lower())\n\n    def get_base_url(self, provider: str) -&gt; Optional[str]:\n        \"\"\"Get base URL for a provider.\n\n        Args:\n            provider: Provider name\n\n        Returns:\n            Base URL if available\n        \"\"\"\n        url_map = {\n            \"openai\": self.openai_base_url,\n            \"anthropic\": self.anthropic_base_url,\n            \"ollama\": self.ollama_base_url,\n        }\n        return url_map.get(provider.lower())\n\n    def to_agent_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert settings to agent configuration.\n\n        Returns:\n            Dictionary suitable for Agent initialization\n        \"\"\"\n        return {\n            \"model\": self.default_model,\n            \"temperature\": self.default_temperature,\n            \"max_tokens\": self.default_max_tokens,\n            \"timeout\": self.default_timeout,\n            \"max_retries\": self.default_max_retries,\n        }\n\n    def to_telemetry_config(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert settings to telemetry configuration.\n\n        Returns:\n            Dictionary suitable for Telemetry initialization\n        \"\"\"\n        return {\n            \"service_name\": self.telemetry_service_name,\n            \"export_to\": self.telemetry_export_endpoint,\n            \"enabled\": self.telemetry_enabled,\n            \"sample_rate\": self.telemetry_sample_rate,\n        }\n\n    @property\n    def is_production(self) -&gt; bool:\n        \"\"\"Check if running in production.\"\"\"\n        return self.environment == \"production\"\n\n    @property\n    def is_development(self) -&gt; bool:\n        \"\"\"Check if running in development.\"\"\"\n        return self.environment == \"development\"\n\n    def validate_required_keys(self, providers: List[str]) -&gt; None:\n        \"\"\"Validate that required API keys are present.\n\n        Args:\n            providers: List of providers that need keys\n\n        Raises:\n            ValueError: If required keys are missing\n        \"\"\"\n        missing = []\n        for provider in providers:\n            if not self.get_api_key(provider):\n                missing.append(provider)\n\n        if missing:\n            raise ValueError(\n                f\"Missing API keys for providers: {', '.join(missing)}. \"\n                f\"Set environment variables or update .env file.\"\n            )\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.is_production","title":"<code>is_production</code>  <code>property</code>","text":"<p>Check if running in production.</p>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.is_development","title":"<code>is_development</code>  <code>property</code>","text":"<p>Check if running in development.</p>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.validate_log_level","title":"<code>validate_log_level(v)</code>","text":"<p>Validate log level.</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>@field_validator('log_level')\ndef validate_log_level(cls, v: str) -&gt; str:\n    \"\"\"Validate log level.\"\"\"\n    valid_levels = {\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"}\n    v_upper = v.upper()\n    if v_upper not in valid_levels:\n        raise ValueError(f\"Invalid log level: {v}. Must be one of {valid_levels}\")\n    return v_upper\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.validate_environment","title":"<code>validate_environment(v)</code>","text":"<p>Validate environment.</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>@field_validator('environment')\ndef validate_environment(cls, v: str) -&gt; str:\n    \"\"\"Validate environment.\"\"\"\n    valid_envs = {\"development\", \"staging\", \"production\", \"test\"}\n    v_lower = v.lower()\n    if v_lower not in valid_envs:\n        raise ValueError(f\"Invalid environment: {v}. Must be one of {valid_envs}\")\n    return v_lower\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.validate_memory_backend","title":"<code>validate_memory_backend(v)</code>","text":"<p>Validate memory backend.</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>@field_validator('memory_backend')\ndef validate_memory_backend(cls, v: str) -&gt; str:\n    \"\"\"Validate memory backend.\"\"\"\n    valid_backends = {\"sqlite\", \"json\", \"redis\"}\n    v_lower = v.lower()\n    if v_lower not in valid_backends:\n        raise ValueError(f\"Invalid memory backend: {v}. Must be one of {valid_backends}\")\n    return v_lower\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.get_api_key","title":"<code>get_api_key(provider)</code>","text":"<p>Get API key for a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name (openai, anthropic, google)</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>API key if available</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def get_api_key(self, provider: str) -&gt; Optional[str]:\n    \"\"\"Get API key for a provider.\n\n    Args:\n        provider: Provider name (openai, anthropic, google)\n\n    Returns:\n        API key if available\n    \"\"\"\n    key_map = {\n        \"openai\": self.openai_api_key,\n        \"anthropic\": self.anthropic_api_key,\n        \"google\": self.google_api_key,\n    }\n    return key_map.get(provider.lower())\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.get_base_url","title":"<code>get_base_url(provider)</code>","text":"<p>Get base URL for a provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Base URL if available</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def get_base_url(self, provider: str) -&gt; Optional[str]:\n    \"\"\"Get base URL for a provider.\n\n    Args:\n        provider: Provider name\n\n    Returns:\n        Base URL if available\n    \"\"\"\n    url_map = {\n        \"openai\": self.openai_base_url,\n        \"anthropic\": self.anthropic_base_url,\n        \"ollama\": self.ollama_base_url,\n    }\n    return url_map.get(provider.lower())\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.to_agent_config","title":"<code>to_agent_config()</code>","text":"<p>Convert settings to agent configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary suitable for Agent initialization</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def to_agent_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert settings to agent configuration.\n\n    Returns:\n        Dictionary suitable for Agent initialization\n    \"\"\"\n    return {\n        \"model\": self.default_model,\n        \"temperature\": self.default_temperature,\n        \"max_tokens\": self.default_max_tokens,\n        \"timeout\": self.default_timeout,\n        \"max_retries\": self.default_max_retries,\n    }\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.to_telemetry_config","title":"<code>to_telemetry_config()</code>","text":"<p>Convert settings to telemetry configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary suitable for Telemetry initialization</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def to_telemetry_config(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert settings to telemetry configuration.\n\n    Returns:\n        Dictionary suitable for Telemetry initialization\n    \"\"\"\n    return {\n        \"service_name\": self.telemetry_service_name,\n        \"export_to\": self.telemetry_export_endpoint,\n        \"enabled\": self.telemetry_enabled,\n        \"sample_rate\": self.telemetry_sample_rate,\n    }\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.AgentiCraftSettings.validate_required_keys","title":"<code>validate_required_keys(providers)</code>","text":"<p>Validate that required API keys are present.</p> <p>Parameters:</p> Name Type Description Default <code>providers</code> <code>List[str]</code> <p>List of providers that need keys</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If required keys are missing</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def validate_required_keys(self, providers: List[str]) -&gt; None:\n    \"\"\"Validate that required API keys are present.\n\n    Args:\n        providers: List of providers that need keys\n\n    Raises:\n        ValueError: If required keys are missing\n    \"\"\"\n    missing = []\n    for provider in providers:\n        if not self.get_api_key(provider):\n            missing.append(provider)\n\n    if missing:\n        raise ValueError(\n            f\"Missing API keys for providers: {', '.join(missing)}. \"\n            f\"Set environment variables or update .env file.\"\n        )\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.get_settings","title":"<code>get_settings()</code>  <code>cached</code>","text":"<p>Get the global settings instance (cached).</p> <p>Returns:</p> Type Description <code>AgentiCraftSettings</code> <p>AgentiCraftSettings instance</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>@lru_cache()\ndef get_settings() -&gt; AgentiCraftSettings:\n    \"\"\"Get the global settings instance (cached).\n\n    Returns:\n        AgentiCraftSettings instance\n    \"\"\"\n    return AgentiCraftSettings()\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.reload_settings","title":"<code>reload_settings()</code>","text":"<p>Reload settings from environment.</p> <p>This clears the cache and creates a new settings instance. Useful for testing or when environment variables change.</p> <p>Returns:</p> Type Description <code>AgentiCraftSettings</code> <p>New AgentiCraftSettings instance</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def reload_settings() -&gt; AgentiCraftSettings:\n    \"\"\"Reload settings from environment.\n\n    This clears the cache and creates a new settings instance.\n    Useful for testing or when environment variables change.\n\n    Returns:\n        New AgentiCraftSettings instance\n    \"\"\"\n    get_settings.cache_clear()\n    global settings\n    settings = get_settings()\n    return settings\n</code></pre>"},{"location":"reference/core/config/#agenticraft.core.config.update_settings","title":"<code>update_settings(**kwargs)</code>","text":"<p>Update settings programmatically.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Setting values to update</p> <code>{}</code> Example <p>update_settings(default_model=\"gpt-3.5-turbo\", debug=True)</p> Source code in <code>agenticraft/core/config.py</code> <pre><code>def update_settings(**kwargs: Any) -&gt; None:\n    \"\"\"Update settings programmatically.\n\n    Args:\n        **kwargs: Setting values to update\n\n    Example:\n        update_settings(default_model=\"gpt-3.5-turbo\", debug=True)\n    \"\"\"\n    for key, value in kwargs.items():\n        if hasattr(settings, key):\n            setattr(settings, key, value)\n        else:\n            raise ValueError(f\"Unknown setting: {key}\")\n</code></pre>"},{"location":"reference/core/exceptions/","title":"Exceptions","text":""},{"location":"reference/core/exceptions/#agenticraft.core.exceptions","title":"<code>exceptions</code>","text":"<p>Custom exceptions for AgentiCraft.</p> <p>This module defines all custom exceptions used throughout the AgentiCraft framework. Each exception is designed to provide clear, actionable error messages to developers.</p> Example <p>Handling AgentiCraft exceptions::</p> <pre><code>from agenticraft import Agent, AgentError\n\ntry:\n    agent = Agent()\n    response = agent.run(\"Do something\")\nexcept AgentError as e:\n    print(f\"Agent error: {e}\")\nexcept ToolExecutionError as e:\n    print(f\"Tool failed: {e.tool_name} - {e}\")\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.AgenticraftError","title":"<code>AgenticraftError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all AgentiCraft errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgenticraftError(Exception):\n    \"\"\"Base exception for all AgentiCraft errors.\"\"\"\n\n    def __init__(self, message: str, **kwargs):\n        super().__init__(message)\n        self.message = message\n        self.details = kwargs\n        # Store any additional context as attributes\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.AgentError","title":"<code>AgentError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Raised when an agent operation fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class AgentError(AgenticraftError):\n    \"\"\"Raised when an agent operation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ToolError","title":"<code>ToolError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for tool-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolError(AgenticraftError):\n    \"\"\"Base exception for tool-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ToolNotFoundError","title":"<code>ToolNotFoundError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when a requested tool is not found.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolNotFoundError(ToolError):\n    \"\"\"Raised when a requested tool is not found.\"\"\"\n\n    def __init__(self, tool_name: str):\n        super().__init__(f\"Tool '{tool_name}' not found in registry\")\n        self.tool_name = tool_name\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ToolExecutionError","title":"<code>ToolExecutionError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when tool execution fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolExecutionError(ToolError):\n    \"\"\"Raised when tool execution fails.\"\"\"\n\n    def __init__(self, message: str, tool_name: str, **kwargs):\n        super().__init__(message, tool_name=tool_name, **kwargs)\n        self.tool_name = tool_name\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ToolValidationError","title":"<code>ToolValidationError</code>","text":"<p>               Bases: <code>ToolError</code></p> <p>Raised when tool arguments are invalid.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ToolValidationError(ToolError):\n    \"\"\"Raised when tool arguments are invalid.\"\"\"\n\n    def __init__(self, tool_name: str, error: str):\n        super().__init__(f\"Tool '{tool_name}' validation failed: {error}\")\n        self.tool_name = tool_name\n        self.error = error\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ProviderError","title":"<code>ProviderError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for LLM provider errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ProviderError(AgenticraftError):\n    \"\"\"Base exception for LLM provider errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ProviderNotFoundError","title":"<code>ProviderNotFoundError</code>","text":"<p>               Bases: <code>ProviderError</code></p> <p>Raised when a requested provider is not found.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ProviderNotFoundError(ProviderError):\n    \"\"\"Raised when a requested provider is not found.\"\"\"\n\n    def __init__(self, model: str):\n        super().__init__(\n            f\"No provider found for model '{model}'. \"\n            f\"Supported providers: openai, anthropic, google, ollama\"\n        )\n        self.model = model\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ProviderAuthError","title":"<code>ProviderAuthError</code>","text":"<p>               Bases: <code>ProviderError</code></p> <p>Raised when provider authentication fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ProviderAuthError(ProviderError):\n    \"\"\"Raised when provider authentication fails.\"\"\"\n\n    def __init__(self, provider: str):\n        super().__init__(\n            f\"Authentication failed for {provider}. \"\n            f\"Please check your API key.\"\n        )\n        self.provider = provider\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ProviderRateLimitError","title":"<code>ProviderRateLimitError</code>","text":"<p>               Bases: <code>ProviderError</code></p> <p>Raised when provider rate limit is exceeded.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ProviderRateLimitError(ProviderError):\n    \"\"\"Raised when provider rate limit is exceeded.\"\"\"\n\n    def __init__(self, provider: str, retry_after: int = None):\n        message = f\"Rate limit exceeded for {provider}\"\n        if retry_after:\n            message += f\". Retry after {retry_after} seconds.\"\n        super().__init__(message)\n        self.provider = provider\n        self.retry_after = retry_after\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.MemoryError","title":"<code>MemoryError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for memory-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class MemoryError(AgenticraftError):\n    \"\"\"Base exception for memory-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.MemoryStorageError","title":"<code>MemoryStorageError</code>","text":"<p>               Bases: <code>MemoryError</code></p> <p>Raised when memory storage operations fail.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class MemoryStorageError(MemoryError):\n    \"\"\"Raised when memory storage operations fail.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.WorkflowError","title":"<code>WorkflowError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for workflow-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class WorkflowError(AgenticraftError):\n    \"\"\"Base exception for workflow-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.StepExecutionError","title":"<code>StepExecutionError</code>","text":"<p>               Bases: <code>WorkflowError</code></p> <p>Raised when a workflow step fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class StepExecutionError(WorkflowError):\n    \"\"\"Raised when a workflow step fails.\"\"\"\n\n    def __init__(self, step_name: str, error: str):\n        super().__init__(f\"Step '{step_name}' failed: {error}\")\n        self.step_name = step_name\n        self.error = error\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Raised when configuration is invalid.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ConfigurationError(AgenticraftError):\n    \"\"\"Raised when configuration is invalid.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Raised when validation fails.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class ValidationError(AgenticraftError):\n    \"\"\"Raised when validation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/exceptions/#agenticraft.core.exceptions.PluginError","title":"<code>PluginError</code>","text":"<p>               Bases: <code>AgenticraftError</code></p> <p>Base exception for plugin-related errors.</p> Source code in <code>agenticraft/core/exceptions.py</code> <pre><code>class PluginError(AgenticraftError):\n    \"\"\"Base exception for plugin-related errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/memory/","title":"Memory","text":""},{"location":"reference/core/memory/#agenticraft.core.memory","title":"<code>memory</code>","text":"<p>Memory interfaces for AgentiCraft agents.</p> <p>This module provides the base classes and implementations for agent memory. AgentiCraft uses a simple two-tier memory system: ConversationMemory for recent interactions and KnowledgeMemory for persistent facts.</p> Example <p>Using memory with an agent::</p> <pre><code>from agenticraft import Agent, ConversationMemory, KnowledgeMemory\n\nagent = Agent(\n    name=\"Assistant\",\n    memory=[\n        ConversationMemory(max_entries=10),\n        KnowledgeMemory(persist=True)\n    ]\n)\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryType","title":"<code>MemoryType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Types of memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class MemoryType(str, Enum):\n    \"\"\"Types of memory.\"\"\"\n    CONVERSATION = \"conversation\"\n    KNOWLEDGE = \"knowledge\"\n    EPISODIC = \"episodic\"\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryEntry","title":"<code>MemoryEntry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single entry in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class MemoryEntry(BaseModel):\n    \"\"\"A single entry in memory.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    content: str\n    entry_type: MemoryType = MemoryType.CONVERSATION\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    timestamp: datetime = Field(default_factory=datetime.now)\n    embedding: Optional[List[float]] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"id\": self.id,\n            \"content\": self.content,\n            \"type\": self.entry_type.value,\n            \"metadata\": self.metadata,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"embedding\": self.embedding\n        }\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryEntry.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\n        \"id\": self.id,\n        \"content\": self.content,\n        \"type\": self.entry_type.value,\n        \"metadata\": self.metadata,\n        \"timestamp\": self.timestamp.isoformat(),\n        \"embedding\": self.embedding\n    }\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryItem","title":"<code>MemoryItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single item in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class MemoryItem(BaseModel):\n    \"\"\"A single item in memory.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    content: str\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=datetime.now)\n    accessed_at: datetime = Field(default_factory=datetime.now)\n    access_count: int = 0\n\n    def access(self) -&gt; None:\n        \"\"\"Mark this item as accessed.\"\"\"\n        self.accessed_at = datetime.now()\n        self.access_count += 1\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryItem.access","title":"<code>access()</code>","text":"<p>Mark this item as accessed.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def access(self) -&gt; None:\n    \"\"\"Mark this item as accessed.\"\"\"\n    self.accessed_at = datetime.now()\n    self.access_count += 1\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory","title":"<code>BaseMemory</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for memory implementations.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class BaseMemory(ABC):\n    \"\"\"Base class for memory implementations.\"\"\"\n\n    def __init__(self, memory_type: str = \"base\"):\n        \"\"\"Initialize base memory.\"\"\"\n        self.memory_type = memory_type\n        self.entries: List[MemoryEntry] = []\n\n    @abstractmethod\n    async def store(self, *args, **kwargs) -&gt; str:\n        \"\"\"Store an item in memory.\"\"\"\n        pass\n\n    @abstractmethod\n    async def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n        \"\"\"Search for items in memory.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n        \"\"\"Get recent items from memory.\"\"\"\n        pass\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all items from memory.\"\"\"\n        self.entries.clear()\n\n    async def size(self) -&gt; int:\n        \"\"\"Get the number of items in memory.\"\"\"\n        return len(self.entries)\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.__init__","title":"<code>__init__(memory_type='base')</code>","text":"<p>Initialize base memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def __init__(self, memory_type: str = \"base\"):\n    \"\"\"Initialize base memory.\"\"\"\n    self.memory_type = memory_type\n    self.entries: List[MemoryEntry] = []\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.store","title":"<code>store(*args, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Store an item in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>@abstractmethod\nasync def store(self, *args, **kwargs) -&gt; str:\n    \"\"\"Store an item in memory.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.search","title":"<code>search(query, max_results=5)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Search for items in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>@abstractmethod\nasync def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n    \"\"\"Search for items in memory.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.get_recent","title":"<code>get_recent(limit=10)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get recent items from memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>@abstractmethod\nasync def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n    \"\"\"Get recent items from memory.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.clear","title":"<code>clear()</code>","text":"<p>Clear all items from memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all items from memory.\"\"\"\n    self.entries.clear()\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.BaseMemory.size","title":"<code>size()</code>  <code>async</code>","text":"<p>Get the number of items in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def size(self) -&gt; int:\n    \"\"\"Get the number of items in memory.\"\"\"\n    return len(self.entries)\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory","title":"<code>ConversationMemory</code>","text":"<p>               Bases: <code>BaseMemory</code></p> <p>Memory for recent conversation history.</p> <p>This memory type stores recent messages in a conversation, automatically managing the history size.</p> <p>Parameters:</p> Name Type Description Default <code>max_entries</code> <code>Optional[int]</code> <p>Maximum number of entries to keep</p> <code>None</code> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class ConversationMemory(BaseMemory):\n    \"\"\"Memory for recent conversation history.\n\n    This memory type stores recent messages in a conversation,\n    automatically managing the history size.\n\n    Args:\n        max_entries: Maximum number of entries to keep\n    \"\"\"\n\n    def __init__(self, max_entries: Optional[int] = None):\n        \"\"\"Initialize conversation memory.\"\"\"\n        super().__init__(memory_type=\"conversation\")\n        self.max_entries = max_entries or settings.conversation_memory_size * 2\n        self.entries: List[MemoryEntry] = []\n\n    async def store(self, user_message: Message, assistant_message: Message) -&gt; str:\n        \"\"\"Store a conversation turn in memory.\"\"\"\n        # Store user message\n        user_entry = MemoryEntry(\n            content=f\"User: {user_message.content}\",\n            entry_type=MemoryType.CONVERSATION,\n            metadata={\"role\": \"user\", \"original_message\": user_message.model_dump()}\n        )\n        self.entries.append(user_entry)\n\n        # Store assistant message\n        assistant_entry = MemoryEntry(\n            content=f\"Assistant: {assistant_message.content}\",\n            entry_type=MemoryType.CONVERSATION,\n            metadata={\"role\": \"assistant\", \"original_message\": assistant_message.model_dump()}\n        )\n        self.entries.append(assistant_entry)\n\n        # Trim to max entries\n        if len(self.entries) &gt; self.max_entries:\n            self.entries = self.entries[-self.max_entries:]\n\n        return assistant_entry.id\n\n    async def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n        \"\"\"Search conversation history.\"\"\"\n        results = []\n        query_lower = query.lower()\n\n        for entry in self.entries:\n            if query_lower in entry.content.lower():\n                results.append(entry)\n\n        return results[:max_results]\n\n    async def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n        \"\"\"Get recent conversation entries.\"\"\"\n        # Return in reverse chronological order (newest first)\n        return list(reversed(self.entries[-limit:]))\n\n    def get_messages(self) -&gt; List[Message]:\n        \"\"\"Get all messages in conversation memory.\"\"\"\n        messages = []\n        for entry in self.entries:\n            if \"original_message\" in entry.metadata:\n                msg_data = entry.metadata[\"original_message\"]\n                messages.append(Message(**msg_data))\n        return messages\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory.__init__","title":"<code>__init__(max_entries=None)</code>","text":"<p>Initialize conversation memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def __init__(self, max_entries: Optional[int] = None):\n    \"\"\"Initialize conversation memory.\"\"\"\n    super().__init__(memory_type=\"conversation\")\n    self.max_entries = max_entries or settings.conversation_memory_size * 2\n    self.entries: List[MemoryEntry] = []\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory.store","title":"<code>store(user_message, assistant_message)</code>  <code>async</code>","text":"<p>Store a conversation turn in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def store(self, user_message: Message, assistant_message: Message) -&gt; str:\n    \"\"\"Store a conversation turn in memory.\"\"\"\n    # Store user message\n    user_entry = MemoryEntry(\n        content=f\"User: {user_message.content}\",\n        entry_type=MemoryType.CONVERSATION,\n        metadata={\"role\": \"user\", \"original_message\": user_message.model_dump()}\n    )\n    self.entries.append(user_entry)\n\n    # Store assistant message\n    assistant_entry = MemoryEntry(\n        content=f\"Assistant: {assistant_message.content}\",\n        entry_type=MemoryType.CONVERSATION,\n        metadata={\"role\": \"assistant\", \"original_message\": assistant_message.model_dump()}\n    )\n    self.entries.append(assistant_entry)\n\n    # Trim to max entries\n    if len(self.entries) &gt; self.max_entries:\n        self.entries = self.entries[-self.max_entries:]\n\n    return assistant_entry.id\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory.search","title":"<code>search(query, max_results=5)</code>  <code>async</code>","text":"<p>Search conversation history.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n    \"\"\"Search conversation history.\"\"\"\n    results = []\n    query_lower = query.lower()\n\n    for entry in self.entries:\n        if query_lower in entry.content.lower():\n            results.append(entry)\n\n    return results[:max_results]\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory.get_recent","title":"<code>get_recent(limit=10)</code>  <code>async</code>","text":"<p>Get recent conversation entries.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n    \"\"\"Get recent conversation entries.\"\"\"\n    # Return in reverse chronological order (newest first)\n    return list(reversed(self.entries[-limit:]))\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.ConversationMemory.get_messages","title":"<code>get_messages()</code>","text":"<p>Get all messages in conversation memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def get_messages(self) -&gt; List[Message]:\n    \"\"\"Get all messages in conversation memory.\"\"\"\n    messages = []\n    for entry in self.entries:\n        if \"original_message\" in entry.metadata:\n            msg_data = entry.metadata[\"original_message\"]\n            messages.append(Message(**msg_data))\n    return messages\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory","title":"<code>KnowledgeMemory</code>","text":"<p>               Bases: <code>BaseMemory</code></p> <p>Memory for persistent knowledge and facts.</p> <p>This memory type stores long-term knowledge that persists across conversations.</p> <p>Parameters:</p> Name Type Description Default <code>use_embeddings</code> <code>bool</code> <p>Whether to compute embeddings for entries</p> <code>False</code> <code>persist</code> <code>bool</code> <p>Whether to persist memory to disk</p> <code>False</code> <code>storage_path</code> <code>Optional[str]</code> <p>Path to store persistent memory</p> <code>None</code> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class KnowledgeMemory(BaseMemory):\n    \"\"\"Memory for persistent knowledge and facts.\n\n    This memory type stores long-term knowledge that persists\n    across conversations.\n\n    Args:\n        use_embeddings: Whether to compute embeddings for entries\n        persist: Whether to persist memory to disk\n        storage_path: Path to store persistent memory\n    \"\"\"\n\n    def __init__(self, use_embeddings: bool = False, persist: bool = False, storage_path: Optional[str] = None):\n        \"\"\"Initialize knowledge memory.\"\"\"\n        super().__init__(memory_type=\"knowledge\")\n        self.use_embeddings = use_embeddings\n        self.persist = persist\n        self.storage_path = storage_path or \"./memory/knowledge.json\"\n        self.entries: List[MemoryEntry] = []\n        self.embeddings = None\n\n        # Load from storage if persisting\n        if self.persist:\n            self._load()\n\n    async def store(self, *args, **kwargs) -&gt; str:\n        \"\"\"Store knowledge (for compatibility).\"\"\"\n        if len(args) &gt; 0:\n            content = args[0]\n        else:\n            content = kwargs.get(\"content\", \"\")\n        metadata = kwargs.get(\"metadata\", {})\n        return await self.store_knowledge(content, metadata)\n\n    async def store_knowledge(self, content: str, metadata: Optional[Dict[str, Any]] = None) -&gt; str:\n        \"\"\"Store knowledge in memory.\"\"\"\n        entry = MemoryEntry(\n            content=content,\n            entry_type=MemoryType.KNOWLEDGE,\n            metadata=metadata or {}\n        )\n\n        # Compute embedding if enabled\n        if self.use_embeddings:\n            entry.embedding = compute_embedding(content)\n\n        self.entries.append(entry)\n\n        # Persist if enabled\n        if self.persist:\n            self._save()\n\n        return entry.id\n\n    async def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n        \"\"\"Search knowledge entries.\"\"\"\n        # Simple text matching for now\n        # TODO: Implement vector similarity search\n\n        matches = []\n        query_lower = query.lower()\n\n        for entry in self.entries:\n            if query_lower in entry.content.lower():\n                matches.append(entry)\n\n        return matches[:max_results]\n\n    async def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n        \"\"\"Get recent knowledge entries.\"\"\"\n        return list(reversed(self.entries[-limit:]))\n\n    async def update_knowledge(self, entry_id: str, content: str, metadata: Optional[Dict[str, Any]] = None) -&gt; None:\n        \"\"\"Update an existing knowledge entry.\"\"\"\n        for entry in self.entries:\n            if entry.id == entry_id:\n                entry.content = content\n                if metadata:\n                    entry.metadata = metadata\n                if self.persist:\n                    self._save()\n                break\n\n    async def delete_knowledge(self, entry_id: str) -&gt; None:\n        \"\"\"Delete a knowledge entry.\"\"\"\n        self.entries = [e for e in self.entries if e.id != entry_id]\n        if self.persist:\n            self._save()\n\n    def _load(self) -&gt; None:\n        \"\"\"Load memory from storage.\"\"\"\n        # TODO: Implement persistence\n        pass\n\n    def _save(self) -&gt; None:\n        \"\"\"Save memory to storage.\"\"\"\n        # TODO: Implement persistence\n        pass\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.__init__","title":"<code>__init__(use_embeddings=False, persist=False, storage_path=None)</code>","text":"<p>Initialize knowledge memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def __init__(self, use_embeddings: bool = False, persist: bool = False, storage_path: Optional[str] = None):\n    \"\"\"Initialize knowledge memory.\"\"\"\n    super().__init__(memory_type=\"knowledge\")\n    self.use_embeddings = use_embeddings\n    self.persist = persist\n    self.storage_path = storage_path or \"./memory/knowledge.json\"\n    self.entries: List[MemoryEntry] = []\n    self.embeddings = None\n\n    # Load from storage if persisting\n    if self.persist:\n        self._load()\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.store","title":"<code>store(*args, **kwargs)</code>  <code>async</code>","text":"<p>Store knowledge (for compatibility).</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def store(self, *args, **kwargs) -&gt; str:\n    \"\"\"Store knowledge (for compatibility).\"\"\"\n    if len(args) &gt; 0:\n        content = args[0]\n    else:\n        content = kwargs.get(\"content\", \"\")\n    metadata = kwargs.get(\"metadata\", {})\n    return await self.store_knowledge(content, metadata)\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.store_knowledge","title":"<code>store_knowledge(content, metadata=None)</code>  <code>async</code>","text":"<p>Store knowledge in memory.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def store_knowledge(self, content: str, metadata: Optional[Dict[str, Any]] = None) -&gt; str:\n    \"\"\"Store knowledge in memory.\"\"\"\n    entry = MemoryEntry(\n        content=content,\n        entry_type=MemoryType.KNOWLEDGE,\n        metadata=metadata or {}\n    )\n\n    # Compute embedding if enabled\n    if self.use_embeddings:\n        entry.embedding = compute_embedding(content)\n\n    self.entries.append(entry)\n\n    # Persist if enabled\n    if self.persist:\n        self._save()\n\n    return entry.id\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.search","title":"<code>search(query, max_results=5)</code>  <code>async</code>","text":"<p>Search knowledge entries.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def search(self, query: str, max_results: int = 5) -&gt; List[MemoryEntry]:\n    \"\"\"Search knowledge entries.\"\"\"\n    # Simple text matching for now\n    # TODO: Implement vector similarity search\n\n    matches = []\n    query_lower = query.lower()\n\n    for entry in self.entries:\n        if query_lower in entry.content.lower():\n            matches.append(entry)\n\n    return matches[:max_results]\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.get_recent","title":"<code>get_recent(limit=10)</code>  <code>async</code>","text":"<p>Get recent knowledge entries.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def get_recent(self, limit: int = 10) -&gt; List[MemoryEntry]:\n    \"\"\"Get recent knowledge entries.\"\"\"\n    return list(reversed(self.entries[-limit:]))\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.update_knowledge","title":"<code>update_knowledge(entry_id, content, metadata=None)</code>  <code>async</code>","text":"<p>Update an existing knowledge entry.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def update_knowledge(self, entry_id: str, content: str, metadata: Optional[Dict[str, Any]] = None) -&gt; None:\n    \"\"\"Update an existing knowledge entry.\"\"\"\n    for entry in self.entries:\n        if entry.id == entry_id:\n            entry.content = content\n            if metadata:\n                entry.metadata = metadata\n            if self.persist:\n                self._save()\n            break\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.KnowledgeMemory.delete_knowledge","title":"<code>delete_knowledge(entry_id)</code>  <code>async</code>","text":"<p>Delete a knowledge entry.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def delete_knowledge(self, entry_id: str) -&gt; None:\n    \"\"\"Delete a knowledge entry.\"\"\"\n    self.entries = [e for e in self.entries if e.id != entry_id]\n    if self.persist:\n        self._save()\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore","title":"<code>MemoryStore</code>","text":"<p>Manages multiple memory types for an agent.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>class MemoryStore:\n    \"\"\"Manages multiple memory types for an agent.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize memory store.\"\"\"\n        self.memories: Dict[str, BaseMemory] = {}\n\n    def add_memory(self, memory: BaseMemory) -&gt; None:\n        \"\"\"Add a memory implementation.\"\"\"\n        self.memories[memory.memory_type] = memory\n\n    def get_memory(self, memory_type: str) -&gt; Optional[BaseMemory]:\n        \"\"\"Get memory by type.\"\"\"\n        return self.memories.get(memory_type)\n\n    async def store(self, user_message: Message, assistant_message: Message) -&gt; None:\n        \"\"\"Store messages in all appropriate memories.\"\"\"\n        for memory in self.memories.values():\n            if isinstance(memory, ConversationMemory):\n                await memory.store(user_message, assistant_message)\n            elif isinstance(memory, KnowledgeMemory):\n                # Extract facts from assistant response\n                # TODO: Implement fact extraction\n                pass\n\n    async def get_context(self, query: str, max_items: int = 10) -&gt; List[Message]:\n        \"\"\"Get relevant context from all memories.\"\"\"\n        all_items = []\n\n        # First, get recent conversation history\n        for memory in self.memories.values():\n            if isinstance(memory, ConversationMemory):\n                # Get recent entries from conversation memory\n                recent_items = await memory.get_recent(limit=max_items // 2)\n                # Reverse them back to chronological order for context\n                all_items.extend(reversed(recent_items))\n\n        # Then search for relevant items\n        for memory in self.memories.values():\n            items = await memory.search(query, max_results=max_items // 2)\n            all_items.extend(items)\n\n        # Remove duplicates while preserving order\n        seen_ids = set()\n        unique_items = []\n        for item in all_items:\n            if item.id not in seen_ids:\n                seen_ids.add(item.id)\n                unique_items.append(item)\n\n        # Convert memory entries to messages\n        messages = []\n        for item in unique_items:\n            # Try to reconstruct original message if available\n            if \"original_message\" in item.metadata:\n                msg_data = item.metadata[\"original_message\"]\n                messages.append(Message(**msg_data))\n            else:\n                # Create message from entry\n                role = MessageRole(item.metadata.get(\"role\", \"user\"))\n                messages.append(Message(\n                    role=role,\n                    content=item.content,\n                    metadata=item.metadata\n                ))\n\n        return messages[:max_items]\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all memories.\"\"\"\n        for memory in self.memories.values():\n            memory.clear()\n        # Clear the memories dictionary itself\n        self.memories.clear()\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.__init__","title":"<code>__init__()</code>","text":"<p>Initialize memory store.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize memory store.\"\"\"\n    self.memories: Dict[str, BaseMemory] = {}\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.add_memory","title":"<code>add_memory(memory)</code>","text":"<p>Add a memory implementation.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def add_memory(self, memory: BaseMemory) -&gt; None:\n    \"\"\"Add a memory implementation.\"\"\"\n    self.memories[memory.memory_type] = memory\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.get_memory","title":"<code>get_memory(memory_type)</code>","text":"<p>Get memory by type.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def get_memory(self, memory_type: str) -&gt; Optional[BaseMemory]:\n    \"\"\"Get memory by type.\"\"\"\n    return self.memories.get(memory_type)\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.store","title":"<code>store(user_message, assistant_message)</code>  <code>async</code>","text":"<p>Store messages in all appropriate memories.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def store(self, user_message: Message, assistant_message: Message) -&gt; None:\n    \"\"\"Store messages in all appropriate memories.\"\"\"\n    for memory in self.memories.values():\n        if isinstance(memory, ConversationMemory):\n            await memory.store(user_message, assistant_message)\n        elif isinstance(memory, KnowledgeMemory):\n            # Extract facts from assistant response\n            # TODO: Implement fact extraction\n            pass\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.get_context","title":"<code>get_context(query, max_items=10)</code>  <code>async</code>","text":"<p>Get relevant context from all memories.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>async def get_context(self, query: str, max_items: int = 10) -&gt; List[Message]:\n    \"\"\"Get relevant context from all memories.\"\"\"\n    all_items = []\n\n    # First, get recent conversation history\n    for memory in self.memories.values():\n        if isinstance(memory, ConversationMemory):\n            # Get recent entries from conversation memory\n            recent_items = await memory.get_recent(limit=max_items // 2)\n            # Reverse them back to chronological order for context\n            all_items.extend(reversed(recent_items))\n\n    # Then search for relevant items\n    for memory in self.memories.values():\n        items = await memory.search(query, max_results=max_items // 2)\n        all_items.extend(items)\n\n    # Remove duplicates while preserving order\n    seen_ids = set()\n    unique_items = []\n    for item in all_items:\n        if item.id not in seen_ids:\n            seen_ids.add(item.id)\n            unique_items.append(item)\n\n    # Convert memory entries to messages\n    messages = []\n    for item in unique_items:\n        # Try to reconstruct original message if available\n        if \"original_message\" in item.metadata:\n            msg_data = item.metadata[\"original_message\"]\n            messages.append(Message(**msg_data))\n        else:\n            # Create message from entry\n            role = MessageRole(item.metadata.get(\"role\", \"user\"))\n            messages.append(Message(\n                role=role,\n                content=item.content,\n                metadata=item.metadata\n            ))\n\n    return messages[:max_items]\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.MemoryStore.clear","title":"<code>clear()</code>","text":"<p>Clear all memories.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all memories.\"\"\"\n    for memory in self.memories.values():\n        memory.clear()\n    # Clear the memories dictionary itself\n    self.memories.clear()\n</code></pre>"},{"location":"reference/core/memory/#agenticraft.core.memory.compute_embedding","title":"<code>compute_embedding(text)</code>","text":"<p>Compute embedding for text (placeholder implementation).</p> <p>In production, this would use a real embedding model. For now, returns a mock embedding based on text length.</p> Source code in <code>agenticraft/core/memory.py</code> <pre><code>def compute_embedding(text: str) -&gt; List[float]:\n    \"\"\"Compute embedding for text (placeholder implementation).\n\n    In production, this would use a real embedding model.\n    For now, returns a mock embedding based on text length.\n    \"\"\"\n    # Mock embedding - in real implementation would use sentence-transformers or similar\n    # Create deterministic embedding based on text\n    hash_val = int(hashlib.md5(text.encode()).hexdigest()[:8], 16)\n    # Generate normalized vector\n    embedding = [\n        float((hash_val &gt;&gt; (i * 4)) &amp; 0xF) / 15.0\n        for i in range(128)  # Standard embedding size\n    ]\n    # Normalize\n    magnitude = sum(x**2 for x in embedding) ** 0.5\n    if magnitude &gt; 0:\n        embedding = [x / magnitude for x in embedding]\n    return embedding\n</code></pre>"},{"location":"reference/core/plugin/","title":"Plugin","text":""},{"location":"reference/core/plugin/#agenticraft.core.plugin","title":"<code>plugin</code>","text":"<p>Plugin architecture for AgentiCraft.</p> <p>This module provides the plugin system that allows extending AgentiCraft without modifying the core framework. Plugins can hook into various lifecycle events and add custom functionality.</p> Example <p>Creating a custom plugin::</p> <pre><code>from agenticraft import BasePlugin, PluginInfo\n\nclass LoggingPlugin(BasePlugin):\n    name = \"logging_plugin\"\n    version = \"1.0.0\"\n    description = \"Logs agent events\"\n\n    def get_info(self) -&gt; PluginInfo:\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description\n        )\n\n    def on_agent_created(self, agent: Agent) -&gt; None:\n        print(f\"Agent created: {agent.name}\")\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginInfo","title":"<code>PluginInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a plugin.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginInfo(BaseModel):\n    \"\"\"Information about a plugin.\"\"\"\n\n    name: str\n    version: str\n    description: str\n    author: Optional[str] = None\n    author_email: Optional[str] = None\n    homepage: Optional[str] = None\n    license: Optional[str] = None\n    provides_tools: List[str] = Field(default_factory=list)\n    provides_agents: List[str] = Field(default_factory=list)\n    requires_plugins: List[str] = Field(default_factory=list)\n    requires_packages: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)\n    config_schema: Optional[Dict[str, Any]] = None\n    capabilities: List[str] = Field(default_factory=list)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginConfig","title":"<code>PluginConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a plugin instance.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginConfig(BaseModel):\n    \"\"\"Configuration for a plugin instance.\"\"\"\n\n    enabled: bool = True\n    config: Dict[str, Any] = Field(default_factory=dict)\n    priority: int = 0\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginContext","title":"<code>PluginContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Context provided to plugins.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginContext(BaseModel):\n    \"\"\"Context provided to plugins.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    plugin_dir: Path\n    data_dir: Path\n    cache_dir: Path\n    shared_data: Dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginLifecycle","title":"<code>PluginLifecycle</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Plugin lifecycle states.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginLifecycle(str, Enum):\n    \"\"\"Plugin lifecycle states.\"\"\"\n\n    CREATED = \"created\"\n    INITIALIZED = \"initialized\"\n    STARTED = \"started\"\n    STOPPED = \"stopped\"\n    DESTROYED = \"destroyed\"\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginCapability","title":"<code>PluginCapability</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Plugin capabilities.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginCapability(str, Enum):\n    \"\"\"Plugin capabilities.\"\"\"\n\n    TOOLS = \"tools\"\n    AGENTS = \"agents\"\n    MEMORY = \"memory\"\n    ENHANCEMENT = \"enhancement\"\n    WORKFLOW = \"workflow\"\n    PROVIDER = \"provider\"\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin","title":"<code>BasePlugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for AgentiCraft plugins.</p> <p>Plugins can hook into various lifecycle events to extend functionality without modifying core code.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class BasePlugin(ABC):\n    \"\"\"Base class for AgentiCraft plugins.\n\n    Plugins can hook into various lifecycle events to extend\n    functionality without modifying core code.\n    \"\"\"\n\n    # Plugin metadata (to be overridden)\n    name: str = \"base_plugin\"\n    version: str = \"1.0.0\"\n    description: str = \"Base plugin\"\n\n    def __init__(self, config: Optional[PluginConfig] = None):\n        \"\"\"Initialize plugin with optional configuration.\"\"\"\n        self.config = config or PluginConfig()\n        self.context: Optional[PluginContext] = None\n        self.state = PluginLifecycle.CREATED\n\n    @abstractmethod\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Get plugin information.\n\n        Returns:\n            PluginInfo describing the plugin\n        \"\"\"\n        pass\n\n    def initialize(self) -&gt; None:\n        \"\"\"Initialize the plugin.\n\n        Called when the plugin is first loaded.\n        \"\"\"\n        self.state = PluginLifecycle.INITIALIZED\n\n    def start(self) -&gt; None:\n        \"\"\"Start the plugin.\n\n        Called when the plugin should begin operation.\n        \"\"\"\n        self.state = PluginLifecycle.STARTED\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the plugin.\n\n        Called when the plugin should cease operation.\n        \"\"\"\n        self.state = PluginLifecycle.STOPPED\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up plugin resources.\n\n        Called when the plugin is being unloaded.\n        \"\"\"\n        self.state = PluginLifecycle.DESTROYED\n\n    # Async lifecycle methods\n\n    async def initialize_async(self) -&gt; None:\n        \"\"\"Async initialization.\"\"\"\n        pass\n\n    async def cleanup_async(self) -&gt; None:\n        \"\"\"Async cleanup.\"\"\"\n        pass\n\n    # Tool and agent providers\n\n    def get_tools(self) -&gt; List[Any]:\n        \"\"\"Get tools provided by this plugin.\n\n        Returns:\n            List of tool instances\n        \"\"\"\n        return []\n\n    def get_agents(self) -&gt; List[type]:\n        \"\"\"Get agent classes provided by this plugin.\n\n        Returns:\n            List of agent classes\n        \"\"\"\n        return []\n\n    def get_capabilities(self) -&gt; List[PluginCapability]:\n        \"\"\"Get plugin capabilities.\n\n        Returns:\n            List of capabilities this plugin provides\n        \"\"\"\n        return []\n\n    # Enhancement methods\n\n    def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n        \"\"\"Enhance an agent with plugin functionality.\n\n        Args:\n            agent: Agent to enhance\n\n        Returns:\n            Enhanced agent\n        \"\"\"\n        return agent\n\n    # Dependency checking\n\n    def check_dependencies(self) -&gt; bool:\n        \"\"\"Check if plugin dependencies are satisfied.\n\n        Returns:\n            True if all dependencies are met\n        \"\"\"\n        return True\n\n    # Lifecycle hooks\n\n    def on_agent_created(self, agent: \"Agent\") -&gt; None:\n        \"\"\"Called when an agent is created.\n\n        Args:\n            agent: The newly created agent\n        \"\"\"\n        pass\n\n    def on_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n        \"\"\"Called before an agent starts processing.\n\n        Args:\n            agent: The agent about to run\n            prompt: The user prompt\n            context: Optional context\n        \"\"\"\n        pass\n\n    def on_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n        \"\"\"Called after an agent completes processing.\n\n        Args:\n            agent: The agent that completed\n            response: The generated response\n        \"\"\"\n        pass\n\n    def on_agent_error(self, agent: \"Agent\", error: Exception) -&gt; None:\n        \"\"\"Called when an agent encounters an error.\n\n        Args:\n            agent: The agent that errored\n            error: The exception that occurred\n        \"\"\"\n        pass\n\n    # Tool lifecycle hooks\n\n    def on_tool_registered(self, tool_name: str, tool: Any) -&gt; None:\n        \"\"\"Called when a tool is registered.\n\n        Args:\n            tool_name: Name of the tool\n            tool: The tool instance\n        \"\"\"\n        pass\n\n    def on_tool_execution_start(self, tool_name: str, arguments: Dict[str, Any]) -&gt; None:\n        \"\"\"Called before a tool is executed.\n\n        Args:\n            tool_name: Name of the tool\n            arguments: Tool arguments\n        \"\"\"\n        pass\n\n    def on_tool_execution_complete(self, tool_name: str, result: Any) -&gt; None:\n        \"\"\"Called after a tool completes execution.\n\n        Args:\n            tool_name: Name of the tool\n            result: Tool execution result\n        \"\"\"\n        pass\n\n    def on_tool_error(self, tool_name: str, error: Exception) -&gt; None:\n        \"\"\"Called when a tool encounters an error.\n\n        Args:\n            tool_name: Name of the tool\n            error: The exception that occurred\n        \"\"\"\n        pass\n\n    # Workflow lifecycle hooks\n\n    def on_workflow_created(self, workflow: \"Workflow\") -&gt; None:\n        \"\"\"Called when a workflow is created.\n\n        Args:\n            workflow: The newly created workflow\n        \"\"\"\n        pass\n\n    def on_workflow_start(self, workflow: \"Workflow\", inputs: Dict[str, Any]) -&gt; None:\n        \"\"\"Called before a workflow starts.\n\n        Args:\n            workflow: The workflow about to run\n            inputs: Workflow inputs\n        \"\"\"\n        pass\n\n    def on_workflow_complete(self, workflow: \"Workflow\", result: \"WorkflowResult\") -&gt; None:\n        \"\"\"Called after a workflow completes.\n\n        Args:\n            workflow: The completed workflow\n            result: Workflow execution result\n        \"\"\"\n        pass\n\n    def on_workflow_step_complete(self, workflow: \"Workflow\", step_name: str, result: Any) -&gt; None:\n        \"\"\"Called after each workflow step completes.\n\n        Args:\n            workflow: The workflow\n            step_name: Name of the completed step\n            result: Step result\n        \"\"\"\n        pass\n\n    # Response modification hooks\n\n    def on_response_generated(self, response: \"AgentResponse\") -&gt; \"AgentResponse\":\n        \"\"\"Called when a response is generated, allows modification.\n\n        Args:\n            response: The generated response\n\n        Returns:\n            Modified response (or original if no changes)\n        \"\"\"\n        return response\n\n    def on_reasoning_complete(self, reasoning: str) -&gt; str:\n        \"\"\"Called when reasoning is formatted, allows modification.\n\n        Args:\n            reasoning: The formatted reasoning\n\n        Returns:\n            Modified reasoning (or original if no changes)\n        \"\"\"\n        return reasoning\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize plugin with optional configuration.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def __init__(self, config: Optional[PluginConfig] = None):\n    \"\"\"Initialize plugin with optional configuration.\"\"\"\n    self.config = config or PluginConfig()\n    self.context: Optional[PluginContext] = None\n    self.state = PluginLifecycle.CREATED\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.get_info","title":"<code>get_info()</code>  <code>abstractmethod</code>","text":"<p>Get plugin information.</p> <p>Returns:</p> Type Description <code>PluginInfo</code> <p>PluginInfo describing the plugin</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>@abstractmethod\ndef get_info(self) -&gt; PluginInfo:\n    \"\"\"Get plugin information.\n\n    Returns:\n        PluginInfo describing the plugin\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the plugin.</p> <p>Called when the plugin is first loaded.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the plugin.\n\n    Called when the plugin is first loaded.\n    \"\"\"\n    self.state = PluginLifecycle.INITIALIZED\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.start","title":"<code>start()</code>","text":"<p>Start the plugin.</p> <p>Called when the plugin should begin operation.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the plugin.\n\n    Called when the plugin should begin operation.\n    \"\"\"\n    self.state = PluginLifecycle.STARTED\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.stop","title":"<code>stop()</code>","text":"<p>Stop the plugin.</p> <p>Called when the plugin should cease operation.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the plugin.\n\n    Called when the plugin should cease operation.\n    \"\"\"\n    self.state = PluginLifecycle.STOPPED\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.cleanup","title":"<code>cleanup()</code>","text":"<p>Clean up plugin resources.</p> <p>Called when the plugin is being unloaded.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Clean up plugin resources.\n\n    Called when the plugin is being unloaded.\n    \"\"\"\n    self.state = PluginLifecycle.DESTROYED\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.initialize_async","title":"<code>initialize_async()</code>  <code>async</code>","text":"<p>Async initialization.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>async def initialize_async(self) -&gt; None:\n    \"\"\"Async initialization.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.cleanup_async","title":"<code>cleanup_async()</code>  <code>async</code>","text":"<p>Async cleanup.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>async def cleanup_async(self) -&gt; None:\n    \"\"\"Async cleanup.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.get_tools","title":"<code>get_tools()</code>","text":"<p>Get tools provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List of tool instances</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_tools(self) -&gt; List[Any]:\n    \"\"\"Get tools provided by this plugin.\n\n    Returns:\n        List of tool instances\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.get_agents","title":"<code>get_agents()</code>","text":"<p>Get agent classes provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[type]</code> <p>List of agent classes</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_agents(self) -&gt; List[type]:\n    \"\"\"Get agent classes provided by this plugin.\n\n    Returns:\n        List of agent classes\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.get_capabilities","title":"<code>get_capabilities()</code>","text":"<p>Get plugin capabilities.</p> <p>Returns:</p> Type Description <code>List[PluginCapability]</code> <p>List of capabilities this plugin provides</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_capabilities(self) -&gt; List[PluginCapability]:\n    \"\"\"Get plugin capabilities.\n\n    Returns:\n        List of capabilities this plugin provides\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.enhance_agent","title":"<code>enhance_agent(agent)</code>","text":"<p>Enhance an agent with plugin functionality.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>Agent to enhance</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>Enhanced agent</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n    \"\"\"Enhance an agent with plugin functionality.\n\n    Args:\n        agent: Agent to enhance\n\n    Returns:\n        Enhanced agent\n    \"\"\"\n    return agent\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.check_dependencies","title":"<code>check_dependencies()</code>","text":"<p>Check if plugin dependencies are satisfied.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all dependencies are met</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def check_dependencies(self) -&gt; bool:\n    \"\"\"Check if plugin dependencies are satisfied.\n\n    Returns:\n        True if all dependencies are met\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_agent_created","title":"<code>on_agent_created(agent)</code>","text":"<p>Called when an agent is created.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The newly created agent</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_created(self, agent: \"Agent\") -&gt; None:\n    \"\"\"Called when an agent is created.\n\n    Args:\n        agent: The newly created agent\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_agent_run_start","title":"<code>on_agent_run_start(agent, prompt, context)</code>","text":"<p>Called before an agent starts processing.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent about to run</p> required <code>prompt</code> <code>str</code> <p>The user prompt</p> required <code>context</code> <code>Optional[Dict[str, Any]]</code> <p>Optional context</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n    \"\"\"Called before an agent starts processing.\n\n    Args:\n        agent: The agent about to run\n        prompt: The user prompt\n        context: Optional context\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_agent_run_complete","title":"<code>on_agent_run_complete(agent, response)</code>","text":"<p>Called after an agent completes processing.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent that completed</p> required <code>response</code> <code>AgentResponse</code> <p>The generated response</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n    \"\"\"Called after an agent completes processing.\n\n    Args:\n        agent: The agent that completed\n        response: The generated response\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_agent_error","title":"<code>on_agent_error(agent, error)</code>","text":"<p>Called when an agent encounters an error.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent that errored</p> required <code>error</code> <code>Exception</code> <p>The exception that occurred</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_error(self, agent: \"Agent\", error: Exception) -&gt; None:\n    \"\"\"Called when an agent encounters an error.\n\n    Args:\n        agent: The agent that errored\n        error: The exception that occurred\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_tool_registered","title":"<code>on_tool_registered(tool_name, tool)</code>","text":"<p>Called when a tool is registered.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>tool</code> <code>Any</code> <p>The tool instance</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_registered(self, tool_name: str, tool: Any) -&gt; None:\n    \"\"\"Called when a tool is registered.\n\n    Args:\n        tool_name: Name of the tool\n        tool: The tool instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_tool_execution_start","title":"<code>on_tool_execution_start(tool_name, arguments)</code>","text":"<p>Called before a tool is executed.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>arguments</code> <code>Dict[str, Any]</code> <p>Tool arguments</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_execution_start(self, tool_name: str, arguments: Dict[str, Any]) -&gt; None:\n    \"\"\"Called before a tool is executed.\n\n    Args:\n        tool_name: Name of the tool\n        arguments: Tool arguments\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_tool_execution_complete","title":"<code>on_tool_execution_complete(tool_name, result)</code>","text":"<p>Called after a tool completes execution.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>result</code> <code>Any</code> <p>Tool execution result</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_execution_complete(self, tool_name: str, result: Any) -&gt; None:\n    \"\"\"Called after a tool completes execution.\n\n    Args:\n        tool_name: Name of the tool\n        result: Tool execution result\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_tool_error","title":"<code>on_tool_error(tool_name, error)</code>","text":"<p>Called when a tool encounters an error.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>error</code> <code>Exception</code> <p>The exception that occurred</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_error(self, tool_name: str, error: Exception) -&gt; None:\n    \"\"\"Called when a tool encounters an error.\n\n    Args:\n        tool_name: Name of the tool\n        error: The exception that occurred\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_workflow_created","title":"<code>on_workflow_created(workflow)</code>","text":"<p>Called when a workflow is created.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The newly created workflow</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_workflow_created(self, workflow: \"Workflow\") -&gt; None:\n    \"\"\"Called when a workflow is created.\n\n    Args:\n        workflow: The newly created workflow\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_workflow_start","title":"<code>on_workflow_start(workflow, inputs)</code>","text":"<p>Called before a workflow starts.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The workflow about to run</p> required <code>inputs</code> <code>Dict[str, Any]</code> <p>Workflow inputs</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_workflow_start(self, workflow: \"Workflow\", inputs: Dict[str, Any]) -&gt; None:\n    \"\"\"Called before a workflow starts.\n\n    Args:\n        workflow: The workflow about to run\n        inputs: Workflow inputs\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_workflow_complete","title":"<code>on_workflow_complete(workflow, result)</code>","text":"<p>Called after a workflow completes.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The completed workflow</p> required <code>result</code> <code>WorkflowResult</code> <p>Workflow execution result</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_workflow_complete(self, workflow: \"Workflow\", result: \"WorkflowResult\") -&gt; None:\n    \"\"\"Called after a workflow completes.\n\n    Args:\n        workflow: The completed workflow\n        result: Workflow execution result\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_workflow_step_complete","title":"<code>on_workflow_step_complete(workflow, step_name, result)</code>","text":"<p>Called after each workflow step completes.</p> <p>Parameters:</p> Name Type Description Default <code>workflow</code> <code>Workflow</code> <p>The workflow</p> required <code>step_name</code> <code>str</code> <p>Name of the completed step</p> required <code>result</code> <code>Any</code> <p>Step result</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_workflow_step_complete(self, workflow: \"Workflow\", step_name: str, result: Any) -&gt; None:\n    \"\"\"Called after each workflow step completes.\n\n    Args:\n        workflow: The workflow\n        step_name: Name of the completed step\n        result: Step result\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_response_generated","title":"<code>on_response_generated(response)</code>","text":"<p>Called when a response is generated, allows modification.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>AgentResponse</code> <p>The generated response</p> required <p>Returns:</p> Type Description <code>AgentResponse</code> <p>Modified response (or original if no changes)</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_response_generated(self, response: \"AgentResponse\") -&gt; \"AgentResponse\":\n    \"\"\"Called when a response is generated, allows modification.\n\n    Args:\n        response: The generated response\n\n    Returns:\n        Modified response (or original if no changes)\n    \"\"\"\n    return response\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.BasePlugin.on_reasoning_complete","title":"<code>on_reasoning_complete(reasoning)</code>","text":"<p>Called when reasoning is formatted, allows modification.</p> <p>Parameters:</p> Name Type Description Default <code>reasoning</code> <code>str</code> <p>The formatted reasoning</p> required <p>Returns:</p> Type Description <code>str</code> <p>Modified reasoning (or original if no changes)</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_reasoning_complete(self, reasoning: str) -&gt; str:\n    \"\"\"Called when reasoning is formatted, allows modification.\n\n    Args:\n        reasoning: The formatted reasoning\n\n    Returns:\n        Modified reasoning (or original if no changes)\n    \"\"\"\n    return reasoning\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Registry for managing plugins.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class PluginRegistry:\n    \"\"\"Registry for managing plugins.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize plugin registry.\"\"\"\n        self._plugins: List[BasePlugin] = []\n\n    def register(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Register a plugin.\n\n        Args:\n            plugin: Plugin instance to register\n        \"\"\"\n        self._plugins.append(plugin)\n\n    def unregister(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Unregister a plugin.\n\n        Args:\n            plugin: Plugin instance to remove\n        \"\"\"\n        if plugin in self._plugins:\n            self._plugins.remove(plugin)\n\n    def get_plugins(self) -&gt; List[BasePlugin]:\n        \"\"\"Get all registered plugins.\"\"\"\n        return self._plugins.copy()\n\n    # Hook execution methods\n\n    def emit_agent_created(self, agent: \"Agent\") -&gt; None:\n        \"\"\"Emit agent created event to all plugins.\"\"\"\n        for plugin in self._plugins:\n            try:\n                plugin.on_agent_created(agent)\n            except Exception:\n                pass  # Plugins shouldn't break core functionality\n\n    def emit_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n        \"\"\"Emit agent run start event.\"\"\"\n        for plugin in self._plugins:\n            try:\n                plugin.on_agent_run_start(agent, prompt, context)\n            except Exception:\n                pass\n\n    def emit_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n        \"\"\"Emit agent run complete event.\"\"\"\n        for plugin in self._plugins:\n            try:\n                plugin.on_agent_run_complete(agent, response)\n            except Exception:\n                pass\n\n    def emit_response_generated(self, response: \"AgentResponse\") -&gt; \"AgentResponse\":\n        \"\"\"Emit response generated event, allowing modification.\"\"\"\n        for plugin in self._plugins:\n            try:\n                response = plugin.on_response_generated(response)\n            except Exception:\n                pass\n        return response\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered plugins.\"\"\"\n        self._plugins.clear()\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize plugin registry.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize plugin registry.\"\"\"\n    self._plugins: List[BasePlugin] = []\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.register","title":"<code>register(plugin)</code>","text":"<p>Register a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to register</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def register(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin.\n\n    Args:\n        plugin: Plugin instance to register\n    \"\"\"\n    self._plugins.append(plugin)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.unregister","title":"<code>unregister(plugin)</code>","text":"<p>Unregister a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to remove</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def unregister(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Unregister a plugin.\n\n    Args:\n        plugin: Plugin instance to remove\n    \"\"\"\n    if plugin in self._plugins:\n        self._plugins.remove(plugin)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.get_plugins","title":"<code>get_plugins()</code>","text":"<p>Get all registered plugins.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_plugins(self) -&gt; List[BasePlugin]:\n    \"\"\"Get all registered plugins.\"\"\"\n    return self._plugins.copy()\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.emit_agent_created","title":"<code>emit_agent_created(agent)</code>","text":"<p>Emit agent created event to all plugins.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def emit_agent_created(self, agent: \"Agent\") -&gt; None:\n    \"\"\"Emit agent created event to all plugins.\"\"\"\n    for plugin in self._plugins:\n        try:\n            plugin.on_agent_created(agent)\n        except Exception:\n            pass  # Plugins shouldn't break core functionality\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.emit_agent_run_start","title":"<code>emit_agent_run_start(agent, prompt, context)</code>","text":"<p>Emit agent run start event.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def emit_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n    \"\"\"Emit agent run start event.\"\"\"\n    for plugin in self._plugins:\n        try:\n            plugin.on_agent_run_start(agent, prompt, context)\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.emit_agent_run_complete","title":"<code>emit_agent_run_complete(agent, response)</code>","text":"<p>Emit agent run complete event.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def emit_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n    \"\"\"Emit agent run complete event.\"\"\"\n    for plugin in self._plugins:\n        try:\n            plugin.on_agent_run_complete(agent, response)\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.emit_response_generated","title":"<code>emit_response_generated(response)</code>","text":"<p>Emit response generated event, allowing modification.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def emit_response_generated(self, response: \"AgentResponse\") -&gt; \"AgentResponse\":\n    \"\"\"Emit response generated event, allowing modification.\"\"\"\n    for plugin in self._plugins:\n        try:\n            response = plugin.on_response_generated(response)\n        except Exception:\n            pass\n    return response\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.PluginRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered plugins.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered plugins.\"\"\"\n    self._plugins.clear()\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.LoggingPlugin","title":"<code>LoggingPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Simple logging plugin for debugging.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class LoggingPlugin(BasePlugin):\n    \"\"\"Simple logging plugin for debugging.\"\"\"\n\n    name = \"logging_plugin\"\n    version = \"1.0.0\"\n    description = \"Logs agent and tool events for debugging\"\n\n    def get_info(self) -&gt; PluginInfo:\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description,\n            provides_tools=[],\n            capabilities=[PluginCapability.ENHANCEMENT.value]\n        )\n\n    def on_agent_created(self, agent: \"Agent\") -&gt; None:\n        \"\"\"Log agent creation.\"\"\"\n        print(f\"[LoggingPlugin] Agent created: {agent.name} (ID: {agent.id})\")\n\n    def on_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n        \"\"\"Log agent run start.\"\"\"\n        print(f\"[LoggingPlugin] Agent {agent.name} starting with prompt: {prompt[:50]}...\")\n\n    def on_tool_execution_start(self, tool_name: str, arguments: Dict[str, Any]) -&gt; None:\n        \"\"\"Log tool execution.\"\"\"\n        print(f\"[LoggingPlugin] Executing tool {tool_name} with args: {arguments}\")\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.LoggingPlugin.on_agent_created","title":"<code>on_agent_created(agent)</code>","text":"<p>Log agent creation.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_created(self, agent: \"Agent\") -&gt; None:\n    \"\"\"Log agent creation.\"\"\"\n    print(f\"[LoggingPlugin] Agent created: {agent.name} (ID: {agent.id})\")\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.LoggingPlugin.on_agent_run_start","title":"<code>on_agent_run_start(agent, prompt, context)</code>","text":"<p>Log agent run start.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_run_start(self, agent: \"Agent\", prompt: str, context: Optional[Dict[str, Any]]) -&gt; None:\n    \"\"\"Log agent run start.\"\"\"\n    print(f\"[LoggingPlugin] Agent {agent.name} starting with prompt: {prompt[:50]}...\")\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.LoggingPlugin.on_tool_execution_start","title":"<code>on_tool_execution_start(tool_name, arguments)</code>","text":"<p>Log tool execution.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_execution_start(self, tool_name: str, arguments: Dict[str, Any]) -&gt; None:\n    \"\"\"Log tool execution.\"\"\"\n    print(f\"[LoggingPlugin] Executing tool {tool_name} with args: {arguments}\")\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin","title":"<code>MetricsPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Plugin for collecting metrics about agent usage.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>class MetricsPlugin(BasePlugin):\n    \"\"\"Plugin for collecting metrics about agent usage.\"\"\"\n\n    name = \"metrics_plugin\"\n    version = \"1.0.0\"\n    description = \"Collects metrics about agent and tool usage\"\n\n    def __init__(self, config: Optional[PluginConfig] = None):\n        \"\"\"Initialize metrics plugin.\"\"\"\n        super().__init__(config)\n        self.metrics = {\n            \"agent_runs\": 0,\n            \"tool_executions\": 0,\n            \"errors\": 0,\n            \"total_response_length\": 0\n        }\n\n    def get_info(self) -&gt; PluginInfo:\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description,\n            capabilities=[PluginCapability.ENHANCEMENT.value]\n        )\n\n    def on_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n        \"\"\"Track agent runs.\"\"\"\n        self.metrics[\"agent_runs\"] += 1\n        self.metrics[\"total_response_length\"] += len(response.content)\n\n    def on_tool_execution_complete(self, tool_name: str, result: Any) -&gt; None:\n        \"\"\"Track tool executions.\"\"\"\n        self.metrics[\"tool_executions\"] += 1\n\n    def on_agent_error(self, agent: \"Agent\", error: Exception) -&gt; None:\n        \"\"\"Track errors.\"\"\"\n        self.metrics[\"errors\"] += 1\n\n    def get_metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Get collected metrics.\"\"\"\n        return self.metrics.copy()\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize metrics plugin.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def __init__(self, config: Optional[PluginConfig] = None):\n    \"\"\"Initialize metrics plugin.\"\"\"\n    super().__init__(config)\n    self.metrics = {\n        \"agent_runs\": 0,\n        \"tool_executions\": 0,\n        \"errors\": 0,\n        \"total_response_length\": 0\n    }\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin.on_agent_run_complete","title":"<code>on_agent_run_complete(agent, response)</code>","text":"<p>Track agent runs.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_run_complete(self, agent: \"Agent\", response: \"AgentResponse\") -&gt; None:\n    \"\"\"Track agent runs.\"\"\"\n    self.metrics[\"agent_runs\"] += 1\n    self.metrics[\"total_response_length\"] += len(response.content)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin.on_tool_execution_complete","title":"<code>on_tool_execution_complete(tool_name, result)</code>","text":"<p>Track tool executions.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_tool_execution_complete(self, tool_name: str, result: Any) -&gt; None:\n    \"\"\"Track tool executions.\"\"\"\n    self.metrics[\"tool_executions\"] += 1\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin.on_agent_error","title":"<code>on_agent_error(agent, error)</code>","text":"<p>Track errors.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def on_agent_error(self, agent: \"Agent\", error: Exception) -&gt; None:\n    \"\"\"Track errors.\"\"\"\n    self.metrics[\"errors\"] += 1\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.MetricsPlugin.get_metrics","title":"<code>get_metrics()</code>","text":"<p>Get collected metrics.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Get collected metrics.\"\"\"\n    return self.metrics.copy()\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.register_plugin","title":"<code>register_plugin(plugin)</code>","text":"<p>Register a plugin globally.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin to register</p> required Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def register_plugin(plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin globally.\n\n    Args:\n        plugin: Plugin to register\n    \"\"\"\n    _global_registry.register(plugin)\n</code></pre>"},{"location":"reference/core/plugin/#agenticraft.core.plugin.get_global_registry","title":"<code>get_global_registry()</code>","text":"<p>Get the global plugin registry.</p> Source code in <code>agenticraft/core/plugin.py</code> <pre><code>def get_global_registry() -&gt; PluginRegistry:\n    \"\"\"Get the global plugin registry.\"\"\"\n    return _global_registry\n</code></pre>"},{"location":"reference/core/provider/","title":"Provider","text":""},{"location":"reference/core/provider/#agenticraft.core.provider","title":"<code>provider</code>","text":"<p>LLM provider interfaces for AgentiCraft.</p> <p>This module provides the base classes and factory for integrating various LLM providers (OpenAI, Anthropic, Google, etc.) with AgentiCraft.</p> Example <p>Using different providers::</p> <pre><code>from agenticraft import Agent\n\n# OpenAI (default)\nagent = Agent(model=\"gpt-4\")\n\n# Anthropic\nagent = Agent(model=\"claude-3-opus\", api_key=\"...\")\n\n# Local Ollama\nagent = Agent(model=\"ollama/llama2\", base_url=\"http://localhost:11434\")\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.BaseProvider","title":"<code>BaseProvider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM providers.</p> Source code in <code>agenticraft/core/provider.py</code> <pre><code>class BaseProvider(ABC):\n    \"\"\"Base class for LLM providers.\"\"\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        timeout: int = 30,\n        max_retries: int = 3\n    ):\n        \"\"\"Initialize provider.\n\n        Args:\n            api_key: API key for authentication\n            base_url: Optional base URL override\n            timeout: Request timeout in seconds\n            max_retries: Maximum retry attempts\n        \"\"\"\n        self.api_key = api_key\n        self.base_url = base_url\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n    @abstractmethod\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from the LLM.\n\n        Args:\n            messages: Conversation messages\n            model: Optional model override\n            tools: Available tools\n            tool_choice: Tool choice strategy\n            temperature: Sampling temperature\n            max_tokens: Maximum tokens to generate\n            **kwargs: Provider-specific arguments\n\n        Returns:\n            CompletionResponse with generated content\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate authentication credentials.\n\n        Raises:\n            ProviderAuthError: If authentication fails\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.BaseProvider.__init__","title":"<code>__init__(api_key=None, base_url=None, timeout=30, max_retries=3)</code>","text":"<p>Initialize provider.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>Optional[str]</code> <p>API key for authentication</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL override</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Request timeout in seconds</p> <code>30</code> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts</p> <code>3</code> Source code in <code>agenticraft/core/provider.py</code> <pre><code>def __init__(\n    self,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    timeout: int = 30,\n    max_retries: int = 3\n):\n    \"\"\"Initialize provider.\n\n    Args:\n        api_key: API key for authentication\n        base_url: Optional base URL override\n        timeout: Request timeout in seconds\n        max_retries: Maximum retry attempts\n    \"\"\"\n    self.api_key = api_key\n    self.base_url = base_url\n    self.timeout = timeout\n    self.max_retries = max_retries\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.BaseProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get completion from the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[List[Message], List[Dict[str, Any]]]</code> <p>Conversation messages</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override</p> <code>None</code> <code>tools</code> <code>Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]]</code> <p>Available tools</p> <code>None</code> <code>tool_choice</code> <code>Optional[Any]</code> <p>Tool choice strategy</p> <code>None</code> <code>temperature</code> <code>float</code> <p>Sampling temperature</p> <code>0.7</code> <code>max_tokens</code> <code>Optional[int]</code> <p>Maximum tokens to generate</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Provider-specific arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletionResponse</code> <p>CompletionResponse with generated content</p> Source code in <code>agenticraft/core/provider.py</code> <pre><code>@abstractmethod\nasync def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from the LLM.\n\n    Args:\n        messages: Conversation messages\n        model: Optional model override\n        tools: Available tools\n        tool_choice: Tool choice strategy\n        temperature: Sampling temperature\n        max_tokens: Maximum tokens to generate\n        **kwargs: Provider-specific arguments\n\n    Returns:\n        CompletionResponse with generated content\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.BaseProvider.validate_auth","title":"<code>validate_auth()</code>  <code>abstractmethod</code>","text":"<p>Validate authentication credentials.</p> <p>Raises:</p> Type Description <code>ProviderAuthError</code> <p>If authentication fails</p> Source code in <code>agenticraft/core/provider.py</code> <pre><code>@abstractmethod\ndef validate_auth(self) -&gt; None:\n    \"\"\"Validate authentication credentials.\n\n    Raises:\n        ProviderAuthError: If authentication fails\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.ProviderFactory","title":"<code>ProviderFactory</code>","text":"<p>Factory for creating LLM providers.</p> Source code in <code>agenticraft/core/provider.py</code> <pre><code>class ProviderFactory:\n    \"\"\"Factory for creating LLM providers.\"\"\"\n\n    _providers: Dict[str, Type[BaseProvider]] = {}\n\n    @classmethod\n    def _lazy_load_providers(cls) -&gt; None:\n        \"\"\"Lazily load provider implementations.\"\"\"\n        if not cls._providers:\n            from ..providers.openai import OpenAIProvider\n            from ..providers.anthropic import AnthropicProvider\n            from ..providers.ollama import OllamaProvider\n\n            cls._providers = {\n                \"openai\": OpenAIProvider,\n                \"anthropic\": AnthropicProvider,\n                \"ollama\": OllamaProvider,\n            }\n\n    @classmethod\n    def create(\n        cls,\n        model: str,\n        provider: Optional[str] = None,\n        api_key: Optional[str] = None,\n        base_url: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; BaseProvider:\n        \"\"\"Create a provider based on model name.\n\n        Args:\n            model: Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"ollama/llama2\")\n            provider: Optional explicit provider name (overrides auto-detection)\n            api_key: Optional API key\n            base_url: Optional base URL\n            **kwargs: Additional provider arguments\n\n        Returns:\n            Provider instance\n\n        Raises:\n            ProviderNotFoundError: If no provider found for model\n        \"\"\"\n        # If explicit provider specified, use it\n        if provider:\n            # Ensure providers are loaded\n            cls._lazy_load_providers()\n\n            provider_class = cls._providers.get(provider)\n            if not provider_class:\n                raise ProviderNotFoundError(f\"Unknown provider: {provider}\")\n\n            return provider_class(\n                api_key=api_key,\n                base_url=base_url,\n                model=model,\n                **kwargs\n            )\n\n        # Otherwise, Common Ollama model prefixes\n        ollama_models = (\n            \"llama\", \"llama2\", \"llama3\", \"codellama\", \"mistral\", \"mixtral\",\n            \"gemma\", \"phi\", \"vicuna\", \"orca\", \"neural-chat\", \"starling\",\n            \"deepseek\", \"qwen\", \"dolphin\", \"yi\", \"solar\", \"command-r\"\n        )\n\n        # Handle explicit provider:model format first\n        if \":\" in model and not model.startswith(\"ollama/\"):\n            parts = model.split(\":\", 1)\n            # Check if it's an Ollama model with version tag first\n            if any(parts[0].startswith(ollama) for ollama in ollama_models):\n                provider_name = \"ollama\"\n            else:\n                # Ensure providers are loaded before checking\n                cls._lazy_load_providers()\n                if parts[0] in cls._providers:\n                    provider_name = parts[0]\n                    model = parts[1]\n                else:\n                    # If using provider:model format, provider must be known\n                    raise ProviderNotFoundError(f\"Unknown provider: {parts[0]}\")\n        # Determine provider from model name\n        elif model.startswith((\"gpt-\", \"o1-\", \"davinci\", \"curie\", \"babbage\", \"ada\")):\n            provider_name = \"openai\"\n        elif model.startswith(\"claude\"):\n            provider_name = \"anthropic\" \n        elif model.startswith(\"gemini\"):\n            provider_name = \"google\"\n        elif model.startswith(\"ollama/\"):\n            provider_name = \"ollama\"\n        # Check if it's a known Ollama model\n        elif any(model.startswith(ollama) for ollama in ollama_models):\n            provider_name = \"ollama\"\n        else:\n            # Unknown model\n            raise ProviderNotFoundError(f\"No provider found for model: {model}\")\n\n        # Ensure providers are loaded (may have been called above already)\n        if not cls._providers:\n            cls._lazy_load_providers()\n\n        # Get provider class\n        provider_class = cls._providers.get(provider_name)\n        if not provider_class:\n            raise ProviderNotFoundError(f\"Unknown provider: {provider_name}\")\n\n        # Create instance\n        return provider_class(\n            api_key=api_key,\n            base_url=base_url,\n            model=model,\n            **kwargs\n        )\n\n    @classmethod\n    def register(cls, name: str, provider_class: Type[BaseProvider]) -&gt; None:\n        \"\"\"Register a custom provider.\n\n        Args:\n            name: Provider name\n            provider_class: Provider class\n        \"\"\"\n        cls._providers[name] = provider_class\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.ProviderFactory.create","title":"<code>create(model, provider=None, api_key=None, base_url=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a provider based on model name.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"ollama/llama2\")</p> required <code>provider</code> <code>Optional[str]</code> <p>Optional explicit provider name (overrides auto-detection)</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Optional API key</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Optional base URL</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>BaseProvider</code> <p>Provider instance</p> <p>Raises:</p> Type Description <code>ProviderNotFoundError</code> <p>If no provider found for model</p> Source code in <code>agenticraft/core/provider.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    model: str,\n    provider: Optional[str] = None,\n    api_key: Optional[str] = None,\n    base_url: Optional[str] = None,\n    **kwargs: Any\n) -&gt; BaseProvider:\n    \"\"\"Create a provider based on model name.\n\n    Args:\n        model: Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"ollama/llama2\")\n        provider: Optional explicit provider name (overrides auto-detection)\n        api_key: Optional API key\n        base_url: Optional base URL\n        **kwargs: Additional provider arguments\n\n    Returns:\n        Provider instance\n\n    Raises:\n        ProviderNotFoundError: If no provider found for model\n    \"\"\"\n    # If explicit provider specified, use it\n    if provider:\n        # Ensure providers are loaded\n        cls._lazy_load_providers()\n\n        provider_class = cls._providers.get(provider)\n        if not provider_class:\n            raise ProviderNotFoundError(f\"Unknown provider: {provider}\")\n\n        return provider_class(\n            api_key=api_key,\n            base_url=base_url,\n            model=model,\n            **kwargs\n        )\n\n    # Otherwise, Common Ollama model prefixes\n    ollama_models = (\n        \"llama\", \"llama2\", \"llama3\", \"codellama\", \"mistral\", \"mixtral\",\n        \"gemma\", \"phi\", \"vicuna\", \"orca\", \"neural-chat\", \"starling\",\n        \"deepseek\", \"qwen\", \"dolphin\", \"yi\", \"solar\", \"command-r\"\n    )\n\n    # Handle explicit provider:model format first\n    if \":\" in model and not model.startswith(\"ollama/\"):\n        parts = model.split(\":\", 1)\n        # Check if it's an Ollama model with version tag first\n        if any(parts[0].startswith(ollama) for ollama in ollama_models):\n            provider_name = \"ollama\"\n        else:\n            # Ensure providers are loaded before checking\n            cls._lazy_load_providers()\n            if parts[0] in cls._providers:\n                provider_name = parts[0]\n                model = parts[1]\n            else:\n                # If using provider:model format, provider must be known\n                raise ProviderNotFoundError(f\"Unknown provider: {parts[0]}\")\n    # Determine provider from model name\n    elif model.startswith((\"gpt-\", \"o1-\", \"davinci\", \"curie\", \"babbage\", \"ada\")):\n        provider_name = \"openai\"\n    elif model.startswith(\"claude\"):\n        provider_name = \"anthropic\" \n    elif model.startswith(\"gemini\"):\n        provider_name = \"google\"\n    elif model.startswith(\"ollama/\"):\n        provider_name = \"ollama\"\n    # Check if it's a known Ollama model\n    elif any(model.startswith(ollama) for ollama in ollama_models):\n        provider_name = \"ollama\"\n    else:\n        # Unknown model\n        raise ProviderNotFoundError(f\"No provider found for model: {model}\")\n\n    # Ensure providers are loaded (may have been called above already)\n    if not cls._providers:\n        cls._lazy_load_providers()\n\n    # Get provider class\n    provider_class = cls._providers.get(provider_name)\n    if not provider_class:\n        raise ProviderNotFoundError(f\"Unknown provider: {provider_name}\")\n\n    # Create instance\n    return provider_class(\n        api_key=api_key,\n        base_url=base_url,\n        model=model,\n        **kwargs\n    )\n</code></pre>"},{"location":"reference/core/provider/#agenticraft.core.provider.ProviderFactory.register","title":"<code>register(name, provider_class)</code>  <code>classmethod</code>","text":"<p>Register a custom provider.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Provider name</p> required <code>provider_class</code> <code>Type[BaseProvider]</code> <p>Provider class</p> required Source code in <code>agenticraft/core/provider.py</code> <pre><code>@classmethod\ndef register(cls, name: str, provider_class: Type[BaseProvider]) -&gt; None:\n    \"\"\"Register a custom provider.\n\n    Args:\n        name: Provider name\n        provider_class: Provider class\n    \"\"\"\n    cls._providers[name] = provider_class\n</code></pre>"},{"location":"reference/core/reasoning/","title":"Reasoning","text":""},{"location":"reference/core/reasoning/#agenticraft.core.reasoning","title":"<code>reasoning</code>","text":"<p>Reasoning patterns for AgentiCraft agents.</p> <p>This module provides various reasoning patterns that agents can use to structure their thinking process. Each pattern provides a different approach to problem-solving and decision-making.</p> Example <p>Using reasoning patterns::</p> <pre><code>from agenticraft import Agent, ChainOfThought\n\nagent = Agent(\n    name=\"Reasoner\",\n    reasoning_pattern=ChainOfThought()\n)\n\nresponse = agent.run(\"Solve this complex problem...\")\nprint(response.reasoning)  # See the chain of thought\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningStep","title":"<code>ReasoningStep</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single step in the reasoning process.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class ReasoningStep(BaseModel):\n    \"\"\"A single step in the reasoning process.\"\"\"\n\n    step_type: str\n    description: str\n    data: Dict[str, Any] = Field(default_factory=dict)\n    timestamp: datetime = Field(default_factory=datetime.now)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert step to dictionary.\"\"\"\n        return {\n            \"type\": self.step_type,\n            \"description\": self.description,\n            \"data\": self.data,\n            \"timestamp\": self.timestamp.isoformat()\n        }\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningStep.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert step to dictionary.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert step to dictionary.\"\"\"\n    return {\n        \"type\": self.step_type,\n        \"description\": self.description,\n        \"data\": self.data,\n        \"timestamp\": self.timestamp.isoformat()\n    }\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace","title":"<code>ReasoningTrace</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A trace of the reasoning process.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class ReasoningTrace(BaseModel):\n    \"\"\"A trace of the reasoning process.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    prompt: str\n    steps: List[ReasoningStep] = Field(default_factory=list)\n    started_at: datetime = Field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    result: Optional[Dict[str, Any]] = None\n\n    def __init__(self, query: Optional[str] = None, prompt: Optional[str] = None, **data: Any):\n        \"\"\"Initialize reasoning trace with query or prompt.\"\"\"\n        # Handle both query and prompt parameters\n        if query is not None:\n            prompt = query\n        elif prompt is None:\n            prompt = \"\"\n        super().__init__(prompt=prompt, **data)\n\n    # Add alias for prompt -&gt; query\n    @property\n    def query(self) -&gt; str:\n        \"\"\"Alias for prompt to match test expectations.\"\"\"\n        return self.prompt\n\n    @property\n    def duration(self) -&gt; float:\n        \"\"\"Calculate duration in seconds.\"\"\"\n        if not self.completed_at:\n            return 0.0\n        return (self.completed_at - self.started_at).total_seconds()\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert trace to dictionary.\"\"\"\n        return {\n            \"query\": self.prompt,\n            \"steps\": [step.to_dict() for step in self.steps],\n            \"result\": self.result,\n            \"duration\": self.duration,\n            \"started_at\": self.started_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n    def add_step(self, step_type: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"Add a step to the reasoning trace.\"\"\"\n        step = ReasoningStep(\n            step_type=step_type,\n            description=self._describe_step(step_type, data),\n            data=data\n        )\n        self.steps.append(step)\n\n    def _describe_step(self, step_type: str, data: Dict[str, Any]) -&gt; str:\n        \"\"\"Generate a human-readable description of a step.\"\"\"\n        descriptions = {\n            \"analyzing_prompt\": \"Analyzing the user's request\",\n            \"calling_llm\": f\"Calling {data.get('model', 'LLM')}\",\n            \"executing_tool\": f\"Executing tool: {data.get('tool', 'unknown')}\",\n            \"tool_result\": f\"Received result from {data.get('tool', 'tool')}\",\n            \"tool_error\": f\"Tool {data.get('tool', 'unknown')} failed\",\n            \"formulating_response\": \"Formulating the response\"\n        }\n        return descriptions.get(step_type, f\"Processing: {step_type}\")\n\n    def complete(self, result: Dict[str, Any]) -&gt; None:\n        \"\"\"Mark the trace as complete.\"\"\"\n        self.completed_at = datetime.now()\n        self.result = result\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.query","title":"<code>query</code>  <code>property</code>","text":"<p>Alias for prompt to match test expectations.</p>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Calculate duration in seconds.</p>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.__init__","title":"<code>__init__(query=None, prompt=None, **data)</code>","text":"<p>Initialize reasoning trace with query or prompt.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def __init__(self, query: Optional[str] = None, prompt: Optional[str] = None, **data: Any):\n    \"\"\"Initialize reasoning trace with query or prompt.\"\"\"\n    # Handle both query and prompt parameters\n    if query is not None:\n        prompt = query\n    elif prompt is None:\n        prompt = \"\"\n    super().__init__(prompt=prompt, **data)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert trace to dictionary.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert trace to dictionary.\"\"\"\n    return {\n        \"query\": self.prompt,\n        \"steps\": [step.to_dict() for step in self.steps],\n        \"result\": self.result,\n        \"duration\": self.duration,\n        \"started_at\": self.started_at.isoformat(),\n        \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n    }\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.add_step","title":"<code>add_step(step_type, data)</code>","text":"<p>Add a step to the reasoning trace.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def add_step(self, step_type: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"Add a step to the reasoning trace.\"\"\"\n    step = ReasoningStep(\n        step_type=step_type,\n        description=self._describe_step(step_type, data),\n        data=data\n    )\n    self.steps.append(step)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReasoningTrace.complete","title":"<code>complete(result)</code>","text":"<p>Mark the trace as complete.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def complete(self, result: Dict[str, Any]) -&gt; None:\n    \"\"\"Mark the trace as complete.\"\"\"\n    self.completed_at = datetime.now()\n    self.result = result\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.BaseReasoning","title":"<code>BaseReasoning</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for reasoning patterns.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class BaseReasoning(ABC):\n    \"\"\"Base class for reasoning patterns.\"\"\"\n\n    def __init__(self, name: str = \"base\", description: str = \"Base reasoning pattern\"):\n        \"\"\"Initialize base reasoning.\"\"\"\n        self.name = name\n        self.description = description\n\n    @abstractmethod\n    def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n        \"\"\"Start a new reasoning trace.\"\"\"\n        pass\n\n    @abstractmethod\n    def format_trace(self, trace: ReasoningTrace) -&gt; str:\n        \"\"\"Format a trace for human consumption.\"\"\"\n        pass\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.BaseReasoning.__init__","title":"<code>__init__(name='base', description='Base reasoning pattern')</code>","text":"<p>Initialize base reasoning.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def __init__(self, name: str = \"base\", description: str = \"Base reasoning pattern\"):\n    \"\"\"Initialize base reasoning.\"\"\"\n    self.name = name\n    self.description = description\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.BaseReasoning.start_trace","title":"<code>start_trace(prompt)</code>  <code>abstractmethod</code>","text":"<p>Start a new reasoning trace.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>@abstractmethod\ndef start_trace(self, prompt: str) -&gt; ReasoningTrace:\n    \"\"\"Start a new reasoning trace.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.BaseReasoning.format_trace","title":"<code>format_trace(trace)</code>  <code>abstractmethod</code>","text":"<p>Format a trace for human consumption.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>@abstractmethod\ndef format_trace(self, trace: ReasoningTrace) -&gt; str:\n    \"\"\"Format a trace for human consumption.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.SimpleReasoning","title":"<code>SimpleReasoning</code>","text":"<p>               Bases: <code>BaseReasoning</code></p> <p>Simple reasoning that just tracks steps.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class SimpleReasoning(BaseReasoning):\n    \"\"\"Simple reasoning that just tracks steps.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize simple reasoning.\"\"\"\n        super().__init__(\n            name=\"simple\",\n            description=\"Basic step-by-step reasoning\"\n        )\n\n    def analyze_problem(self, problem: str) -&gt; Dict[str, Any]:\n        \"\"\"Analyze a problem and return analysis.\"\"\"\n        return {\n            \"type\": \"general\" if \"?\" in problem else \"statement\",\n            \"complexity\": \"low\" if len(problem.split()) &lt; 10 else \"medium\",\n            \"approach\": \"direct\"\n        }\n\n    def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n        \"\"\"Start a new reasoning trace.\"\"\"\n        trace = ReasoningTrace(prompt=prompt)\n        trace.add_step(\"analyzing_prompt\", {\"prompt\": prompt})\n        return trace\n\n    def format_trace(self, trace: ReasoningTrace) -&gt; str:\n        \"\"\"Format trace as a simple list of steps.\"\"\"\n        if not trace.steps:\n            return \"No reasoning steps recorded.\"\n\n        # Include pattern name in output for tests\n        lines = [f\"[{self.name}] Reasoning process for: {trace.prompt}\"]\n        for i, step in enumerate(trace.steps, 1):\n            lines.append(f\"{i}. {step.description} ({step.step_type})\")\n\n        if trace.result:\n            # Include all result keys in output\n            result_parts = []\n            for key, value in trace.result.items():\n                result_parts.append(f\"{key}: {value}\")\n            lines.append(f\"\\nResult: {', '.join(result_parts)}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.SimpleReasoning.__init__","title":"<code>__init__()</code>","text":"<p>Initialize simple reasoning.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize simple reasoning.\"\"\"\n    super().__init__(\n        name=\"simple\",\n        description=\"Basic step-by-step reasoning\"\n    )\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.SimpleReasoning.analyze_problem","title":"<code>analyze_problem(problem)</code>","text":"<p>Analyze a problem and return analysis.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def analyze_problem(self, problem: str) -&gt; Dict[str, Any]:\n    \"\"\"Analyze a problem and return analysis.\"\"\"\n    return {\n        \"type\": \"general\" if \"?\" in problem else \"statement\",\n        \"complexity\": \"low\" if len(problem.split()) &lt; 10 else \"medium\",\n        \"approach\": \"direct\"\n    }\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.SimpleReasoning.start_trace","title":"<code>start_trace(prompt)</code>","text":"<p>Start a new reasoning trace.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n    \"\"\"Start a new reasoning trace.\"\"\"\n    trace = ReasoningTrace(prompt=prompt)\n    trace.add_step(\"analyzing_prompt\", {\"prompt\": prompt})\n    return trace\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.SimpleReasoning.format_trace","title":"<code>format_trace(trace)</code>","text":"<p>Format trace as a simple list of steps.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def format_trace(self, trace: ReasoningTrace) -&gt; str:\n    \"\"\"Format trace as a simple list of steps.\"\"\"\n    if not trace.steps:\n        return \"No reasoning steps recorded.\"\n\n    # Include pattern name in output for tests\n    lines = [f\"[{self.name}] Reasoning process for: {trace.prompt}\"]\n    for i, step in enumerate(trace.steps, 1):\n        lines.append(f\"{i}. {step.description} ({step.step_type})\")\n\n    if trace.result:\n        # Include all result keys in output\n        result_parts = []\n        for key, value in trace.result.items():\n            result_parts.append(f\"{key}: {value}\")\n        lines.append(f\"\\nResult: {', '.join(result_parts)}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ChainOfThought","title":"<code>ChainOfThought</code>","text":"<p>               Bases: <code>BaseReasoning</code></p> <p>Chain of Thought reasoning pattern.</p> <p>This pattern encourages the agent to think step-by-step through a problem, making its reasoning process transparent and logical.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class ChainOfThought(BaseReasoning):\n    \"\"\"Chain of Thought reasoning pattern.\n\n    This pattern encourages the agent to think step-by-step through\n    a problem, making its reasoning process transparent and logical.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize chain of thought reasoning.\"\"\"\n        super().__init__(\n            name=\"chain_of_thought\",\n            description=\"Step-by-step reasoning with clear thought progression\"\n        )\n\n    def break_down_problem(self, problem: str) -&gt; List[str]:\n        \"\"\"Break down a complex problem into steps.\"\"\"\n        steps = []\n\n        # Simple heuristic breakdown\n        if \"calculate\" in problem.lower() or \"total\" in problem.lower():\n            steps.append(\"Identify the numbers and quantities involved\")\n            if \"each\" in problem.lower():\n                steps.append(\"Multiply quantity by unit price\")\n            if \"tax\" in problem.lower():\n                steps.append(\"Calculate the tax amount\")\n                steps.append(\"Add tax to the subtotal\")\n            steps.append(\"Compute the final result\")\n        else:\n            steps.append(\"Understand the core question\")\n            steps.append(\"Identify key components\")\n            steps.append(\"Analyze relationships\")\n            steps.append(\"Formulate response\")\n\n        return steps\n\n    def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n        \"\"\"Start a new reasoning trace.\"\"\"\n        trace = ReasoningTrace(prompt=prompt)\n        trace.add_step(\"problem_analysis\", {\n            \"prompt\": prompt,\n            \"approach\": \"chain_of_thought\"\n        })\n\n        # Add breakdown step\n        breakdown = self.break_down_problem(prompt)\n        trace.add_step(\"breakdown\", {\n            \"steps\": breakdown,\n            \"count\": len(breakdown)\n        })\n\n        return trace\n\n    def format_trace(self, trace: ReasoningTrace) -&gt; str:\n        \"\"\"Format trace as a chain of thought.\"\"\"\n        if not trace.steps:\n            return \"No reasoning steps recorded.\"\n\n        lines = [f\"[{self.name}] Chain of Thought:\"]\n        lines.append(f\"\\nQuestion: {trace.prompt}\")\n        lines.append(\"\\nThinking process:\")\n\n        # Count non-metadata steps for numbering\n        step_count = 0\n        for step in trace.steps:\n            if step.step_type not in [\"problem_analysis\", \"breakdown\"]:\n                step_count += 1\n                lines.append(f\"{step_count}. {step.description}\")\n                # Include key data from the step\n                if step.data:\n                    for key, value in step.data.items():\n                        if isinstance(value, (str, int, float)):\n                            lines.append(f\"   - {key}: {value}\")\n                        elif isinstance(value, dict):\n                            lines.append(f\"   - {key}: {value}\")\n                        elif isinstance(value, list) and len(value) &gt; 0:\n                            lines.append(f\"   - {key}: {', '.join(str(v) for v in value)}\")\n            elif step.step_type == \"problem_analysis\":\n                lines.append(\"- First, I need to understand what's being asked...\")\n            elif step.step_type == \"breakdown\":\n                lines.append(\"- Breaking down the problem into steps:\")\n                for i, breakdown_step in enumerate(step.data.get(\"steps\", []), 1):\n                    lines.append(f\"  Step {i}: {breakdown_step}\")\n\n        if trace.result:\n            lines.append(f\"\\nConclusion:\")\n            for key, value in trace.result.items():\n                if isinstance(value, list):\n                    lines.append(f\"- {key}: {', '.join(str(v) for v in value)}\")\n                else:\n                    lines.append(f\"- {key}: {value}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ChainOfThought.__init__","title":"<code>__init__()</code>","text":"<p>Initialize chain of thought reasoning.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize chain of thought reasoning.\"\"\"\n    super().__init__(\n        name=\"chain_of_thought\",\n        description=\"Step-by-step reasoning with clear thought progression\"\n    )\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ChainOfThought.break_down_problem","title":"<code>break_down_problem(problem)</code>","text":"<p>Break down a complex problem into steps.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def break_down_problem(self, problem: str) -&gt; List[str]:\n    \"\"\"Break down a complex problem into steps.\"\"\"\n    steps = []\n\n    # Simple heuristic breakdown\n    if \"calculate\" in problem.lower() or \"total\" in problem.lower():\n        steps.append(\"Identify the numbers and quantities involved\")\n        if \"each\" in problem.lower():\n            steps.append(\"Multiply quantity by unit price\")\n        if \"tax\" in problem.lower():\n            steps.append(\"Calculate the tax amount\")\n            steps.append(\"Add tax to the subtotal\")\n        steps.append(\"Compute the final result\")\n    else:\n        steps.append(\"Understand the core question\")\n        steps.append(\"Identify key components\")\n        steps.append(\"Analyze relationships\")\n        steps.append(\"Formulate response\")\n\n    return steps\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ChainOfThought.start_trace","title":"<code>start_trace(prompt)</code>","text":"<p>Start a new reasoning trace.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n    \"\"\"Start a new reasoning trace.\"\"\"\n    trace = ReasoningTrace(prompt=prompt)\n    trace.add_step(\"problem_analysis\", {\n        \"prompt\": prompt,\n        \"approach\": \"chain_of_thought\"\n    })\n\n    # Add breakdown step\n    breakdown = self.break_down_problem(prompt)\n    trace.add_step(\"breakdown\", {\n        \"steps\": breakdown,\n        \"count\": len(breakdown)\n    })\n\n    return trace\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ChainOfThought.format_trace","title":"<code>format_trace(trace)</code>","text":"<p>Format trace as a chain of thought.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def format_trace(self, trace: ReasoningTrace) -&gt; str:\n    \"\"\"Format trace as a chain of thought.\"\"\"\n    if not trace.steps:\n        return \"No reasoning steps recorded.\"\n\n    lines = [f\"[{self.name}] Chain of Thought:\"]\n    lines.append(f\"\\nQuestion: {trace.prompt}\")\n    lines.append(\"\\nThinking process:\")\n\n    # Count non-metadata steps for numbering\n    step_count = 0\n    for step in trace.steps:\n        if step.step_type not in [\"problem_analysis\", \"breakdown\"]:\n            step_count += 1\n            lines.append(f\"{step_count}. {step.description}\")\n            # Include key data from the step\n            if step.data:\n                for key, value in step.data.items():\n                    if isinstance(value, (str, int, float)):\n                        lines.append(f\"   - {key}: {value}\")\n                    elif isinstance(value, dict):\n                        lines.append(f\"   - {key}: {value}\")\n                    elif isinstance(value, list) and len(value) &gt; 0:\n                        lines.append(f\"   - {key}: {', '.join(str(v) for v in value)}\")\n        elif step.step_type == \"problem_analysis\":\n            lines.append(\"- First, I need to understand what's being asked...\")\n        elif step.step_type == \"breakdown\":\n            lines.append(\"- Breaking down the problem into steps:\")\n            for i, breakdown_step in enumerate(step.data.get(\"steps\", []), 1):\n                lines.append(f\"  Step {i}: {breakdown_step}\")\n\n    if trace.result:\n        lines.append(f\"\\nConclusion:\")\n        for key, value in trace.result.items():\n            if isinstance(value, list):\n                lines.append(f\"- {key}: {', '.join(str(v) for v in value)}\")\n            else:\n                lines.append(f\"- {key}: {value}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReflectiveReasoning","title":"<code>ReflectiveReasoning</code>","text":"<p>               Bases: <code>BaseReasoning</code></p> <p>Reflective reasoning that considers multiple perspectives.</p> <p>This pattern encourages the agent to think about a problem from multiple angles and reflect on its own thinking.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>class ReflectiveReasoning(BaseReasoning):\n    \"\"\"Reflective reasoning that considers multiple perspectives.\n\n    This pattern encourages the agent to think about a problem from\n    multiple angles and reflect on its own thinking.\n    \"\"\"\n\n    def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n        \"\"\"Start a new reasoning trace.\"\"\"\n        trace = ReasoningTrace(prompt=prompt)\n        trace.add_step(\"analyzing_prompt\", {\n            \"prompt\": prompt,\n            \"approach\": \"reflective\"\n        })\n        return trace\n\n    def format_trace(self, trace: ReasoningTrace) -&gt; str:\n        \"\"\"Format trace with reflection.\"\"\"\n        if not trace.steps:\n            return \"No reasoning steps recorded.\"\n\n        lines = [\"Reflective Analysis:\"]\n        lines.append(f\"\\nConsidering: {trace.prompt}\")\n        lines.append(\"\\nPerspectives explored:\")\n\n        perspectives = []\n        for step in trace.steps:\n            if step.step_type == \"executing_tool\":\n                perspectives.append(f\"- Data perspective from {step.data.get('tool')}\")\n            elif step.step_type == \"calling_llm\":\n                perspectives.append(\"- Analytical perspective\")\n\n        lines.extend(perspectives or [\"- Direct analysis\"])\n\n        if trace.result:\n            lines.append(f\"\\nSynthesis: {trace.result.get('response', 'No response')}\")\n\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReflectiveReasoning.start_trace","title":"<code>start_trace(prompt)</code>","text":"<p>Start a new reasoning trace.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def start_trace(self, prompt: str) -&gt; ReasoningTrace:\n    \"\"\"Start a new reasoning trace.\"\"\"\n    trace = ReasoningTrace(prompt=prompt)\n    trace.add_step(\"analyzing_prompt\", {\n        \"prompt\": prompt,\n        \"approach\": \"reflective\"\n    })\n    return trace\n</code></pre>"},{"location":"reference/core/reasoning/#agenticraft.core.reasoning.ReflectiveReasoning.format_trace","title":"<code>format_trace(trace)</code>","text":"<p>Format trace with reflection.</p> Source code in <code>agenticraft/core/reasoning.py</code> <pre><code>def format_trace(self, trace: ReasoningTrace) -&gt; str:\n    \"\"\"Format trace with reflection.\"\"\"\n    if not trace.steps:\n        return \"No reasoning steps recorded.\"\n\n    lines = [\"Reflective Analysis:\"]\n    lines.append(f\"\\nConsidering: {trace.prompt}\")\n    lines.append(\"\\nPerspectives explored:\")\n\n    perspectives = []\n    for step in trace.steps:\n        if step.step_type == \"executing_tool\":\n            perspectives.append(f\"- Data perspective from {step.data.get('tool')}\")\n        elif step.step_type == \"calling_llm\":\n            perspectives.append(\"- Analytical perspective\")\n\n    lines.extend(perspectives or [\"- Direct analysis\"])\n\n    if trace.result:\n        lines.append(f\"\\nSynthesis: {trace.result.get('response', 'No response')}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/telemetry/","title":"Telemetry","text":""},{"location":"reference/core/telemetry/#agenticraft.core.telemetry","title":"<code>telemetry</code>","text":"<p>Telemetry and observability for AgentiCraft.</p> <p>This module provides OpenTelemetry integration for monitoring and observing agent behavior in production environments.</p> Example <p>Enabling telemetry::</p> <pre><code>from agenticraft import Agent, Telemetry\n\ntelemetry = Telemetry(\n    service_name=\"my-agent-app\",\n    export_to=\"http://localhost:4317\"\n)\n\nagent = Agent(\n    name=\"MonitoredAgent\",\n    telemetry=telemetry\n)\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.TelemetryConfig","title":"<code>TelemetryConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for telemetry.</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>class TelemetryConfig(BaseModel):\n    \"\"\"Configuration for telemetry.\"\"\"\n\n    service_name: str = Field(default=\"agenticraft\")\n    service_version: str = Field(default=\"0.1.0\")\n    export_endpoint: Optional[str] = Field(default=None)\n    export_headers: Dict[str, str] = Field(default_factory=dict)\n    enabled: bool = Field(default=True)\n    sample_rate: float = Field(default=1.0, ge=0.0, le=1.0)\n\n    @property\n    def endpoint(self) -&gt; str:\n        \"\"\"Get the export endpoint.\"\"\"\n        return self.export_endpoint or os.getenv(\n            \"OTEL_EXPORTER_OTLP_ENDPOINT\",\n            \"http://localhost:4317\"\n        )\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.TelemetryConfig.endpoint","title":"<code>endpoint</code>  <code>property</code>","text":"<p>Get the export endpoint.</p>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry","title":"<code>Telemetry</code>","text":"<p>Telemetry manager for AgentiCraft.</p> <p>Provides OpenTelemetry integration for distributed tracing and metrics collection.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> <code>'agenticraft'</code> <code>service_version</code> <code>str</code> <p>Version of your service</p> <code>'0.1.0'</code> <code>export_to</code> <code>Optional[str]</code> <p>OTLP endpoint to export telemetry</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether telemetry is enabled</p> <code>True</code> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>class Telemetry:\n    \"\"\"Telemetry manager for AgentiCraft.\n\n    Provides OpenTelemetry integration for distributed tracing\n    and metrics collection.\n\n    Args:\n        service_name: Name of your service\n        service_version: Version of your service\n        export_to: OTLP endpoint to export telemetry\n        enabled: Whether telemetry is enabled\n    \"\"\"\n\n    def __init__(\n        self,\n        service_name: str = \"agenticraft\",\n        service_version: str = \"0.1.0\", \n        export_to: Optional[str] = None,\n        enabled: bool = True\n    ):\n        \"\"\"Initialize telemetry.\"\"\"\n        self.config = TelemetryConfig(\n            service_name=service_name,\n            service_version=service_version,\n            export_endpoint=export_to,\n            enabled=enabled\n        )\n\n        self._tracer: Optional[trace.Tracer] = None\n        self._meter: Optional[metrics.Meter] = None\n\n        if self.config.enabled:\n            self._setup_telemetry()\n\n    def _setup_telemetry(self) -&gt; None:\n        \"\"\"Set up OpenTelemetry providers.\"\"\"\n        # Create resource\n        resource = Resource.create({\n            \"service.name\": self.config.service_name,\n            \"service.version\": self.config.service_version,\n        })\n\n        # Set up tracing\n        trace_provider = TracerProvider(resource=resource)\n\n        if self.config.export_endpoint:\n            span_exporter = OTLPSpanExporter(\n                endpoint=self.config.endpoint,\n                headers=self.config.export_headers\n            )\n            span_processor = BatchSpanProcessor(span_exporter)\n            trace_provider.add_span_processor(span_processor)\n\n        trace.set_tracer_provider(trace_provider)\n        self._tracer = trace.get_tracer(\n            self.config.service_name,\n            self.config.service_version\n        )\n\n        # Set up metrics\n        if self.config.export_endpoint:\n            metric_exporter = OTLPMetricExporter(\n                endpoint=self.config.endpoint,\n                headers=self.config.export_headers\n            )\n            metric_reader = PeriodicExportingMetricReader(\n                exporter=metric_exporter,\n                export_interval_millis=60000  # 1 minute\n            )\n            meter_provider = MeterProvider(\n                resource=resource,\n                metric_readers=[metric_reader]\n            )\n        else:\n            meter_provider = MeterProvider(resource=resource)\n\n        metrics.set_meter_provider(meter_provider)\n        self._meter = metrics.get_meter(\n            self.config.service_name,\n            self.config.service_version\n        )\n\n        # Create common metrics\n        self._setup_metrics()\n\n    def _setup_metrics(self) -&gt; None:\n        \"\"\"Set up common metrics.\"\"\"\n        if not self._meter:\n            return\n\n        # Agent metrics\n        self.agent_runs = self._meter.create_counter(\n            \"agenticraft.agent.runs\",\n            description=\"Number of agent runs\"\n        )\n\n        self.agent_errors = self._meter.create_counter(\n            \"agenticraft.agent.errors\",\n            description=\"Number of agent errors\"\n        )\n\n        self.agent_duration = self._meter.create_histogram(\n            \"agenticraft.agent.duration\",\n            description=\"Agent execution duration in seconds\",\n            unit=\"s\"\n        )\n\n        # Tool metrics\n        self.tool_executions = self._meter.create_counter(\n            \"agenticraft.tool.executions\",\n            description=\"Number of tool executions\"\n        )\n\n        self.tool_errors = self._meter.create_counter(\n            \"agenticraft.tool.errors\",\n            description=\"Number of tool errors\"\n        )\n\n        self.tool_duration = self._meter.create_histogram(\n            \"agenticraft.tool.duration\",\n            description=\"Tool execution duration in seconds\",\n            unit=\"s\"\n        )\n\n        # Token metrics\n        self.tokens_used = self._meter.create_counter(\n            \"agenticraft.tokens.used\",\n            description=\"Number of tokens used\"\n        )\n\n    @property\n    def tracer(self) -&gt; Optional[trace.Tracer]:\n        \"\"\"Get the tracer instance.\"\"\"\n        return self._tracer\n\n    @property\n    def meter(self) -&gt; Optional[metrics.Meter]:\n        \"\"\"Get the meter instance.\"\"\"\n        return self._meter\n\n    @contextmanager\n    def span(self, name: str, attributes: Optional[Dict[str, Any]] = None):\n        \"\"\"Create a traced span.\n\n        Args:\n            name: Span name\n            attributes: Span attributes\n\n        Example:\n            with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):\n                # Do work\n                pass\n        \"\"\"\n        if not self._tracer or not self.config.enabled:\n            yield None\n            return\n\n        with self._tracer.start_as_current_span(name) as span:\n            if attributes:\n                for key, value in attributes.items():\n                    span.set_attribute(key, value)\n            yield span\n\n    def record_agent_run(\n        self,\n        agent_name: str,\n        duration: float,\n        success: bool,\n        tokens: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Record metrics for an agent run.\n\n        Args:\n            agent_name: Name of the agent\n            duration: Execution duration in seconds\n            success: Whether the run was successful\n            tokens: Number of tokens used\n        \"\"\"\n        if not self._meter or not self.config.enabled:\n            return\n\n        attributes = {\"agent.name\": agent_name}\n\n        self.agent_runs.add(1, attributes)\n\n        if not success:\n            self.agent_errors.add(1, attributes)\n\n        self.agent_duration.record(duration, attributes)\n\n        if tokens is not None:\n            self.tokens_used.add(tokens, attributes)\n\n    def record_tool_execution(\n        self,\n        tool_name: str,\n        duration: float,\n        success: bool\n    ) -&gt; None:\n        \"\"\"Record metrics for a tool execution.\n\n        Args:\n            tool_name: Name of the tool\n            duration: Execution duration in seconds\n            success: Whether execution was successful\n        \"\"\"\n        if not self._meter or not self.config.enabled:\n            return\n\n        attributes = {\"tool.name\": tool_name}\n\n        self.tool_executions.add(1, attributes)\n\n        if not success:\n            self.tool_errors.add(1, attributes)\n\n        self.tool_duration.record(duration, attributes)\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.tracer","title":"<code>tracer</code>  <code>property</code>","text":"<p>Get the tracer instance.</p>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.meter","title":"<code>meter</code>  <code>property</code>","text":"<p>Get the meter instance.</p>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.__init__","title":"<code>__init__(service_name='agenticraft', service_version='0.1.0', export_to=None, enabled=True)</code>","text":"<p>Initialize telemetry.</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def __init__(\n    self,\n    service_name: str = \"agenticraft\",\n    service_version: str = \"0.1.0\", \n    export_to: Optional[str] = None,\n    enabled: bool = True\n):\n    \"\"\"Initialize telemetry.\"\"\"\n    self.config = TelemetryConfig(\n        service_name=service_name,\n        service_version=service_version,\n        export_endpoint=export_to,\n        enabled=enabled\n    )\n\n    self._tracer: Optional[trace.Tracer] = None\n    self._meter: Optional[metrics.Meter] = None\n\n    if self.config.enabled:\n        self._setup_telemetry()\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.span","title":"<code>span(name, attributes=None)</code>","text":"<p>Create a traced span.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Span name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Span attributes</p> <code>None</code> Example <p>with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):     # Do work     pass</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>@contextmanager\ndef span(self, name: str, attributes: Optional[Dict[str, Any]] = None):\n    \"\"\"Create a traced span.\n\n    Args:\n        name: Span name\n        attributes: Span attributes\n\n    Example:\n        with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):\n            # Do work\n            pass\n    \"\"\"\n    if not self._tracer or not self.config.enabled:\n        yield None\n        return\n\n    with self._tracer.start_as_current_span(name) as span:\n        if attributes:\n            for key, value in attributes.items():\n                span.set_attribute(key, value)\n        yield span\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.record_agent_run","title":"<code>record_agent_run(agent_name, duration, success, tokens=None)</code>","text":"<p>Record metrics for an agent run.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Name of the agent</p> required <code>duration</code> <code>float</code> <p>Execution duration in seconds</p> required <code>success</code> <code>bool</code> <p>Whether the run was successful</p> required <code>tokens</code> <code>Optional[int]</code> <p>Number of tokens used</p> <code>None</code> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def record_agent_run(\n    self,\n    agent_name: str,\n    duration: float,\n    success: bool,\n    tokens: Optional[int] = None\n) -&gt; None:\n    \"\"\"Record metrics for an agent run.\n\n    Args:\n        agent_name: Name of the agent\n        duration: Execution duration in seconds\n        success: Whether the run was successful\n        tokens: Number of tokens used\n    \"\"\"\n    if not self._meter or not self.config.enabled:\n        return\n\n    attributes = {\"agent.name\": agent_name}\n\n    self.agent_runs.add(1, attributes)\n\n    if not success:\n        self.agent_errors.add(1, attributes)\n\n    self.agent_duration.record(duration, attributes)\n\n    if tokens is not None:\n        self.tokens_used.add(tokens, attributes)\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.Telemetry.record_tool_execution","title":"<code>record_tool_execution(tool_name, duration, success)</code>","text":"<p>Record metrics for a tool execution.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>duration</code> <code>float</code> <p>Execution duration in seconds</p> required <code>success</code> <code>bool</code> <p>Whether execution was successful</p> required Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def record_tool_execution(\n    self,\n    tool_name: str,\n    duration: float,\n    success: bool\n) -&gt; None:\n    \"\"\"Record metrics for a tool execution.\n\n    Args:\n        tool_name: Name of the tool\n        duration: Execution duration in seconds\n        success: Whether execution was successful\n    \"\"\"\n    if not self._meter or not self.config.enabled:\n        return\n\n    attributes = {\"tool.name\": tool_name}\n\n    self.tool_executions.add(1, attributes)\n\n    if not success:\n        self.tool_errors.add(1, attributes)\n\n    self.tool_duration.record(duration, attributes)\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.set_global_telemetry","title":"<code>set_global_telemetry(telemetry)</code>","text":"<p>Set the global telemetry instance.</p> <p>Parameters:</p> Name Type Description Default <code>telemetry</code> <code>Telemetry</code> <p>Telemetry instance to use globally</p> required Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def set_global_telemetry(telemetry: Telemetry) -&gt; None:\n    \"\"\"Set the global telemetry instance.\n\n    Args:\n        telemetry: Telemetry instance to use globally\n    \"\"\"\n    global _global_telemetry\n    _global_telemetry = telemetry\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.get_global_telemetry","title":"<code>get_global_telemetry()</code>","text":"<p>Get the global telemetry instance.</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def get_global_telemetry() -&gt; Optional[Telemetry]:\n    \"\"\"Get the global telemetry instance.\"\"\"\n    return _global_telemetry\n</code></pre>"},{"location":"reference/core/telemetry/#agenticraft.core.telemetry.init_telemetry","title":"<code>init_telemetry(service_name='agenticraft', export_to=None, enabled=True)</code>","text":"<p>Initialize and set global telemetry.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> <code>'agenticraft'</code> <code>export_to</code> <code>Optional[str]</code> <p>OTLP endpoint</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether telemetry is enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>Telemetry</code> <p>Telemetry instance</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def init_telemetry(\n    service_name: str = \"agenticraft\",\n    export_to: Optional[str] = None,\n    enabled: bool = True\n) -&gt; Telemetry:\n    \"\"\"Initialize and set global telemetry.\n\n    Args:\n        service_name: Name of your service\n        export_to: OTLP endpoint\n        enabled: Whether telemetry is enabled\n\n    Returns:\n        Telemetry instance\n    \"\"\"\n    telemetry = Telemetry(\n        service_name=service_name,\n        export_to=export_to,\n        enabled=enabled\n    )\n    set_global_telemetry(telemetry)\n    return telemetry\n</code></pre>"},{"location":"reference/core/tool/","title":"Tool","text":""},{"location":"reference/core/tool/#agenticraft.core.tool","title":"<code>tool</code>","text":"<p>Tool abstraction for AgentiCraft.</p> <p>This module provides the base classes and decorators for creating tools that agents can use. Tools are functions that extend an agent's capabilities beyond just language generation.</p> Example <p>Creating a simple tool::</p> <pre><code>from agenticraft import tool\n\n@tool\ndef calculate(expression: str) -&gt; float:\n    '''Evaluate a mathematical expression.'''\n    return eval(expression, {\"__builtins__\": {}})\n\n# Use with an agent\nagent = Agent(tools=[calculate])\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool","title":"<code>BaseTool</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all tools.</p> <p>Tools extend agent capabilities by providing specific functions that can be called during agent execution.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class BaseTool(ABC):\n    \"\"\"Base class for all tools.\n\n    Tools extend agent capabilities by providing specific functions\n    that can be called during agent execution.\n    \"\"\"\n\n    def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n        \"\"\"Initialize a tool.\n\n        Args:\n            name: Override the tool name\n            description: Override the tool description\n        \"\"\"\n        # Check if class has a name attribute first\n        if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n            self.name = self.__class__.name\n        else:\n            self.name = name or self.__class__.__name__\n\n        # Check if class has a description attribute first\n        if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n            self.description = self.__class__.description\n        else:\n            self.description = description or self.__class__.__doc__ or \"No description\"\n\n    @abstractmethod\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool asynchronously.\"\"\"\n        pass\n\n    def run(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool synchronously.\"\"\"\n        return asyncio.run(self.arun(**kwargs))\n\n    @abstractmethod\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get the tool definition for LLM providers.\"\"\"\n        pass\n\n    async def __call__(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Make the tool callable.\"\"\"\n        return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool.__init__","title":"<code>__init__(name=None, description=None)</code>","text":"<p>Initialize a tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override the tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override the tool description</p> <code>None</code> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __init__(self, name: Optional[str] = None, description: Optional[str] = None):\n    \"\"\"Initialize a tool.\n\n    Args:\n        name: Override the tool name\n        description: Override the tool description\n    \"\"\"\n    # Check if class has a name attribute first\n    if name is None and hasattr(self.__class__, 'name') and self.__class__.name != 'BaseTool':\n        self.name = self.__class__.name\n    else:\n        self.name = name or self.__class__.__name__\n\n    # Check if class has a description attribute first\n    if description is None and hasattr(self.__class__, 'description') and self.__class__.description != 'BaseTool':\n        self.description = self.__class__.description\n    else:\n        self.description = description or self.__class__.__doc__ or \"No description\"\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool.arun","title":"<code>arun(**kwargs)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Run the tool asynchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\nasync def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool asynchronously.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool.run","title":"<code>run(**kwargs)</code>","text":"<p>Run the tool synchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool synchronously.\"\"\"\n    return asyncio.run(self.arun(**kwargs))\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool.get_definition","title":"<code>get_definition()</code>  <code>abstractmethod</code>","text":"<p>Get the tool definition for LLM providers.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>@abstractmethod\ndef get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get the tool definition for LLM providers.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.BaseTool.__call__","title":"<code>__call__(**kwargs)</code>  <code>async</code>","text":"<p>Make the tool callable.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def __call__(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Make the tool callable.\"\"\"\n    return await self.arun(**kwargs)\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool","title":"<code>FunctionTool</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>A tool created from a function.</p> <p>This is the most common type of tool, created using the @tool decorator.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class FunctionTool(BaseTool):\n    \"\"\"A tool created from a function.\n\n    This is the most common type of tool, created using the @tool decorator.\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable,\n        name: Optional[str] = None,\n        description: Optional[str] = None\n    ):\n        \"\"\"Initialize from a function.\"\"\"\n        self.func = func\n        self.is_async = asyncio.iscoroutinefunction(func)\n\n        # Extract metadata\n        name = name or func.__name__\n        description = description or func.__doc__ or f\"Function {func.__name__}\"\n\n        super().__init__(name=name, description=description)\n\n        # Parse function signature\n        self.signature = inspect.signature(func)\n        self.parameters = self._parse_parameters()\n\n    def _parse_parameters(self) -&gt; List[ToolParameter]:\n        \"\"\"Parse function parameters into ToolParameter objects.\"\"\"\n        parameters = []\n\n        for param_name, param in self.signature.parameters.items():\n            if param_name == 'self':\n                continue\n\n            # Get type annotation\n            param_type = \"string\"  # default\n            if param.annotation != inspect.Parameter.empty:\n                # Handle Optional types\n                annotation = param.annotation\n\n                # Check if it's Optional (Union with None)\n                if hasattr(annotation, '__origin__'):\n                    if annotation.__origin__ is Union:\n                        # Get the non-None type from Optional\n                        args = [arg for arg in annotation.__args__ if arg is not type(None)]\n                        if args:\n                            annotation = args[0]\n\n                # Check for generic types (List, Dict, etc.)\n                if hasattr(annotation, '__origin__'):\n                    origin = annotation.__origin__\n                    # Map generic types to their base types\n                    if origin is list:\n                        annotation = list\n                    elif origin is dict:\n                        annotation = dict\n                    # Add more generic types as needed\n\n                type_map = {\n                    int: \"integer\",\n                    float: \"number\",\n                    str: \"string\",\n                    bool: \"boolean\",\n                    list: \"array\",\n                    dict: \"object\"\n                }\n                param_type = type_map.get(annotation, \"string\")\n\n            # Check if required (no default value)\n            required = param.default == inspect.Parameter.empty\n\n            # Extract description from docstring if available\n            description = f\"Parameter {param_name}\"\n\n            parameters.append(ToolParameter(\n                name=param_name,\n                type=param_type,\n                description=description,\n                required=required,\n                default=None if required else param.default\n            ))\n\n        return parameters\n\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool asynchronously.\"\"\"\n        try:\n            # Validate arguments\n            self._validate_arguments(kwargs)\n\n            # Execute\n            if self.is_async:\n                result = await self.func(**kwargs)\n            else:\n                result = self.func(**kwargs)\n\n            return result\n\n        except Exception as e:\n            raise ToolExecutionError(str(e), tool_name=self.name) from e\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Make the tool callable with original function signature.\"\"\"\n        # If called with positional args, convert to kwargs using signature\n        if args:\n            bound_args = self.signature.bind(*args, **kwargs)\n            bound_args.apply_defaults()\n            kwargs = bound_args.arguments\n\n        # Run synchronously if called directly\n        if self.is_async:\n            # If in an async context, this would fail - user should use arun\n            # For now, just run in a new event loop\n            try:\n                loop = asyncio.get_running_loop()\n                # We're in an async context, can't use asyncio.run\n                raise RuntimeError(\"Cannot call async tool synchronously from async context. Use await tool.arun() instead.\")\n            except RuntimeError:\n                # No running loop, safe to use asyncio.run\n                return asyncio.run(self.arun(**kwargs))\n        else:\n            return self.run(**kwargs)\n\n    def _validate_arguments(self, kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"Validate arguments against function signature.\"\"\"\n        # Check required parameters\n        for param in self.parameters:\n            if param.required and param.name not in kwargs:\n                raise ToolValidationError(\n                    self.name,\n                    f\"Missing required parameter: {param.name}\"\n                )\n\n        # Check for unknown parameters\n        valid_params = {p.name for p in self.parameters}\n        for key in kwargs:\n            if key not in valid_params:\n                raise ToolValidationError(\n                    self.name,\n                    f\"Unknown parameter: {key}\"\n                )\n\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get the tool definition.\"\"\"\n        return ToolDefinition(\n            name=self.name,\n            description=self.description,\n            parameters=self.parameters\n        )\n\n    def run(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Run the tool synchronously.\"\"\"\n        # Override to handle sync functions without creating event loop issues\n        try:\n            # Validate arguments\n            self._validate_arguments(kwargs)\n\n            # Execute sync functions directly\n            if not self.is_async:\n                result = self.func(**kwargs)\n                return result\n            else:\n                # For async functions, use the parent's run method\n                return super().run(**kwargs)\n\n        except ToolValidationError:\n            raise\n        except ToolExecutionError:\n            raise\n        except Exception as e:\n            raise ToolExecutionError(str(e), tool_name=self.name) from e\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool.__init__","title":"<code>__init__(func, name=None, description=None)</code>","text":"<p>Initialize from a function.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __init__(\n    self,\n    func: Callable,\n    name: Optional[str] = None,\n    description: Optional[str] = None\n):\n    \"\"\"Initialize from a function.\"\"\"\n    self.func = func\n    self.is_async = asyncio.iscoroutinefunction(func)\n\n    # Extract metadata\n    name = name or func.__name__\n    description = description or func.__doc__ or f\"Function {func.__name__}\"\n\n    super().__init__(name=name, description=description)\n\n    # Parse function signature\n    self.signature = inspect.signature(func)\n    self.parameters = self._parse_parameters()\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool.arun","title":"<code>arun(**kwargs)</code>  <code>async</code>","text":"<p>Run the tool asynchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool asynchronously.\"\"\"\n    try:\n        # Validate arguments\n        self._validate_arguments(kwargs)\n\n        # Execute\n        if self.is_async:\n            result = await self.func(**kwargs)\n        else:\n            result = self.func(**kwargs)\n\n        return result\n\n    except Exception as e:\n        raise ToolExecutionError(str(e), tool_name=self.name) from e\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Make the tool callable with original function signature.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Make the tool callable with original function signature.\"\"\"\n    # If called with positional args, convert to kwargs using signature\n    if args:\n        bound_args = self.signature.bind(*args, **kwargs)\n        bound_args.apply_defaults()\n        kwargs = bound_args.arguments\n\n    # Run synchronously if called directly\n    if self.is_async:\n        # If in an async context, this would fail - user should use arun\n        # For now, just run in a new event loop\n        try:\n            loop = asyncio.get_running_loop()\n            # We're in an async context, can't use asyncio.run\n            raise RuntimeError(\"Cannot call async tool synchronously from async context. Use await tool.arun() instead.\")\n        except RuntimeError:\n            # No running loop, safe to use asyncio.run\n            return asyncio.run(self.arun(**kwargs))\n    else:\n        return self.run(**kwargs)\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool.get_definition","title":"<code>get_definition()</code>","text":"<p>Get the tool definition.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get the tool definition.\"\"\"\n    return ToolDefinition(\n        name=self.name,\n        description=self.description,\n        parameters=self.parameters\n    )\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.FunctionTool.run","title":"<code>run(**kwargs)</code>","text":"<p>Run the tool synchronously.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def run(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Run the tool synchronously.\"\"\"\n    # Override to handle sync functions without creating event loop issues\n    try:\n        # Validate arguments\n        self._validate_arguments(kwargs)\n\n        # Execute sync functions directly\n        if not self.is_async:\n            result = self.func(**kwargs)\n            return result\n        else:\n            # For async functions, use the parent's run method\n            return super().run(**kwargs)\n\n    except ToolValidationError:\n        raise\n    except ToolExecutionError:\n        raise\n    except Exception as e:\n        raise ToolExecutionError(str(e), tool_name=self.name) from e\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry","title":"<code>ToolRegistry</code>","text":"<p>Registry for managing tools.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class ToolRegistry:\n    \"\"\"Registry for managing tools.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the registry.\"\"\"\n        self._tools: Dict[str, BaseTool] = {}\n\n    def register(self, tool: Union[BaseTool, Callable], name: Optional[str] = None) -&gt; None:\n        \"\"\"Register a tool.\n\n        Args:\n            tool: Tool instance or callable to register\n            name: Optional name override for the tool\n        \"\"\"\n        if callable(tool) and not isinstance(tool, BaseTool):\n            # Convert function to tool\n            tool = FunctionTool(tool, name=name)\n\n        if not isinstance(tool, BaseTool):\n            raise ValueError(f\"Invalid tool type: {type(tool)}\")\n\n        # Use provided name or tool's own name\n        tool_name = name or tool.name\n        self._tools[tool_name] = tool\n\n    def get(self, name: str) -&gt; BaseTool:\n        \"\"\"Get a tool by name.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            The tool instance\n\n        Raises:\n            ToolNotFoundError: If tool not found\n        \"\"\"\n        if name not in self._tools:\n            raise ToolNotFoundError(name)\n        return self._tools[name]\n\n    async def execute(self, name: str, **kwargs: Any) -&gt; Any:\n        \"\"\"Execute a tool by name.\n\n        Args:\n            name: Tool name\n            **kwargs: Tool arguments\n\n        Returns:\n            Tool execution result\n        \"\"\"\n        tool = self.get(name)\n        return await tool.arun(**kwargs)\n\n    def get_tools_schema(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get schema for all tools (for LLM providers).\"\"\"\n        if not self._tools:\n            return []\n\n        schemas = []\n        for tool in self._tools.values():\n            definition = tool.get_definition()\n            schemas.append(definition.to_openai_schema())\n\n        return schemas\n\n    def list_tools(self) -&gt; List[str]:\n        \"\"\"List all registered tool names.\"\"\"\n        return list(self._tools.keys())\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered tools.\"\"\"\n        self._tools.clear()\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the registry.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the registry.\"\"\"\n    self._tools: Dict[str, BaseTool] = {}\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.register","title":"<code>register(tool, name=None)</code>","text":"<p>Register a tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, Callable]</code> <p>Tool instance or callable to register</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name override for the tool</p> <code>None</code> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def register(self, tool: Union[BaseTool, Callable], name: Optional[str] = None) -&gt; None:\n    \"\"\"Register a tool.\n\n    Args:\n        tool: Tool instance or callable to register\n        name: Optional name override for the tool\n    \"\"\"\n    if callable(tool) and not isinstance(tool, BaseTool):\n        # Convert function to tool\n        tool = FunctionTool(tool, name=name)\n\n    if not isinstance(tool, BaseTool):\n        raise ValueError(f\"Invalid tool type: {type(tool)}\")\n\n    # Use provided name or tool's own name\n    tool_name = name or tool.name\n    self._tools[tool_name] = tool\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.get","title":"<code>get(name)</code>","text":"<p>Get a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>The tool instance</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def get(self, name: str) -&gt; BaseTool:\n    \"\"\"Get a tool by name.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        The tool instance\n\n    Raises:\n        ToolNotFoundError: If tool not found\n    \"\"\"\n    if name not in self._tools:\n        raise ToolNotFoundError(name)\n    return self._tools[name]\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.execute","title":"<code>execute(name, **kwargs)</code>  <code>async</code>","text":"<p>Execute a tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <code>**kwargs</code> <code>Any</code> <p>Tool arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Tool execution result</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def execute(self, name: str, **kwargs: Any) -&gt; Any:\n    \"\"\"Execute a tool by name.\n\n    Args:\n        name: Tool name\n        **kwargs: Tool arguments\n\n    Returns:\n        Tool execution result\n    \"\"\"\n    tool = self.get(name)\n    return await tool.arun(**kwargs)\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.get_tools_schema","title":"<code>get_tools_schema()</code>","text":"<p>Get schema for all tools (for LLM providers).</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def get_tools_schema(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get schema for all tools (for LLM providers).\"\"\"\n    if not self._tools:\n        return []\n\n    schemas = []\n    for tool in self._tools.values():\n        definition = tool.get_definition()\n        schemas.append(definition.to_openai_schema())\n\n    return schemas\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.list_tools","title":"<code>list_tools()</code>","text":"<p>List all registered tool names.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def list_tools(self) -&gt; List[str]:\n    \"\"\"List all registered tool names.\"\"\"\n    return list(self._tools.keys())\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.ToolRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered tools.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered tools.\"\"\"\n    self._tools.clear()\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.Calculator","title":"<code>Calculator</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>A simple calculator tool for mathematical expressions.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>class Calculator(BaseTool):\n    \"\"\"A simple calculator tool for mathematical expressions.\"\"\"\n\n    def __init__(self):\n        super().__init__(\n            name=\"calculator\",\n            description=\"Calculator tool to evaluate mathematical expressions safely\"\n        )\n\n    async def arun(self, expression: str) -&gt; float:\n        \"\"\"Evaluate a mathematical expression.\"\"\"\n        try:\n            # Only allow basic arithmetic operations, no function calls\n            # This is the safest approach\n            result = eval(expression, {\"__builtins__\": {}}, {})\n            return float(result)\n        except Exception as e:\n            raise ToolExecutionError(f\"Invalid expression: {e}\", tool_name=self.name)\n\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get tool definition.\"\"\"\n        return ToolDefinition(\n            name=self.name,\n            description=self.description,\n            parameters=[\n                ToolParameter(\n                    name=\"expression\",\n                    type=\"string\",\n                    description=\"Mathematical expression to evaluate\",\n                    required=True\n                )\n            ]\n        )\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.Calculator.arun","title":"<code>arun(expression)</code>  <code>async</code>","text":"<p>Evaluate a mathematical expression.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>async def arun(self, expression: str) -&gt; float:\n    \"\"\"Evaluate a mathematical expression.\"\"\"\n    try:\n        # Only allow basic arithmetic operations, no function calls\n        # This is the safest approach\n        result = eval(expression, {\"__builtins__\": {}}, {})\n        return float(result)\n    except Exception as e:\n        raise ToolExecutionError(f\"Invalid expression: {e}\", tool_name=self.name)\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.Calculator.get_definition","title":"<code>get_definition()</code>","text":"<p>Get tool definition.</p> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get tool definition.\"\"\"\n    return ToolDefinition(\n        name=self.name,\n        description=self.description,\n        parameters=[\n            ToolParameter(\n                name=\"expression\",\n                type=\"string\",\n                description=\"Mathematical expression to evaluate\",\n                required=True\n            )\n        ]\n    )\n</code></pre>"},{"location":"reference/core/tool/#agenticraft.core.tool.tool","title":"<code>tool(name=None, description=None)</code>","text":"<p>Decorator to create a tool from a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override the function name as the tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override the function docstring as description</p> <code>None</code> Example <p>Basic tool::</p> <pre><code>@tool\ndef get_weather(city: str) -&gt; str:\n    '''Get weather for a city.'''\n    return f\"Weather in {city}: Sunny\"\n</code></pre> <p>With overrides::</p> <pre><code>@tool(name=\"calc\", description=\"Calculate math\")\ndef calculate(expr: str) -&gt; float:\n    return eval(expr)\n</code></pre> Source code in <code>agenticraft/core/tool.py</code> <pre><code>def tool(\n    name: Optional[str] = None,\n    description: Optional[str] = None\n) -&gt; Callable:\n    \"\"\"Decorator to create a tool from a function.\n\n    Args:\n        name: Override the function name as the tool name\n        description: Override the function docstring as description\n\n    Example:\n        Basic tool::\n\n            @tool\n            def get_weather(city: str) -&gt; str:\n                '''Get weather for a city.'''\n                return f\"Weather in {city}: Sunny\"\n\n        With overrides::\n\n            @tool(name=\"calc\", description=\"Calculate math\")\n            def calculate(expr: str) -&gt; float:\n                return eval(expr)\n    \"\"\"\n    def decorator(func: Callable) -&gt; FunctionTool:\n        return FunctionTool(func, name=name, description=description)\n\n    # Handle both @tool and @tool() syntax\n    if callable(name):\n        func = name\n        name = None\n        return decorator(func)\n\n    return decorator\n</code></pre>"},{"location":"reference/core/types/","title":"Types","text":""},{"location":"reference/core/types/#agenticraft.core.types","title":"<code>types</code>","text":"<p>Common types used throughout AgentiCraft.</p> <p>This module defines shared type definitions, enums, and data structures used across the AgentiCraft framework.</p>"},{"location":"reference/core/types/#agenticraft.core.types.ToolCall","title":"<code>ToolCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a call to a tool.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class ToolCall(BaseModel):\n    \"\"\"Represents a call to a tool.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid4()))\n    name: str\n    arguments: Dict[str, Any]\n\n    @field_validator('arguments', mode='before')\n    @classmethod\n    def validate_arguments(cls, v: Any) -&gt; Dict[str, Any]:\n        \"\"\"Ensure arguments is a dictionary.\"\"\"\n        if isinstance(v, str):\n            try:\n                return json.loads(v)\n            except json.JSONDecodeError:\n                return {\"input\": v}\n        return v\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolCall.validate_arguments","title":"<code>validate_arguments(v)</code>  <code>classmethod</code>","text":"<p>Ensure arguments is a dictionary.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>@field_validator('arguments', mode='before')\n@classmethod\ndef validate_arguments(cls, v: Any) -&gt; Dict[str, Any]:\n    \"\"\"Ensure arguments is a dictionary.\"\"\"\n    if isinstance(v, str):\n        try:\n            return json.loads(v)\n        except json.JSONDecodeError:\n            return {\"input\": v}\n    return v\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolResult","title":"<code>ToolResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from a tool execution.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class ToolResult(BaseModel):\n    \"\"\"Result from a tool execution.\"\"\"\n\n    tool_call_id: str\n    result: Any\n    error: Optional[str] = None\n\n    @property\n    def success(self) -&gt; bool:\n        \"\"\"Check if the tool execution was successful.\"\"\"\n        return self.error is None\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolResult.success","title":"<code>success</code>  <code>property</code>","text":"<p>Check if the tool execution was successful.</p>"},{"location":"reference/core/types/#agenticraft.core.types.MessageRole","title":"<code>MessageRole</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Role of a message in a conversation.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class MessageRole(str, Enum):\n    \"\"\"Role of a message in a conversation.\"\"\"\n\n    SYSTEM = \"system\"\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n    TOOL = \"tool\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A message in a conversation.</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>MessageRole</code> <p>The role of the message sender</p> <code>content</code> <code>str</code> <p>The message content</p> <code>tool_calls</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Tool calls made in this message (for assistant messages)</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata</p> <code>created_at</code> <code>datetime</code> <p>When the message was created</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"A message in a conversation.\n\n    Attributes:\n        role: The role of the message sender\n        content: The message content\n        tool_calls: Tool calls made in this message (for assistant messages)\n        metadata: Additional metadata\n        created_at: When the message was created\n    \"\"\"\n\n    role: MessageRole\n    content: str\n    tool_calls: Optional[List[Dict[str, Any]]] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=datetime.now)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for LLM providers.\"\"\"\n        data = {\n            \"role\": str(self.role),\n            \"content\": self.content\n        }\n\n        if self.tool_calls:\n            data[\"tool_calls\"] = self.tool_calls\n\n        # Some providers need specific metadata\n        if self.role == MessageRole.TOOL and \"tool_call_id\" in self.metadata:\n            data[\"tool_call_id\"] = self.metadata[\"tool_call_id\"]\n\n        return data\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.Message.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for LLM providers.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for LLM providers.\"\"\"\n    data = {\n        \"role\": str(self.role),\n        \"content\": self.content\n    }\n\n    if self.tool_calls:\n        data[\"tool_calls\"] = self.tool_calls\n\n    # Some providers need specific metadata\n    if self.role == MessageRole.TOOL and \"tool_call_id\" in self.metadata:\n        data[\"tool_call_id\"] = self.metadata[\"tool_call_id\"]\n\n    return data\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.CompletionResponse","title":"<code>CompletionResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response from an LLM completion.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class CompletionResponse(BaseModel):\n    \"\"\"Response from an LLM completion.\"\"\"\n\n    content: str\n    tool_calls: List[ToolCall] = Field(default_factory=list)\n    finish_reason: Optional[str] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    usage: Optional[Dict[str, int]] = None\n    model: Optional[str] = None  # Model used for completion\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolParameter","title":"<code>ToolParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition of a tool parameter.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class ToolParameter(BaseModel):\n    \"\"\"Definition of a tool parameter.\"\"\"\n\n    name: str\n    type: str\n    description: str\n    required: bool = True\n    default: Any = None\n    enum: Optional[List[Any]] = None\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolDefinition","title":"<code>ToolDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition of a tool for LLM providers.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>class ToolDefinition(BaseModel):\n    \"\"\"Definition of a tool for LLM providers.\"\"\"\n\n    name: str\n    description: str\n    parameters: List[ToolParameter]\n\n    def to_openai_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to OpenAI function schema.\"\"\"\n        properties = {}\n        required = []\n\n        for param in self.parameters:\n            properties[param.name] = {\n                \"type\": param.type,\n                \"description\": param.description\n            }\n            if param.enum:\n                properties[param.name][\"enum\"] = param.enum\n            if param.default is not None:\n                properties[param.name][\"default\"] = param.default\n            if param.required:\n                required.append(param.name)\n\n        return {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": self.name,\n                \"description\": self.description,\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": properties,\n                    \"required\": required\n                }\n            }\n        }\n</code></pre>"},{"location":"reference/core/types/#agenticraft.core.types.ToolDefinition.to_openai_schema","title":"<code>to_openai_schema()</code>","text":"<p>Convert to OpenAI function schema.</p> Source code in <code>agenticraft/core/types.py</code> <pre><code>def to_openai_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to OpenAI function schema.\"\"\"\n    properties = {}\n    required = []\n\n    for param in self.parameters:\n        properties[param.name] = {\n            \"type\": param.type,\n            \"description\": param.description\n        }\n        if param.enum:\n            properties[param.name][\"enum\"] = param.enum\n        if param.default is not None:\n            properties[param.name][\"default\"] = param.default\n        if param.required:\n            required.append(param.name)\n\n    return {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required\n            }\n        }\n    }\n</code></pre>"},{"location":"reference/core/workflow/","title":"Workflow","text":""},{"location":"reference/core/workflow/#agenticraft.core.workflow","title":"<code>workflow</code>","text":"<p>Workflow engine for AgentiCraft.</p> <p>This module provides a simple step-based workflow engine for chaining agents and tools together. Unlike graph-based approaches, our workflows use a simple dependency system that's easy to understand and debug.</p> Example <p>Creating a simple workflow::</p> <pre><code>from agenticraft import Workflow, Step, Agent\n\nresearcher = Agent(name=\"Researcher\")\nwriter = Agent(name=\"Writer\")\n\nworkflow = Workflow(name=\"content_pipeline\")\nworkflow.add_steps([\n    Step(\"research\", agent=researcher, inputs=[\"topic\"]),\n    Step(\"write\", agent=writer, depends_on=[\"research\"])\n])\n\nresult = await workflow.run(topic=\"AI trends\")\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.StepResult","title":"<code>StepResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from a workflow step execution.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class StepResult(BaseModel):\n    \"\"\"Result from a workflow step execution.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    step_name: str\n    success: bool\n    output: Any\n    error: Optional[str] = None\n    started_at: datetime\n    completed_at: datetime\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Step","title":"<code>Step</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single step in a workflow.</p> <p>Steps are the building blocks of workflows. Each step can be executed by an agent or a tool, and can depend on other steps.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique name for this step</p> <code>agent</code> <code>Optional[Agent]</code> <p>Agent to execute this step</p> <code>tool</code> <code>Optional[Any]</code> <p>Tool to execute this step (if no agent)</p> <code>inputs</code> <code>Dict[str, Any]</code> <p>Input parameters for this step</p> <code>depends_on</code> <code>List[str]</code> <p>Names of steps this depends on</p> <code>retry_count</code> <code>int</code> <p>Number of retries on failure</p> <code>timeout</code> <code>Optional[int]</code> <p>Timeout in seconds</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class Step(BaseModel):\n    \"\"\"A single step in a workflow.\n\n    Steps are the building blocks of workflows. Each step can be\n    executed by an agent or a tool, and can depend on other steps.\n\n    Attributes:\n        name: Unique name for this step\n        agent: Agent to execute this step\n        tool: Tool to execute this step (if no agent)\n        inputs: Input parameters for this step\n        depends_on: Names of steps this depends on\n        retry_count: Number of retries on failure\n        timeout: Timeout in seconds\n    \"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    name: str\n    agent: Optional[Agent] = None\n    tool: Optional[Any] = None  # Will be BaseTool when imported\n    inputs: Dict[str, Any] = Field(default_factory=dict)\n    depends_on: List[str] = Field(default_factory=list)\n    retry_count: int = Field(default=0, ge=0)\n    timeout: Optional[int] = Field(default=None, gt=0)\n\n    @model_validator(mode='before')\n    @classmethod\n    def validate_executor(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Ensure we have either an agent or tool.\"\"\"\n        agent = values.get('agent')\n        tool = values.get('tool')\n\n        if agent is None and tool is None:\n            raise ValueError(\"Step must have either an agent or a tool\")\n        if agent is not None and tool is not None:\n            raise ValueError(\"Step cannot have both agent and tool\")\n\n        # Check if agent is a mock object (for testing)\n        if agent is not None:\n            agent_type_str = str(type(agent))\n            is_mock = (\n                'mock' in agent_type_str.lower() or\n                hasattr(agent, '_mock_name') or\n                hasattr(agent, '_mock_methods') or\n                hasattr(agent, '_spec_class') or\n                hasattr(agent, '_mock_sealed') or\n                (hasattr(type(agent), '__module__') and \n                 type(agent).__module__ in ['unittest.mock', 'mock'])\n            )\n            if is_mock:\n                # Allow mocks in testing\n                return values\n\n            # In production, validate it's an Agent or has arun method\n            # Import here to avoid circular imports\n            try:\n                from .agent import Agent\n                if not isinstance(agent, Agent) and not hasattr(agent, 'arun'):\n                    raise ValueError(\"Agent must be an Agent instance or have an arun method\")\n            except ImportError:\n                # If can't import Agent, just check for arun method\n                if not hasattr(agent, 'arun'):\n                    raise ValueError(\"Agent must have an arun method\")\n\n        # Similar check for tool\n        if tool is not None:\n            tool_type_str = str(type(tool))\n            is_mock = (\n                'mock' in tool_type_str.lower() or\n                hasattr(tool, '_mock_name') or\n                hasattr(tool, '_mock_methods')\n            )\n            if is_mock:\n                return values\n\n        return values\n\n    def __init__(self, name: str, **kwargs):\n        \"\"\"Convenience constructor.\n\n        Example:\n            Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})\n        \"\"\"\n        super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Step.validate_executor","title":"<code>validate_executor(values)</code>  <code>classmethod</code>","text":"<p>Ensure we have either an agent or tool.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>@model_validator(mode='before')\n@classmethod\ndef validate_executor(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Ensure we have either an agent or tool.\"\"\"\n    agent = values.get('agent')\n    tool = values.get('tool')\n\n    if agent is None and tool is None:\n        raise ValueError(\"Step must have either an agent or a tool\")\n    if agent is not None and tool is not None:\n        raise ValueError(\"Step cannot have both agent and tool\")\n\n    # Check if agent is a mock object (for testing)\n    if agent is not None:\n        agent_type_str = str(type(agent))\n        is_mock = (\n            'mock' in agent_type_str.lower() or\n            hasattr(agent, '_mock_name') or\n            hasattr(agent, '_mock_methods') or\n            hasattr(agent, '_spec_class') or\n            hasattr(agent, '_mock_sealed') or\n            (hasattr(type(agent), '__module__') and \n             type(agent).__module__ in ['unittest.mock', 'mock'])\n        )\n        if is_mock:\n            # Allow mocks in testing\n            return values\n\n        # In production, validate it's an Agent or has arun method\n        # Import here to avoid circular imports\n        try:\n            from .agent import Agent\n            if not isinstance(agent, Agent) and not hasattr(agent, 'arun'):\n                raise ValueError(\"Agent must be an Agent instance or have an arun method\")\n        except ImportError:\n            # If can't import Agent, just check for arun method\n            if not hasattr(agent, 'arun'):\n                raise ValueError(\"Agent must have an arun method\")\n\n    # Similar check for tool\n    if tool is not None:\n        tool_type_str = str(type(tool))\n        is_mock = (\n            'mock' in tool_type_str.lower() or\n            hasattr(tool, '_mock_name') or\n            hasattr(tool, '_mock_methods')\n        )\n        if is_mock:\n            return values\n\n    return values\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Step.__init__","title":"<code>__init__(name, **kwargs)</code>","text":"<p>Convenience constructor.</p> Example <p>Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __init__(self, name: str, **kwargs):\n    \"\"\"Convenience constructor.\n\n    Example:\n        Step(\"analyze\", agent=analyzer, inputs={\"data\": \"...\"})\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.WorkflowResult","title":"<code>WorkflowResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from a complete workflow execution.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class WorkflowResult(BaseModel):\n    \"\"\"Result from a complete workflow execution.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    workflow_id: str\n    workflow_name: str\n    success: bool\n    steps: Dict[str, StepResult]\n    started_at: datetime\n    completed_at: datetime\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def __getitem__(self, step_name: str) -&gt; Any:\n        \"\"\"Get output from a specific step.\"\"\"\n        if step_name not in self.steps:\n            raise KeyError(f\"Step '{step_name}' not found in results\")\n        return self.steps[step_name].output\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.WorkflowResult.__getitem__","title":"<code>__getitem__(step_name)</code>","text":"<p>Get output from a specific step.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __getitem__(self, step_name: str) -&gt; Any:\n    \"\"\"Get output from a specific step.\"\"\"\n    if step_name not in self.steps:\n        raise KeyError(f\"Step '{step_name}' not found in results\")\n    return self.steps[step_name].output\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow","title":"<code>Workflow</code>","text":"<p>Simple step-based workflow engine.</p> <p>Workflows in AgentiCraft use a straightforward dependency system instead of complex graphs. Steps are executed in order based on their dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Workflow name</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description</p> <code>None</code> Example <p>Basic workflow::</p> <pre><code>workflow = Workflow(\"analysis_pipeline\")\n\nworkflow.add_step(\n    Step(\"load\", tool=load_data, inputs={\"file\": \"data.csv\"})\n)\nworkflow.add_step(\n    Step(\"analyze\", agent=analyst, depends_on=[\"load\"])\n)\nworkflow.add_step(\n    Step(\"report\", agent=reporter, depends_on=[\"analyze\"])\n)\n\nresult = await workflow.run(file=\"sales.csv\")\n</code></pre> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>class Workflow:\n    \"\"\"Simple step-based workflow engine.\n\n    Workflows in AgentiCraft use a straightforward dependency system\n    instead of complex graphs. Steps are executed in order based on\n    their dependencies.\n\n    Args:\n        name: Workflow name\n        description: Optional description\n\n    Example:\n        Basic workflow::\n\n            workflow = Workflow(\"analysis_pipeline\")\n\n            workflow.add_step(\n                Step(\"load\", tool=load_data, inputs={\"file\": \"data.csv\"})\n            )\n            workflow.add_step(\n                Step(\"analyze\", agent=analyst, depends_on=[\"load\"])\n            )\n            workflow.add_step(\n                Step(\"report\", agent=reporter, depends_on=[\"analyze\"])\n            )\n\n            result = await workflow.run(file=\"sales.csv\")\n    \"\"\"\n\n    def __init__(self, name: str, description: Optional[str] = None):\n        \"\"\"Initialize workflow.\"\"\"\n        self.id = str(uuid4())\n        self.name = name\n        self.description = description or f\"Workflow: {name}\"\n        self._steps: Dict[str, Step] = {}\n        self._execution_order: Optional[List[str]] = None\n\n    def add_step(self, step: Step) -&gt; None:\n        \"\"\"Add a single step to the workflow.\n\n        Args:\n            step: Step to add\n\n        Raises:\n            WorkflowError: If step name already exists\n        \"\"\"\n        if step.name in self._steps:\n            raise WorkflowError(f\"Step '{step.name}' already exists\")\n\n        self._steps[step.name] = step\n        self._execution_order = None  # Reset execution order\n\n    def add_steps(self, steps: List[Step]) -&gt; None:\n        \"\"\"Add multiple steps to the workflow.\n\n        Args:\n            steps: List of steps to add\n        \"\"\"\n        for step in steps:\n            self.add_step(step)\n\n    def _validate_dependencies(self) -&gt; None:\n        \"\"\"Validate all step dependencies exist.\"\"\"\n        for step in self._steps.values():\n            for dep in step.depends_on:\n                if dep not in self._steps:\n                    raise WorkflowError(\n                        f\"Step '{step.name}' depends on non-existent step '{dep}'\"\n                    )\n\n    def _calculate_execution_order(self) -&gt; List[str]:\n        \"\"\"Calculate step execution order using topological sort.\"\"\"\n        self._validate_dependencies()\n\n        # Build dependency graph\n        graph: Dict[str, Set[str]] = {name: set() for name in self._steps}\n        in_degree: Dict[str, int] = {name: 0 for name in self._steps}\n\n        for step in self._steps.values():\n            for dep in step.depends_on:\n                graph[dep].add(step.name)\n                in_degree[step.name] += 1\n\n        # Topological sort using Kahn's algorithm\n        queue = [name for name, degree in in_degree.items() if degree == 0]\n        order = []\n\n        while queue:\n            current = queue.pop(0)\n            order.append(current)\n\n            for neighbor in graph[current]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # Check for cycles\n        if len(order) != len(self._steps):\n            raise WorkflowError(\"Workflow contains circular dependencies\")\n\n        return order\n\n    async def run(self, **inputs: Any) -&gt; WorkflowResult:\n        \"\"\"Run the workflow.\n\n        Args:\n            **inputs: Initial inputs for the workflow\n\n        Returns:\n            WorkflowResult with outputs from all steps\n        \"\"\"\n        # Calculate execution order if needed\n        if self._execution_order is None:\n            self._execution_order = self._calculate_execution_order()\n\n        # Initialize result\n        result = WorkflowResult(\n            workflow_id=self.id,\n            workflow_name=self.name,\n            success=True,\n            steps={},\n            started_at=datetime.now(),\n            completed_at=datetime.now()  # Will update\n        )\n\n        # Context for passing data between steps\n        context: Dict[str, Any] = inputs.copy()\n\n        # Execute steps in order\n        for step_name in self._execution_order:\n            step = self._steps[step_name]\n\n            try:\n                # Execute step\n                step_result = await self._execute_step(step, context)\n                result.steps[step_name] = step_result\n\n                # Add output to context for dependent steps\n                context[step_name] = step_result.output\n\n            except Exception as e:\n                # Handle step failure\n                step_result = StepResult(\n                    step_name=step_name,\n                    success=False,\n                    output=None,\n                    error=str(e),\n                    started_at=datetime.now(),\n                    completed_at=datetime.now()\n                )\n                result.steps[step_name] = step_result\n                result.success = False\n\n                # Stop execution on failure\n                break\n\n        result.completed_at = datetime.now()\n        return result\n\n    async def _execute_step(self, step: Step, context: Dict[str, Any]) -&gt; StepResult:\n        \"\"\"Execute a single step.\"\"\"\n        started_at = datetime.now()\n\n        # Prepare inputs\n        step_inputs = {}\n        for key, value in step.inputs.items():\n            if isinstance(value, str) and value.startswith(\"$\"):\n                # Reference to context variable\n                ref_key = value[1:]  # Remove $\n                if ref_key in context:\n                    step_inputs[key] = context[ref_key]\n                else:\n                    raise StepExecutionError(\n                        step.name,\n                        f\"Reference '${ref_key}' not found in context\"\n                    )\n            else:\n                step_inputs[key] = value\n\n        # Add dependency outputs to inputs\n        for dep in step.depends_on:\n            if dep in context:\n                step_inputs[dep] = context[dep]\n\n        # Execute with retries\n        last_error = None\n        for attempt in range(step.retry_count + 1):\n            try:\n                if step.agent:\n                    # Execute with agent\n                    response = await self._execute_with_agent(\n                        step.agent,\n                        step_inputs,\n                        step.timeout\n                    )\n                    output = response\n                elif step.tool:\n                    # Execute with tool\n                    output = await self._execute_with_tool(\n                        step.tool,\n                        step_inputs,\n                        step.timeout\n                    )\n                else:\n                    raise StepExecutionError(step.name, \"No executor defined\")\n\n                # Success\n                return StepResult(\n                    step_name=step.name,\n                    success=True,\n                    output=output,\n                    started_at=started_at,\n                    completed_at=datetime.now(),\n                    metadata={\"attempts\": attempt + 1}\n                )\n\n            except Exception as e:\n                last_error = e\n                if attempt &lt; step.retry_count:\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n                    continue\n                break\n\n        # All attempts failed\n        raise StepExecutionError(\n            step.name,\n            f\"Failed after {step.retry_count + 1} attempts: {last_error}\"\n        )\n\n    async def _execute_with_agent(\n        self,\n        agent: Agent,\n        inputs: Dict[str, Any],\n        timeout: Optional[int]\n    ) -&gt; AgentResponse:\n        \"\"\"Execute step with an agent.\"\"\"\n        # Build prompt from inputs\n        prompt_parts = []\n        context = {}\n\n        for key, value in inputs.items():\n            if isinstance(value, str) and len(value) &lt; 100:\n                prompt_parts.append(f\"{key}: {value}\")\n            else:\n                context[key] = value\n\n        prompt = \"\\n\".join(prompt_parts) if prompt_parts else \"Process the provided context\"\n\n        # Execute with timeout if specified\n        if timeout:\n            return await asyncio.wait_for(\n                agent.arun(prompt, context=context),\n                timeout=timeout\n            )\n        else:\n            return await agent.arun(prompt, context=context)\n\n    async def _execute_with_tool(\n        self,\n        tool: Any,\n        inputs: Dict[str, Any],\n        timeout: Optional[int]\n    ) -&gt; Any:\n        \"\"\"Execute step with a tool.\"\"\"\n        # Execute with timeout if specified\n        if timeout:\n            return await asyncio.wait_for(\n                tool.arun(**inputs),\n                timeout=timeout\n            )\n        else:\n            return await tool.arun(**inputs)\n\n    def visualize(self) -&gt; str:\n        \"\"\"Get a text visualization of the workflow.\"\"\"\n        if not self._steps:\n            return \"Empty workflow\"\n\n        lines = [f\"Workflow: {self.name}\"]\n        lines.append(\"=\" * (len(lines[0]) + 5))\n\n        # Calculate execution order if needed\n        if self._execution_order is None:\n            self._execution_order = self._calculate_execution_order()\n\n        for i, step_name in enumerate(self._execution_order, 1):\n            step = self._steps[step_name]\n            executor = \"agent\" if step.agent else \"tool\"\n            deps = f\" &lt;- {', '.join(step.depends_on)}\" if step.depends_on else \"\"\n            lines.append(f\"{i}. {step_name} ({executor}){deps}\")\n\n        return \"\\n\".join(lines)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"Workflow(name='{self.name}', steps={len(self._steps)})\"\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.__init__","title":"<code>__init__(name, description=None)</code>","text":"<p>Initialize workflow.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __init__(self, name: str, description: Optional[str] = None):\n    \"\"\"Initialize workflow.\"\"\"\n    self.id = str(uuid4())\n    self.name = name\n    self.description = description or f\"Workflow: {name}\"\n    self._steps: Dict[str, Step] = {}\n    self._execution_order: Optional[List[str]] = None\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.add_step","title":"<code>add_step(step)</code>","text":"<p>Add a single step to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>Step to add</p> required <p>Raises:</p> Type Description <code>WorkflowError</code> <p>If step name already exists</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def add_step(self, step: Step) -&gt; None:\n    \"\"\"Add a single step to the workflow.\n\n    Args:\n        step: Step to add\n\n    Raises:\n        WorkflowError: If step name already exists\n    \"\"\"\n    if step.name in self._steps:\n        raise WorkflowError(f\"Step '{step.name}' already exists\")\n\n    self._steps[step.name] = step\n    self._execution_order = None  # Reset execution order\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.add_steps","title":"<code>add_steps(steps)</code>","text":"<p>Add multiple steps to the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>List[Step]</code> <p>List of steps to add</p> required Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def add_steps(self, steps: List[Step]) -&gt; None:\n    \"\"\"Add multiple steps to the workflow.\n\n    Args:\n        steps: List of steps to add\n    \"\"\"\n    for step in steps:\n        self.add_step(step)\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.run","title":"<code>run(**inputs)</code>  <code>async</code>","text":"<p>Run the workflow.</p> <p>Parameters:</p> Name Type Description Default <code>**inputs</code> <code>Any</code> <p>Initial inputs for the workflow</p> <code>{}</code> <p>Returns:</p> Type Description <code>WorkflowResult</code> <p>WorkflowResult with outputs from all steps</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>async def run(self, **inputs: Any) -&gt; WorkflowResult:\n    \"\"\"Run the workflow.\n\n    Args:\n        **inputs: Initial inputs for the workflow\n\n    Returns:\n        WorkflowResult with outputs from all steps\n    \"\"\"\n    # Calculate execution order if needed\n    if self._execution_order is None:\n        self._execution_order = self._calculate_execution_order()\n\n    # Initialize result\n    result = WorkflowResult(\n        workflow_id=self.id,\n        workflow_name=self.name,\n        success=True,\n        steps={},\n        started_at=datetime.now(),\n        completed_at=datetime.now()  # Will update\n    )\n\n    # Context for passing data between steps\n    context: Dict[str, Any] = inputs.copy()\n\n    # Execute steps in order\n    for step_name in self._execution_order:\n        step = self._steps[step_name]\n\n        try:\n            # Execute step\n            step_result = await self._execute_step(step, context)\n            result.steps[step_name] = step_result\n\n            # Add output to context for dependent steps\n            context[step_name] = step_result.output\n\n        except Exception as e:\n            # Handle step failure\n            step_result = StepResult(\n                step_name=step_name,\n                success=False,\n                output=None,\n                error=str(e),\n                started_at=datetime.now(),\n                completed_at=datetime.now()\n            )\n            result.steps[step_name] = step_result\n            result.success = False\n\n            # Stop execution on failure\n            break\n\n    result.completed_at = datetime.now()\n    return result\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.visualize","title":"<code>visualize()</code>","text":"<p>Get a text visualization of the workflow.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def visualize(self) -&gt; str:\n    \"\"\"Get a text visualization of the workflow.\"\"\"\n    if not self._steps:\n        return \"Empty workflow\"\n\n    lines = [f\"Workflow: {self.name}\"]\n    lines.append(\"=\" * (len(lines[0]) + 5))\n\n    # Calculate execution order if needed\n    if self._execution_order is None:\n        self._execution_order = self._calculate_execution_order()\n\n    for i, step_name in enumerate(self._execution_order, 1):\n        step = self._steps[step_name]\n        executor = \"agent\" if step.agent else \"tool\"\n        deps = f\" &lt;- {', '.join(step.depends_on)}\" if step.depends_on else \"\"\n        lines.append(f\"{i}. {step_name} ({executor}){deps}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/core/workflow/#agenticraft.core.workflow.Workflow.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation.</p> Source code in <code>agenticraft/core/workflow.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"Workflow(name='{self.name}', steps={len(self._steps)})\"\n</code></pre>"},{"location":"reference/plugins/__init__/","title":"init","text":""},{"location":"reference/plugins/__init__/#agenticraft.plugins","title":"<code>plugins</code>","text":"<p>AgentiCraft plugin system.</p> <p>This package provides the plugin architecture that allows extending AgentiCraft without modifying the core framework. Plugins can add tools, agents, providers, and custom functionality.</p> Example <p>Using the plugin system::</p> <pre><code>from agenticraft.plugins import BasePlugin, load_plugin, discover_plugins\n\n# Create a custom plugin\nclass MyPlugin(BasePlugin):\n    name = \"my_plugin\"\n    version = \"1.0.0\"\n\n    def get_tools(self):\n        return [MyCustomTool()]\n\n# Discover available plugins\nplugins = discover_plugins()\n\n# Load a specific plugin\nplugin = load_plugin(\"weather_plugin\")\n\n# Get all tools from plugins\nfrom agenticraft.plugins import get_all_plugin_tools\ntools = get_all_plugin_tools()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin","title":"<code>BasePlugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all AgentiCraft plugins.</p> <p>Plugins must inherit from this class and implement required methods. They can optionally override lifecycle hooks to customize behavior.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class BasePlugin(ABC):\n    \"\"\"Base class for all AgentiCraft plugins.\n\n    Plugins must inherit from this class and implement required methods.\n    They can optionally override lifecycle hooks to customize behavior.\n    \"\"\"\n\n    # Plugin metadata (should be overridden by subclasses)\n    name: str = \"unnamed_plugin\"\n    version: str = \"0.0.0\"\n    description: str = \"\"\n    author: str = \"\"\n\n    def __init__(self, config: Optional[PluginConfig] = None):\n        \"\"\"Initialize plugin with configuration.\n\n        Args:\n            config: Plugin configuration\n        \"\"\"\n        self.config = config or PluginConfig()\n        self._initialized = False\n\n    @abstractmethod\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Get plugin information.\n\n        Returns:\n            Plugin metadata and capabilities\n\n        Example:\n            def get_info(self) -&gt; PluginInfo:\n                return PluginInfo(\n                    name=\"my_plugin\",\n                    version=\"1.0.0\",\n                    description=\"Does amazing things\",\n                    provides_tools=[\"calculator\", \"converter\"]\n                )\n        \"\"\"\n        pass\n\n    # Initialization and cleanup\n\n    def initialize(self) -&gt; None:\n        \"\"\"Initialize the plugin.\n\n        Called once when the plugin is loaded. Use this for:\n        - Setting up connections\n        - Loading resources\n        - Validating configuration\n\n        Raises:\n            Exception: If initialization fails\n        \"\"\"\n        self._initialized = True\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up plugin resources.\n\n        Called when the plugin is being unloaded. Use this for:\n        - Closing connections\n        - Releasing resources\n        - Saving state\n        \"\"\"\n        self._initialized = False\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        \"\"\"Check if plugin is initialized.\"\"\"\n        return self._initialized\n\n    # Tool provision\n\n    def get_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Get tools provided by this plugin.\n\n        Returns:\n            List of tool instances\n\n        Example:\n            def get_tools(self):\n                return [\n                    SearchTool(api_key=self.config.config[\"api_key\"]),\n                    CalculatorTool()\n                ]\n        \"\"\"\n        return []\n\n    # Agent enhancement\n\n    def get_agents(self) -&gt; List[type]:\n        \"\"\"Get agent classes provided by this plugin.\n\n        Returns:\n            List of agent classes (not instances)\n\n        Example:\n            def get_agents(self):\n                return [ResearchAgent, AnalysisAgent]\n        \"\"\"\n        return []\n\n    def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n        \"\"\"Enhance an existing agent with plugin capabilities.\n\n        Args:\n            agent: Agent to enhance\n\n        Returns:\n            Enhanced agent (can be same instance)\n\n        Example:\n            def enhance_agent(self, agent):\n                # Add tools\n                for tool in self.get_tools():\n                    agent.add_tool(tool)\n\n                # Add custom reasoning\n                agent.add_reasoning_pattern(\"research_mode\")\n\n                return agent\n        \"\"\"\n        return agent\n\n    # Provider support\n\n    def get_providers(self) -&gt; Dict[str, type]:\n        \"\"\"Get LLM providers offered by this plugin.\n\n        Returns:\n            Dict mapping provider name to provider class\n\n        Example:\n            def get_providers(self):\n                return {\n                    \"custom_llm\": CustomLLMProvider,\n                    \"local_model\": LocalModelProvider\n                }\n        \"\"\"\n        return {}\n\n    # Configuration\n\n    def validate_config(self) -&gt; bool:\n        \"\"\"Validate plugin configuration.\n\n        Returns:\n            True if configuration is valid\n\n        Raises:\n            ValueError: If configuration is invalid\n        \"\"\"\n        return True\n\n    def get_config_schema(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get JSON schema for plugin configuration.\n\n        Returns:\n            JSON schema dict or None\n\n        Example:\n            def get_config_schema(self):\n                return {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"api_key\": {\"type\": \"string\"},\n                        \"timeout\": {\"type\": \"integer\", \"default\": 30}\n                    },\n                    \"required\": [\"api_key\"]\n                }\n        \"\"\"\n        return None\n\n    # Plugin discovery\n\n    @classmethod\n    def discover_plugins(cls, path: Path) -&gt; List[type]:\n        \"\"\"Discover plugin classes in a directory.\n\n        Args:\n            path: Directory to search\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        plugins = []\n\n        if not path.exists() or not path.is_dir():\n            return plugins\n\n        # Import all Python files and look for BasePlugin subclasses\n        import importlib.util\n        import inspect\n\n        for file_path in path.glob(\"*.py\"):\n            if file_path.name.startswith(\"_\"):\n                continue\n\n            # Load the module\n            spec = importlib.util.spec_from_file_location(\n                file_path.stem, file_path\n            )\n            if spec and spec.loader:\n                module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(module)\n\n                # Find plugin classes\n                for name, obj in inspect.getmembers(module):\n                    if (inspect.isclass(obj) and \n                        issubclass(obj, BasePlugin) and \n                        obj != BasePlugin):\n                        plugins.append(obj)\n\n        return plugins\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.is_initialized","title":"<code>is_initialized</code>  <code>property</code>","text":"<p>Check if plugin is initialized.</p>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize plugin with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def __init__(self, config: Optional[PluginConfig] = None):\n    \"\"\"Initialize plugin with configuration.\n\n    Args:\n        config: Plugin configuration\n    \"\"\"\n    self.config = config or PluginConfig()\n    self._initialized = False\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.get_info","title":"<code>get_info()</code>  <code>abstractmethod</code>","text":"<p>Get plugin information.</p> <p>Returns:</p> Type Description <code>PluginInfo</code> <p>Plugin metadata and capabilities</p> Example <p>def get_info(self) -&gt; PluginInfo:     return PluginInfo(         name=\"my_plugin\",         version=\"1.0.0\",         description=\"Does amazing things\",         provides_tools=[\"calculator\", \"converter\"]     )</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef get_info(self) -&gt; PluginInfo:\n    \"\"\"Get plugin information.\n\n    Returns:\n        Plugin metadata and capabilities\n\n    Example:\n        def get_info(self) -&gt; PluginInfo:\n            return PluginInfo(\n                name=\"my_plugin\",\n                version=\"1.0.0\",\n                description=\"Does amazing things\",\n                provides_tools=[\"calculator\", \"converter\"]\n            )\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the plugin.</p> <p>Called once when the plugin is loaded. Use this for: - Setting up connections - Loading resources - Validating configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If initialization fails</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the plugin.\n\n    Called once when the plugin is loaded. Use this for:\n    - Setting up connections\n    - Loading resources\n    - Validating configuration\n\n    Raises:\n        Exception: If initialization fails\n    \"\"\"\n    self._initialized = True\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.cleanup","title":"<code>cleanup()</code>","text":"<p>Clean up plugin resources.</p> <p>Called when the plugin is being unloaded. Use this for: - Closing connections - Releasing resources - Saving state</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Clean up plugin resources.\n\n    Called when the plugin is being unloaded. Use this for:\n    - Closing connections\n    - Releasing resources\n    - Saving state\n    \"\"\"\n    self._initialized = False\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.get_tools","title":"<code>get_tools()</code>","text":"<p>Get tools provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[Tool]</code> <p>List of tool instances</p> Example <p>def get_tools(self):     return [         SearchTool(api_key=self.config.config[\"api_key\"]),         CalculatorTool()     ]</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Get tools provided by this plugin.\n\n    Returns:\n        List of tool instances\n\n    Example:\n        def get_tools(self):\n            return [\n                SearchTool(api_key=self.config.config[\"api_key\"]),\n                CalculatorTool()\n            ]\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.get_agents","title":"<code>get_agents()</code>","text":"<p>Get agent classes provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[type]</code> <p>List of agent classes (not instances)</p> Example <p>def get_agents(self):     return [ResearchAgent, AnalysisAgent]</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_agents(self) -&gt; List[type]:\n    \"\"\"Get agent classes provided by this plugin.\n\n    Returns:\n        List of agent classes (not instances)\n\n    Example:\n        def get_agents(self):\n            return [ResearchAgent, AnalysisAgent]\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.enhance_agent","title":"<code>enhance_agent(agent)</code>","text":"<p>Enhance an existing agent with plugin capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>Agent to enhance</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>Enhanced agent (can be same instance)</p> Example <p>def enhance_agent(self, agent):     # Add tools     for tool in self.get_tools():         agent.add_tool(tool)</p> <pre><code># Add custom reasoning\nagent.add_reasoning_pattern(\"research_mode\")\n\nreturn agent\n</code></pre> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n    \"\"\"Enhance an existing agent with plugin capabilities.\n\n    Args:\n        agent: Agent to enhance\n\n    Returns:\n        Enhanced agent (can be same instance)\n\n    Example:\n        def enhance_agent(self, agent):\n            # Add tools\n            for tool in self.get_tools():\n                agent.add_tool(tool)\n\n            # Add custom reasoning\n            agent.add_reasoning_pattern(\"research_mode\")\n\n            return agent\n    \"\"\"\n    return agent\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.get_providers","title":"<code>get_providers()</code>","text":"<p>Get LLM providers offered by this plugin.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping provider name to provider class</p> Example <p>def get_providers(self):     return {         \"custom_llm\": CustomLLMProvider,         \"local_model\": LocalModelProvider     }</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_providers(self) -&gt; Dict[str, type]:\n    \"\"\"Get LLM providers offered by this plugin.\n\n    Returns:\n        Dict mapping provider name to provider class\n\n    Example:\n        def get_providers(self):\n            return {\n                \"custom_llm\": CustomLLMProvider,\n                \"local_model\": LocalModelProvider\n            }\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.validate_config","title":"<code>validate_config()</code>","text":"<p>Validate plugin configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration is valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If configuration is invalid</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def validate_config(self) -&gt; bool:\n    \"\"\"Validate plugin configuration.\n\n    Returns:\n        True if configuration is valid\n\n    Raises:\n        ValueError: If configuration is invalid\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.get_config_schema","title":"<code>get_config_schema()</code>","text":"<p>Get JSON schema for plugin configuration.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>JSON schema dict or None</p> Example <p>def get_config_schema(self):     return {         \"type\": \"object\",         \"properties\": {             \"api_key\": {\"type\": \"string\"},             \"timeout\": {\"type\": \"integer\", \"default\": 30}         },         \"required\": [\"api_key\"]     }</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_config_schema(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get JSON schema for plugin configuration.\n\n    Returns:\n        JSON schema dict or None\n\n    Example:\n        def get_config_schema(self):\n            return {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"api_key\": {\"type\": \"string\"},\n                    \"timeout\": {\"type\": \"integer\", \"default\": 30}\n                },\n                \"required\": [\"api_key\"]\n            }\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.BasePlugin.discover_plugins","title":"<code>discover_plugins(path)</code>  <code>classmethod</code>","text":"<p>Discover plugin classes in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory to search</p> required <p>Returns:</p> Type Description <code>List[type]</code> <p>List of plugin classes found</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@classmethod\ndef discover_plugins(cls, path: Path) -&gt; List[type]:\n    \"\"\"Discover plugin classes in a directory.\n\n    Args:\n        path: Directory to search\n\n    Returns:\n        List of plugin classes found\n    \"\"\"\n    plugins = []\n\n    if not path.exists() or not path.is_dir():\n        return plugins\n\n    # Import all Python files and look for BasePlugin subclasses\n    import importlib.util\n    import inspect\n\n    for file_path in path.glob(\"*.py\"):\n        if file_path.name.startswith(\"_\"):\n            continue\n\n        # Load the module\n        spec = importlib.util.spec_from_file_location(\n            file_path.stem, file_path\n        )\n        if spec and spec.loader:\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n\n            # Find plugin classes\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin):\n                    plugins.append(obj)\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginInfo","title":"<code>PluginInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a plugin.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class PluginInfo(BaseModel):\n    \"\"\"Information about a plugin.\"\"\"\n\n    name: str = Field(..., description=\"Unique plugin name\")\n    version: str = Field(..., description=\"Plugin version (semantic)\")\n    description: str = Field(\"\", description=\"Plugin description\")\n    author: str = Field(\"\", description=\"Plugin author\")\n    author_email: str = Field(\"\", description=\"Author email\")\n    homepage: str = Field(\"\", description=\"Plugin homepage/docs\")\n    license: str = Field(\"Apache-2.0\", description=\"Plugin license\")\n\n    # Dependencies\n    requires_python: str = Field(\"&gt;=3.8\", description=\"Python version requirement\")\n    requires_agenticraft: str = Field(\"&gt;=0.1.0\", description=\"AgentiCraft version requirement\")\n    dependencies: List[str] = Field(default_factory=list, description=\"Python dependencies\")\n\n    # Capabilities\n    provides_tools: List[str] = Field(default_factory=list, description=\"Tool names provided\")\n    provides_agents: List[str] = Field(default_factory=list, description=\"Agent types provided\")\n    provides_providers: List[str] = Field(default_factory=list, description=\"LLM providers\")\n\n    # Configuration\n    config_schema: Optional[Dict[str, Any]] = Field(None, description=\"Configuration schema\")\n\n    class Config:\n        extra = \"allow\"\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginConfig","title":"<code>PluginConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base configuration for plugins.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class PluginConfig(BaseModel):\n    \"\"\"Base configuration for plugins.\"\"\"\n\n    enabled: bool = Field(True, description=\"Whether plugin is enabled\")\n    config: Dict[str, Any] = Field(default_factory=dict, description=\"Plugin-specific config\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.ToolPlugin","title":"<code>ToolPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Specialized base class for tool-only plugins.</p> <p>Simplifies creating plugins that only provide tools.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class ToolPlugin(BasePlugin):\n    \"\"\"Specialized base class for tool-only plugins.\n\n    Simplifies creating plugins that only provide tools.\n    \"\"\"\n\n    @abstractmethod\n    def create_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Create and return tool instances.\n\n        Returns:\n            List of configured tools\n        \"\"\"\n        pass\n\n    def get_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Get tools from create_tools method.\"\"\"\n        return self.create_tools()\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate info from tools.\"\"\"\n        tools = self.create_tools()\n        tool_names = [tool.name for tool in tools]\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description or f\"Provides tools: {', '.join(tool_names)}\",\n            author=self.author,\n            provides_tools=tool_names\n        )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.ToolPlugin.create_tools","title":"<code>create_tools()</code>  <code>abstractmethod</code>","text":"<p>Create and return tool instances.</p> <p>Returns:</p> Type Description <code>List[Tool]</code> <p>List of configured tools</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef create_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Create and return tool instances.\n\n    Returns:\n        List of configured tools\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.ToolPlugin.get_tools","title":"<code>get_tools()</code>","text":"<p>Get tools from create_tools method.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Get tools from create_tools method.\"\"\"\n    return self.create_tools()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.ToolPlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate info from tools.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate info from tools.\"\"\"\n    tools = self.create_tools()\n    tool_names = [tool.name for tool in tools]\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description or f\"Provides tools: {', '.join(tool_names)}\",\n        author=self.author,\n        provides_tools=tool_names\n    )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.AgentPlugin","title":"<code>AgentPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Specialized base class for agent-providing plugins.</p> <p>Simplifies creating plugins that provide custom agents.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class AgentPlugin(BasePlugin):\n    \"\"\"Specialized base class for agent-providing plugins.\n\n    Simplifies creating plugins that provide custom agents.\n    \"\"\"\n\n    @abstractmethod\n    def create_agents(self) -&gt; List[type]:\n        \"\"\"Create and return agent classes.\n\n        Returns:\n            List of agent classes\n        \"\"\"\n        pass\n\n    def get_agents(self) -&gt; List[type]:\n        \"\"\"Get agents from create_agents method.\"\"\"\n        return self.create_agents()\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate info from agents.\"\"\"\n        agents = self.create_agents()\n        agent_names = [agent.__name__ for agent in agents]\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description or f\"Provides agents: {', '.join(agent_names)}\",\n            author=self.author,\n            provides_agents=agent_names\n        )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.AgentPlugin.create_agents","title":"<code>create_agents()</code>  <code>abstractmethod</code>","text":"<p>Create and return agent classes.</p> <p>Returns:</p> Type Description <code>List[type]</code> <p>List of agent classes</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef create_agents(self) -&gt; List[type]:\n    \"\"\"Create and return agent classes.\n\n    Returns:\n        List of agent classes\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.AgentPlugin.get_agents","title":"<code>get_agents()</code>","text":"<p>Get agents from create_agents method.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_agents(self) -&gt; List[type]:\n    \"\"\"Get agents from create_agents method.\"\"\"\n    return self.create_agents()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.AgentPlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate info from agents.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate info from agents.\"\"\"\n    agents = self.create_agents()\n    agent_names = [agent.__name__ for agent in agents]\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description or f\"Provides agents: {', '.join(agent_names)}\",\n        author=self.author,\n        provides_agents=agent_names\n    )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.CompositePlugin","title":"<code>CompositePlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Base class for plugins that combine multiple capabilities.</p> <p>Useful for creating comprehensive plugins that provide tools, agents, providers, and enhancements.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class CompositePlugin(BasePlugin):\n    \"\"\"Base class for plugins that combine multiple capabilities.\n\n    Useful for creating comprehensive plugins that provide tools,\n    agents, providers, and enhancements.\n    \"\"\"\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate comprehensive plugin info.\"\"\"\n        tools = self.get_tools()\n        agents = self.get_agents()\n        providers = self.get_providers()\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description,\n            author=self.author,\n            provides_tools=[t.name for t in tools],\n            provides_agents=[a.__name__ for a in agents],\n            provides_providers=list(providers.keys()),\n            config_schema=self.get_config_schema()\n        )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.CompositePlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate comprehensive plugin info.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate comprehensive plugin info.\"\"\"\n    tools = self.get_tools()\n    agents = self.get_agents()\n    providers = self.get_providers()\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description,\n        author=self.author,\n        provides_tools=[t.name for t in tools],\n        provides_agents=[a.__name__ for a in agents],\n        provides_providers=list(providers.keys()),\n        config_schema=self.get_config_schema()\n    )\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader","title":"<code>PluginLoader</code>","text":"<p>Manages dynamic loading of AgentiCraft plugins.</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>class PluginLoader:\n    \"\"\"Manages dynamic loading of AgentiCraft plugins.\"\"\"\n\n    def __init__(\n        self,\n        plugin_dirs: Optional[List[Union[str, Path]]] = None,\n        auto_discover: bool = True\n    ):\n        \"\"\"Initialize plugin loader.\n\n        Args:\n            plugin_dirs: Directories to search for plugins\n            auto_discover: Whether to auto-discover plugins on init\n        \"\"\"\n        self.plugin_dirs = []\n        if plugin_dirs:\n            for dir_path in plugin_dirs:\n                self.add_plugin_directory(dir_path)\n\n        # Add default plugin directories\n        self._add_default_directories()\n\n        # Plugin storage\n        self._loaded_plugins: Dict[str, BasePlugin] = {}\n        self._plugin_classes: Dict[str, Type[BasePlugin]] = {}\n        self._plugin_modules: Dict[str, Any] = {}\n\n        # Registry for plugin management\n        self.registry = PluginRegistry()\n\n        # Auto-discover if requested\n        if auto_discover:\n            self.discover_all()\n\n    def _add_default_directories(self) -&gt; None:\n        \"\"\"Add default plugin directories.\"\"\"\n        # User plugins directory\n        user_plugins = Path.home() / \".agenticraft\" / \"plugins\"\n        if user_plugins.exists():\n            self.plugin_dirs.append(user_plugins)\n\n        # Built-in plugins\n        builtin_plugins = Path(__file__).parent / \"builtin\"\n        if builtin_plugins.exists():\n            self.plugin_dirs.append(builtin_plugins)\n\n        # Environment variable\n        import os\n        if env_dirs := os.getenv(\"AGENTICRAFT_PLUGIN_PATH\"):\n            for dir_path in env_dirs.split(\":\"):\n                if Path(dir_path).exists():\n                    self.plugin_dirs.append(Path(dir_path))\n\n    def add_plugin_directory(self, directory: Union[str, Path]) -&gt; None:\n        \"\"\"Add a directory to search for plugins.\n\n        Args:\n            directory: Path to plugin directory\n        \"\"\"\n        path = Path(directory).expanduser().resolve()\n        if path.exists() and path.is_dir():\n            if path not in self.plugin_dirs:\n                self.plugin_dirs.append(path)\n                logger.info(f\"Added plugin directory: {path}\")\n        else:\n            logger.warning(f\"Plugin directory does not exist: {path}\")\n\n    def discover_all(self) -&gt; List[str]:\n        \"\"\"Discover all plugins in configured directories.\n\n        Returns:\n            List of discovered plugin names\n        \"\"\"\n        discovered = []\n\n        for plugin_dir in self.plugin_dirs:\n            plugins = self.discover_in_directory(plugin_dir)\n            discovered.extend(plugins)\n\n        logger.info(f\"Discovered {len(discovered)} plugins\")\n        return discovered\n\n    def discover_in_directory(self, directory: Union[str, Path]) -&gt; List[str]:\n        \"\"\"Discover plugins in a specific directory.\n\n        Args:\n            directory: Directory to search\n\n        Returns:\n            List of discovered plugin names\n        \"\"\"\n        path = Path(directory)\n        discovered = []\n\n        if not path.exists() or not path.is_dir():\n            return discovered\n\n        # Look for Python files and packages\n        for item in path.iterdir():\n            if item.is_file() and item.suffix == \".py\" and not item.name.startswith(\"_\"):\n                # Single file plugin\n                try:\n                    plugin_classes = self._load_plugin_from_file(item)\n                    for plugin_class in plugin_classes:\n                        self._plugin_classes[plugin_class.name] = plugin_class\n                        discovered.append(plugin_class.name)\n                except Exception as e:\n                    logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n            elif item.is_dir() and not item.name.startswith(\"_\"):\n                # Package plugin\n                init_file = item / \"__init__.py\"\n                if init_file.exists():\n                    try:\n                        plugin_classes = self._load_plugin_from_package(item)\n                        for plugin_class in plugin_classes:\n                            self._plugin_classes[plugin_class.name] = plugin_class\n                            discovered.append(plugin_class.name)\n                    except Exception as e:\n                        logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n        return discovered\n\n    def _load_plugin_from_file(self, file_path: Path) -&gt; List[Type[BasePlugin]]:\n        \"\"\"Load plugin classes from a Python file.\n\n        Args:\n            file_path: Path to Python file\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        # Create module spec\n        module_name = f\"agenticraft_plugin_{file_path.stem}\"\n        spec = importlib.util.spec_from_file_location(module_name, file_path)\n\n        if not spec or not spec.loader:\n            raise PluginLoadError(f\"Cannot create module spec for {file_path}\")\n\n        # Load module\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = module\n        spec.loader.exec_module(module)\n\n        # Find plugin classes\n        plugin_classes = []\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and \n                issubclass(obj, BasePlugin) and \n                obj != BasePlugin and\n                obj.__module__ == module_name):\n                plugin_classes.append(obj)\n                self._plugin_modules[obj.name] = module\n\n        return plugin_classes\n\n    def _load_plugin_from_package(self, package_path: Path) -&gt; List[Type[BasePlugin]]:\n        \"\"\"Load plugin classes from a Python package.\n\n        Args:\n            package_path: Path to package directory\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        # Add to sys.path temporarily\n        parent_dir = str(package_path.parent)\n        if parent_dir not in sys.path:\n            sys.path.insert(0, parent_dir)\n            added_to_path = True\n        else:\n            added_to_path = False\n\n        try:\n            # Import the package\n            module_name = package_path.name\n            if module_name in sys.modules:\n                # Reload if already imported\n                module = importlib.reload(sys.modules[module_name])\n            else:\n                module = importlib.import_module(module_name)\n\n            # Find plugin classes\n            plugin_classes = []\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin):\n                    plugin_classes.append(obj)\n                    self._plugin_modules[obj.name] = module\n\n            # Also check for a 'plugin' attribute\n            if hasattr(module, 'plugin') and inspect.isclass(module.plugin):\n                if issubclass(module.plugin, BasePlugin):\n                    plugin_classes.append(module.plugin)\n                    self._plugin_modules[module.plugin.name] = module\n\n            return plugin_classes\n\n        finally:\n            # Clean up sys.path\n            if added_to_path:\n                sys.path.remove(parent_dir)\n\n    def load_plugin(\n        self,\n        plugin_name: str,\n        config: Optional[PluginConfig] = None\n    ) -&gt; BasePlugin:\n        \"\"\"Load and initialize a specific plugin.\n\n        Args:\n            plugin_name: Name of the plugin to load\n            config: Plugin configuration\n\n        Returns:\n            Initialized plugin instance\n\n        Raises:\n            PluginLoadError: If plugin cannot be loaded\n        \"\"\"\n        # Check if already loaded\n        if plugin_name in self._loaded_plugins:\n            return self._loaded_plugins[plugin_name]\n\n        # Check if plugin class is available\n        if plugin_name not in self._plugin_classes:\n            # Try to discover it\n            self.discover_all()\n            if plugin_name not in self._plugin_classes:\n                raise PluginLoadError(f\"Plugin '{plugin_name}' not found\")\n\n        # Create plugin instance\n        plugin_class = self._plugin_classes[plugin_name]\n        try:\n            plugin = plugin_class(config)\n\n            # Validate configuration\n            plugin.validate_config()\n\n            # Initialize plugin\n            plugin.initialize()\n\n            # Store loaded plugin\n            self._loaded_plugins[plugin_name] = plugin\n\n            # Register with registry\n            self.registry.register(plugin)\n\n            logger.info(f\"Loaded plugin: {plugin_name} v{plugin.version}\")\n            return plugin\n\n        except Exception as e:\n            raise PluginLoadError(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n    def load_all_discovered(\n        self,\n        configs: Optional[Dict[str, PluginConfig]] = None\n    ) -&gt; Dict[str, BasePlugin]:\n        \"\"\"Load all discovered plugins.\n\n        Args:\n            configs: Optional configurations for plugins\n\n        Returns:\n            Dict mapping plugin names to loaded instances\n        \"\"\"\n        configs = configs or {}\n        loaded = {}\n\n        for plugin_name in self._plugin_classes:\n            try:\n                config = configs.get(plugin_name)\n                plugin = self.load_plugin(plugin_name, config)\n                loaded[plugin_name] = plugin\n            except Exception as e:\n                logger.error(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n        return loaded\n\n    def unload_plugin(self, plugin_name: str) -&gt; None:\n        \"\"\"Unload a plugin and clean up its resources.\n\n        Args:\n            plugin_name: Name of plugin to unload\n        \"\"\"\n        if plugin_name not in self._loaded_plugins:\n            return\n\n        plugin = self._loaded_plugins[plugin_name]\n\n        # Cleanup plugin\n        try:\n            plugin.cleanup()\n        except Exception as e:\n            logger.error(f\"Error during plugin cleanup: {e}\")\n\n        # Unregister from registry\n        self.registry.unregister(plugin)\n\n        # Remove from loaded plugins\n        del self._loaded_plugins[plugin_name]\n\n        logger.info(f\"Unloaded plugin: {plugin_name}\")\n\n    def reload_plugin(\n        self,\n        plugin_name: str,\n        config: Optional[PluginConfig] = None\n    ) -&gt; BasePlugin:\n        \"\"\"Reload a plugin (unload and load again).\n\n        Args:\n            plugin_name: Name of plugin to reload\n            config: New configuration\n\n        Returns:\n            Reloaded plugin instance\n        \"\"\"\n        # Unload if loaded\n        if plugin_name in self._loaded_plugins:\n            self.unload_plugin(plugin_name)\n\n        # Reload module if available\n        if plugin_name in self._plugin_modules:\n            module = self._plugin_modules[plugin_name]\n            importlib.reload(module)\n\n            # Re-discover classes from reloaded module\n            plugin_classes = []\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin and\n                    obj.name == plugin_name):\n                    plugin_classes.append(obj)\n\n            if plugin_classes:\n                self._plugin_classes[plugin_name] = plugin_classes[0]\n\n        # Load plugin\n        return self.load_plugin(plugin_name, config)\n\n    def get_loaded_plugins(self) -&gt; Dict[str, BasePlugin]:\n        \"\"\"Get all currently loaded plugins.\n\n        Returns:\n            Dict mapping plugin names to instances\n        \"\"\"\n        return self._loaded_plugins.copy()\n\n    def get_discovered_plugins(self) -&gt; Dict[str, Type[BasePlugin]]:\n        \"\"\"Get all discovered plugin classes.\n\n        Returns:\n            Dict mapping plugin names to classes\n        \"\"\"\n        return self._plugin_classes.copy()\n\n    def get_plugin_info(self, plugin_name: str) -&gt; Optional[PluginInfo]:\n        \"\"\"Get information about a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n\n        Returns:\n            Plugin info or None if not found\n        \"\"\"\n        # Check loaded plugins first\n        if plugin_name in self._loaded_plugins:\n            return self._loaded_plugins[plugin_name].get_info()\n\n        # Check discovered plugins\n        if plugin_name in self._plugin_classes:\n            # Create temporary instance to get info\n            try:\n                plugin = self._plugin_classes[plugin_name]()\n                return plugin.get_info()\n            except Exception:\n                pass\n\n        return None\n\n    def list_plugins(self, loaded_only: bool = False) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all plugins with their status.\n\n        Args:\n            loaded_only: Only list loaded plugins\n\n        Returns:\n            List of plugin information dicts\n        \"\"\"\n        plugins = []\n\n        if loaded_only:\n            # Only loaded plugins\n            for name, plugin in self._loaded_plugins.items():\n                info = plugin.get_info()\n                plugins.append({\n                    \"name\": name,\n                    \"version\": info.version,\n                    \"description\": info.description,\n                    \"loaded\": True,\n                    \"provides\": {\n                        \"tools\": info.provides_tools,\n                        \"agents\": info.provides_agents,\n                        \"providers\": info.provides_providers\n                    }\n                })\n        else:\n            # All discovered plugins\n            for name, plugin_class in self._plugin_classes.items():\n                loaded = name in self._loaded_plugins\n\n                if loaded:\n                    info = self._loaded_plugins[name].get_info()\n                else:\n                    try:\n                        # Create temporary instance\n                        plugin = plugin_class()\n                        info = plugin.get_info()\n                    except Exception:\n                        # Minimal info if can't instantiate\n                        info = PluginInfo(\n                            name=name,\n                            version=getattr(plugin_class, 'version', 'unknown'),\n                            description=getattr(plugin_class, 'description', '')\n                        )\n\n                plugins.append({\n                    \"name\": name,\n                    \"version\": info.version,\n                    \"description\": info.description,\n                    \"loaded\": loaded,\n                    \"provides\": {\n                        \"tools\": info.provides_tools,\n                        \"agents\": info.provides_agents,\n                        \"providers\": info.provides_providers\n                    }\n                })\n\n        return plugins\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.__init__","title":"<code>__init__(plugin_dirs=None, auto_discover=True)</code>","text":"<p>Initialize plugin loader.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_dirs</code> <code>Optional[List[Union[str, Path]]]</code> <p>Directories to search for plugins</p> <code>None</code> <code>auto_discover</code> <code>bool</code> <p>Whether to auto-discover plugins on init</p> <code>True</code> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def __init__(\n    self,\n    plugin_dirs: Optional[List[Union[str, Path]]] = None,\n    auto_discover: bool = True\n):\n    \"\"\"Initialize plugin loader.\n\n    Args:\n        plugin_dirs: Directories to search for plugins\n        auto_discover: Whether to auto-discover plugins on init\n    \"\"\"\n    self.plugin_dirs = []\n    if plugin_dirs:\n        for dir_path in plugin_dirs:\n            self.add_plugin_directory(dir_path)\n\n    # Add default plugin directories\n    self._add_default_directories()\n\n    # Plugin storage\n    self._loaded_plugins: Dict[str, BasePlugin] = {}\n    self._plugin_classes: Dict[str, Type[BasePlugin]] = {}\n    self._plugin_modules: Dict[str, Any] = {}\n\n    # Registry for plugin management\n    self.registry = PluginRegistry()\n\n    # Auto-discover if requested\n    if auto_discover:\n        self.discover_all()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.add_plugin_directory","title":"<code>add_plugin_directory(directory)</code>","text":"<p>Add a directory to search for plugins.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, Path]</code> <p>Path to plugin directory</p> required Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def add_plugin_directory(self, directory: Union[str, Path]) -&gt; None:\n    \"\"\"Add a directory to search for plugins.\n\n    Args:\n        directory: Path to plugin directory\n    \"\"\"\n    path = Path(directory).expanduser().resolve()\n    if path.exists() and path.is_dir():\n        if path not in self.plugin_dirs:\n            self.plugin_dirs.append(path)\n            logger.info(f\"Added plugin directory: {path}\")\n    else:\n        logger.warning(f\"Plugin directory does not exist: {path}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.discover_all","title":"<code>discover_all()</code>","text":"<p>Discover all plugins in configured directories.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_all(self) -&gt; List[str]:\n    \"\"\"Discover all plugins in configured directories.\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    discovered = []\n\n    for plugin_dir in self.plugin_dirs:\n        plugins = self.discover_in_directory(plugin_dir)\n        discovered.extend(plugins)\n\n    logger.info(f\"Discovered {len(discovered)} plugins\")\n    return discovered\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.discover_in_directory","title":"<code>discover_in_directory(directory)</code>","text":"<p>Discover plugins in a specific directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, Path]</code> <p>Directory to search</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_in_directory(self, directory: Union[str, Path]) -&gt; List[str]:\n    \"\"\"Discover plugins in a specific directory.\n\n    Args:\n        directory: Directory to search\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    path = Path(directory)\n    discovered = []\n\n    if not path.exists() or not path.is_dir():\n        return discovered\n\n    # Look for Python files and packages\n    for item in path.iterdir():\n        if item.is_file() and item.suffix == \".py\" and not item.name.startswith(\"_\"):\n            # Single file plugin\n            try:\n                plugin_classes = self._load_plugin_from_file(item)\n                for plugin_class in plugin_classes:\n                    self._plugin_classes[plugin_class.name] = plugin_class\n                    discovered.append(plugin_class.name)\n            except Exception as e:\n                logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n        elif item.is_dir() and not item.name.startswith(\"_\"):\n            # Package plugin\n            init_file = item / \"__init__.py\"\n            if init_file.exists():\n                try:\n                    plugin_classes = self._load_plugin_from_package(item)\n                    for plugin_class in plugin_classes:\n                        self._plugin_classes[plugin_class.name] = plugin_class\n                        discovered.append(plugin_class.name)\n                except Exception as e:\n                    logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n    return discovered\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.load_plugin","title":"<code>load_plugin(plugin_name, config=None)</code>","text":"<p>Load and initialize a specific plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin to load</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Initialized plugin instance</p> <p>Raises:</p> Type Description <code>PluginLoadError</code> <p>If plugin cannot be loaded</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_plugin(\n    self,\n    plugin_name: str,\n    config: Optional[PluginConfig] = None\n) -&gt; BasePlugin:\n    \"\"\"Load and initialize a specific plugin.\n\n    Args:\n        plugin_name: Name of the plugin to load\n        config: Plugin configuration\n\n    Returns:\n        Initialized plugin instance\n\n    Raises:\n        PluginLoadError: If plugin cannot be loaded\n    \"\"\"\n    # Check if already loaded\n    if plugin_name in self._loaded_plugins:\n        return self._loaded_plugins[plugin_name]\n\n    # Check if plugin class is available\n    if plugin_name not in self._plugin_classes:\n        # Try to discover it\n        self.discover_all()\n        if plugin_name not in self._plugin_classes:\n            raise PluginLoadError(f\"Plugin '{plugin_name}' not found\")\n\n    # Create plugin instance\n    plugin_class = self._plugin_classes[plugin_name]\n    try:\n        plugin = plugin_class(config)\n\n        # Validate configuration\n        plugin.validate_config()\n\n        # Initialize plugin\n        plugin.initialize()\n\n        # Store loaded plugin\n        self._loaded_plugins[plugin_name] = plugin\n\n        # Register with registry\n        self.registry.register(plugin)\n\n        logger.info(f\"Loaded plugin: {plugin_name} v{plugin.version}\")\n        return plugin\n\n    except Exception as e:\n        raise PluginLoadError(f\"Failed to load plugin '{plugin_name}': {e}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.load_all_discovered","title":"<code>load_all_discovered(configs=None)</code>","text":"<p>Load all discovered plugins.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>Optional[Dict[str, PluginConfig]]</code> <p>Optional configurations for plugins</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, BasePlugin]</code> <p>Dict mapping plugin names to loaded instances</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_all_discovered(\n    self,\n    configs: Optional[Dict[str, PluginConfig]] = None\n) -&gt; Dict[str, BasePlugin]:\n    \"\"\"Load all discovered plugins.\n\n    Args:\n        configs: Optional configurations for plugins\n\n    Returns:\n        Dict mapping plugin names to loaded instances\n    \"\"\"\n    configs = configs or {}\n    loaded = {}\n\n    for plugin_name in self._plugin_classes:\n        try:\n            config = configs.get(plugin_name)\n            plugin = self.load_plugin(plugin_name, config)\n            loaded[plugin_name] = plugin\n        except Exception as e:\n            logger.error(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n    return loaded\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.unload_plugin","title":"<code>unload_plugin(plugin_name)</code>","text":"<p>Unload a plugin and clean up its resources.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of plugin to unload</p> required Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def unload_plugin(self, plugin_name: str) -&gt; None:\n    \"\"\"Unload a plugin and clean up its resources.\n\n    Args:\n        plugin_name: Name of plugin to unload\n    \"\"\"\n    if plugin_name not in self._loaded_plugins:\n        return\n\n    plugin = self._loaded_plugins[plugin_name]\n\n    # Cleanup plugin\n    try:\n        plugin.cleanup()\n    except Exception as e:\n        logger.error(f\"Error during plugin cleanup: {e}\")\n\n    # Unregister from registry\n    self.registry.unregister(plugin)\n\n    # Remove from loaded plugins\n    del self._loaded_plugins[plugin_name]\n\n    logger.info(f\"Unloaded plugin: {plugin_name}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.reload_plugin","title":"<code>reload_plugin(plugin_name, config=None)</code>","text":"<p>Reload a plugin (unload and load again).</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of plugin to reload</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>New configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Reloaded plugin instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def reload_plugin(\n    self,\n    plugin_name: str,\n    config: Optional[PluginConfig] = None\n) -&gt; BasePlugin:\n    \"\"\"Reload a plugin (unload and load again).\n\n    Args:\n        plugin_name: Name of plugin to reload\n        config: New configuration\n\n    Returns:\n        Reloaded plugin instance\n    \"\"\"\n    # Unload if loaded\n    if plugin_name in self._loaded_plugins:\n        self.unload_plugin(plugin_name)\n\n    # Reload module if available\n    if plugin_name in self._plugin_modules:\n        module = self._plugin_modules[plugin_name]\n        importlib.reload(module)\n\n        # Re-discover classes from reloaded module\n        plugin_classes = []\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and \n                issubclass(obj, BasePlugin) and \n                obj != BasePlugin and\n                obj.name == plugin_name):\n                plugin_classes.append(obj)\n\n        if plugin_classes:\n            self._plugin_classes[plugin_name] = plugin_classes[0]\n\n    # Load plugin\n    return self.load_plugin(plugin_name, config)\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.get_loaded_plugins","title":"<code>get_loaded_plugins()</code>","text":"<p>Get all currently loaded plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, BasePlugin]</code> <p>Dict mapping plugin names to instances</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_loaded_plugins(self) -&gt; Dict[str, BasePlugin]:\n    \"\"\"Get all currently loaded plugins.\n\n    Returns:\n        Dict mapping plugin names to instances\n    \"\"\"\n    return self._loaded_plugins.copy()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.get_discovered_plugins","title":"<code>get_discovered_plugins()</code>","text":"<p>Get all discovered plugin classes.</p> <p>Returns:</p> Type Description <code>Dict[str, Type[BasePlugin]]</code> <p>Dict mapping plugin names to classes</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_discovered_plugins(self) -&gt; Dict[str, Type[BasePlugin]]:\n    \"\"\"Get all discovered plugin classes.\n\n    Returns:\n        Dict mapping plugin names to classes\n    \"\"\"\n    return self._plugin_classes.copy()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.get_plugin_info","title":"<code>get_plugin_info(plugin_name)</code>","text":"<p>Get information about a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <p>Returns:</p> Type Description <code>Optional[PluginInfo]</code> <p>Plugin info or None if not found</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_plugin_info(self, plugin_name: str) -&gt; Optional[PluginInfo]:\n    \"\"\"Get information about a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n\n    Returns:\n        Plugin info or None if not found\n    \"\"\"\n    # Check loaded plugins first\n    if plugin_name in self._loaded_plugins:\n        return self._loaded_plugins[plugin_name].get_info()\n\n    # Check discovered plugins\n    if plugin_name in self._plugin_classes:\n        # Create temporary instance to get info\n        try:\n            plugin = self._plugin_classes[plugin_name]()\n            return plugin.get_info()\n        except Exception:\n            pass\n\n    return None\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoader.list_plugins","title":"<code>list_plugins(loaded_only=False)</code>","text":"<p>List all plugins with their status.</p> <p>Parameters:</p> Name Type Description Default <code>loaded_only</code> <code>bool</code> <p>Only list loaded plugins</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of plugin information dicts</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def list_plugins(self, loaded_only: bool = False) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all plugins with their status.\n\n    Args:\n        loaded_only: Only list loaded plugins\n\n    Returns:\n        List of plugin information dicts\n    \"\"\"\n    plugins = []\n\n    if loaded_only:\n        # Only loaded plugins\n        for name, plugin in self._loaded_plugins.items():\n            info = plugin.get_info()\n            plugins.append({\n                \"name\": name,\n                \"version\": info.version,\n                \"description\": info.description,\n                \"loaded\": True,\n                \"provides\": {\n                    \"tools\": info.provides_tools,\n                    \"agents\": info.provides_agents,\n                    \"providers\": info.provides_providers\n                }\n            })\n    else:\n        # All discovered plugins\n        for name, plugin_class in self._plugin_classes.items():\n            loaded = name in self._loaded_plugins\n\n            if loaded:\n                info = self._loaded_plugins[name].get_info()\n            else:\n                try:\n                    # Create temporary instance\n                    plugin = plugin_class()\n                    info = plugin.get_info()\n                except Exception:\n                    # Minimal info if can't instantiate\n                    info = PluginInfo(\n                        name=name,\n                        version=getattr(plugin_class, 'version', 'unknown'),\n                        description=getattr(plugin_class, 'description', '')\n                    )\n\n            plugins.append({\n                \"name\": name,\n                \"version\": info.version,\n                \"description\": info.description,\n                \"loaded\": loaded,\n                \"provides\": {\n                    \"tools\": info.provides_tools,\n                    \"agents\": info.provides_agents,\n                    \"providers\": info.provides_providers\n                }\n            })\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginLoadError","title":"<code>PluginLoadError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a plugin fails to load.</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>class PluginLoadError(Exception):\n    \"\"\"Raised when a plugin fails to load.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for managing AgentiCraft plugins.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>class PluginRegistry:\n    \"\"\"Central registry for managing AgentiCraft plugins.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize plugin registry.\"\"\"\n        # Registered plugins by name\n        self._plugins: Dict[str, BasePlugin] = {}\n\n        # Plugin metadata cache\n        self._plugin_info: Dict[str, PluginInfo] = {}\n\n        # Capability indexes\n        self._tools_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n        self._agents_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n        self._providers_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n\n        # Plugin dependencies\n        self._dependencies: Dict[str, Set[str]] = defaultdict(set)\n        self._dependents: Dict[str, Set[str]] = defaultdict(set)\n\n        # Lifecycle tracking\n        self._initialized_plugins: Set[str] = set()\n        self._load_order: List[str] = []\n\n    def register(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Register a plugin with the registry.\n\n        Args:\n            plugin: Plugin instance to register\n\n        Raises:\n            ValueError: If plugin with same name already registered\n        \"\"\"\n        info = plugin.get_info()\n\n        if info.name in self._plugins:\n            raise ValueError(f\"Plugin '{info.name}' already registered\")\n\n        # Store plugin and info\n        self._plugins[info.name] = plugin\n        self._plugin_info[info.name] = info\n\n        # Update capability indexes\n        self._update_indexes(plugin, info)\n\n        # Track dependencies\n        self._update_dependencies(info)\n\n        # Add to load order\n        self._load_order.append(info.name)\n\n        logger.info(f\"Registered plugin: {info.name} v{info.version}\")\n\n    def unregister(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Unregister a plugin from the registry.\n\n        Args:\n            plugin: Plugin instance to unregister\n        \"\"\"\n        info = plugin.get_info()\n\n        if info.name not in self._plugins:\n            return\n\n        # Check dependents\n        if info.name in self._dependents and self._dependents[info.name]:\n            dependents = \", \".join(self._dependents[info.name])\n            logger.warning(\n                f\"Unregistering plugin '{info.name}' which has dependents: {dependents}\"\n            )\n\n        # Remove from indexes\n        self._remove_from_indexes(plugin, info)\n\n        # Remove from tracking\n        del self._plugins[info.name]\n        del self._plugin_info[info.name]\n\n        if info.name in self._initialized_plugins:\n            self._initialized_plugins.remove(info.name)\n\n        if info.name in self._load_order:\n            self._load_order.remove(info.name)\n\n        # Clean up dependencies\n        if info.name in self._dependencies:\n            del self._dependencies[info.name]\n\n        for deps in self._dependents.values():\n            deps.discard(info.name)\n\n        logger.info(f\"Unregistered plugin: {info.name}\")\n\n    def _update_indexes(self, plugin: BasePlugin, info: PluginInfo) -&gt; None:\n        \"\"\"Update capability indexes for a plugin.\"\"\"\n        # Tool index\n        for tool_name in info.provides_tools:\n            self._tools_index[tool_name].append(plugin)\n\n        # Agent index\n        for agent_name in info.provides_agents:\n            self._agents_index[agent_name].append(plugin)\n\n        # Provider index\n        for provider_name in info.provides_providers:\n            self._providers_index[provider_name].append(plugin)\n\n    def _remove_from_indexes(self, plugin: BasePlugin, info: PluginInfo) -&gt; None:\n        \"\"\"Remove plugin from capability indexes.\"\"\"\n        # Tool index\n        for tool_name in info.provides_tools:\n            if plugin in self._tools_index[tool_name]:\n                self._tools_index[tool_name].remove(plugin)\n\n        # Agent index  \n        for agent_name in info.provides_agents:\n            if plugin in self._agents_index[agent_name]:\n                self._agents_index[agent_name].remove(plugin)\n\n        # Provider index\n        for provider_name in info.provides_providers:\n            if plugin in self._providers_index[provider_name]:\n                self._providers_index[provider_name].remove(plugin)\n\n    def _update_dependencies(self, info: PluginInfo) -&gt; None:\n        \"\"\"Update dependency tracking for a plugin.\"\"\"\n        # Parse dependencies from info\n        deps = set()\n        if hasattr(info, 'depends_on'):\n            deps.update(info.depends_on)\n\n        self._dependencies[info.name] = deps\n\n        # Update dependents\n        for dep in deps:\n            self._dependents[dep].add(info.name)\n\n    def get_plugin(self, name: str) -&gt; Optional[BasePlugin]:\n        \"\"\"Get a registered plugin by name.\n\n        Args:\n            name: Plugin name\n\n        Returns:\n            Plugin instance or None\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_plugin_info(self, name: str) -&gt; Optional[PluginInfo]:\n        \"\"\"Get plugin information by name.\n\n        Args:\n            name: Plugin name\n\n        Returns:\n            Plugin info or None\n        \"\"\"\n        return self._plugin_info.get(name)\n\n    def list_plugins(self) -&gt; List[PluginInfo]:\n        \"\"\"List all registered plugins.\n\n        Returns:\n            List of plugin information\n        \"\"\"\n        return list(self._plugin_info.values())\n\n    def get_plugins_by_capability(self, capability: str) -&gt; List[BasePlugin]:\n        \"\"\"Get plugins that provide a specific capability.\n\n        Args:\n            capability: Capability type (\"tools\", \"agents\", \"providers\")\n\n        Returns:\n            List of plugins with the capability\n        \"\"\"\n        plugins = []\n\n        if capability == \"tools\":\n            for plugin_list in self._tools_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        elif capability == \"agents\":\n            for plugin_list in self._agents_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        elif capability == \"providers\":\n            for plugin_list in self._providers_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        return plugins\n\n    def get_all_tools(self) -&gt; Dict[str, \"Tool\"]:\n        \"\"\"Get all tools from registered plugins.\n\n        Returns:\n            Dict mapping tool names to tool instances\n        \"\"\"\n        tools = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_tools = plugin.get_tools()\n                for tool in plugin_tools:\n                    if hasattr(tool, 'name'):\n                        tools[tool.name] = tool\n            except Exception as e:\n                logger.error(f\"Error getting tools from plugin '{plugin.name}': {e}\")\n\n        return tools\n\n    def get_all_agents(self) -&gt; Dict[str, type]:\n        \"\"\"Get all agent classes from registered plugins.\n\n        Returns:\n            Dict mapping agent names to agent classes\n        \"\"\"\n        agents = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_agents = plugin.get_agents()\n                for agent_class in plugin_agents:\n                    agents[agent_class.__name__] = agent_class\n            except Exception as e:\n                logger.error(f\"Error getting agents from plugin '{plugin.name}': {e}\")\n\n        return agents\n\n    def get_all_providers(self) -&gt; Dict[str, type]:\n        \"\"\"Get all providers from registered plugins.\n\n        Returns:\n            Dict mapping provider names to provider classes\n        \"\"\"\n        providers = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_providers = plugin.get_providers()\n                providers.update(plugin_providers)\n            except Exception as e:\n                logger.error(f\"Error getting providers from plugin '{plugin.name}': {e}\")\n\n        return providers\n\n    def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n        \"\"\"Apply all plugin enhancements to an agent.\n\n        Args:\n            agent: Agent to enhance\n\n        Returns:\n            Enhanced agent\n        \"\"\"\n        for plugin in self._plugins.values():\n            try:\n                agent = plugin.enhance_agent(agent)\n            except Exception as e:\n                logger.error(f\"Error enhancing agent with plugin '{plugin.name}': {e}\")\n\n        return agent\n\n    def initialize_all(self) -&gt; None:\n        \"\"\"Initialize all registered plugins in dependency order.\"\"\"\n        # Get initialization order\n        init_order = self._get_initialization_order()\n\n        for plugin_name in init_order:\n            if plugin_name in self._initialized_plugins:\n                continue\n\n            plugin = self._plugins[plugin_name]\n\n            try:\n                plugin.initialize()\n                self._initialized_plugins.add(plugin_name)\n                logger.info(f\"Initialized plugin: {plugin_name}\")\n            except Exception as e:\n                logger.error(f\"Failed to initialize plugin '{plugin_name}': {e}\")\n                raise\n\n    def cleanup_all(self) -&gt; None:\n        \"\"\"Clean up all plugins in reverse dependency order.\"\"\"\n        # Clean up in reverse order\n        cleanup_order = list(reversed(self._get_initialization_order()))\n\n        for plugin_name in cleanup_order:\n            if plugin_name not in self._initialized_plugins:\n                continue\n\n            plugin = self._plugins[plugin_name]\n\n            try:\n                plugin.cleanup()\n                self._initialized_plugins.remove(plugin_name)\n                logger.info(f\"Cleaned up plugin: {plugin_name}\")\n            except Exception as e:\n                logger.error(f\"Error cleaning up plugin '{plugin_name}': {e}\")\n\n    def _get_initialization_order(self) -&gt; List[str]:\n        \"\"\"Get plugin initialization order based on dependencies.\n\n        Returns:\n            List of plugin names in initialization order\n\n        Raises:\n            PluginDependencyError: If circular dependencies detected\n        \"\"\"\n        # Topological sort\n        visited = set()\n        temp_visited = set()\n        order = []\n\n        def visit(name: str):\n            if name in temp_visited:\n                raise PluginDependencyError(f\"Circular dependency detected involving '{name}'\")\n\n            if name in visited:\n                return\n\n            temp_visited.add(name)\n\n            # Visit dependencies first\n            if name in self._dependencies:\n                for dep in self._dependencies[name]:\n                    if dep in self._plugins:  # Only if dependency is registered\n                        visit(dep)\n\n            temp_visited.remove(name)\n            visited.add(name)\n            order.append(name)\n\n        # Visit all plugins\n        for plugin_name in self._plugins:\n            if plugin_name not in visited:\n                visit(plugin_name)\n\n        return order\n\n    def validate_dependencies(self) -&gt; List[str]:\n        \"\"\"Validate all plugin dependencies are satisfied.\n\n        Returns:\n            List of missing dependencies\n        \"\"\"\n        missing = []\n\n        for plugin_name, deps in self._dependencies.items():\n            for dep in deps:\n                if dep not in self._plugins:\n                    missing.append(f\"{plugin_name} requires {dep}\")\n\n        return missing\n\n    def get_plugin_stats(self) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics about registered plugins.\n\n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        total_tools = sum(len(info.provides_tools) for info in self._plugin_info.values())\n        total_agents = sum(len(info.provides_agents) for info in self._plugin_info.values())\n        total_providers = sum(len(info.provides_providers) for info in self._plugin_info.values())\n\n        return {\n            \"total_plugins\": len(self._plugins),\n            \"initialized_plugins\": len(self._initialized_plugins),\n            \"total_tools\": total_tools,\n            \"total_agents\": total_agents,\n            \"total_providers\": total_providers,\n            \"unique_tools\": len(self._tools_index),\n            \"unique_agents\": len(self._agents_index),\n            \"unique_providers\": len(self._providers_index),\n            \"plugins_with_dependencies\": len([d for d in self._dependencies.values() if d]),\n            \"missing_dependencies\": len(self.validate_dependencies())\n        }\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered plugins.\"\"\"\n        # Clean up first\n        self.cleanup_all()\n\n        # Clear all data\n        self._plugins.clear()\n        self._plugin_info.clear()\n        self._tools_index.clear()\n        self._agents_index.clear()\n        self._providers_index.clear()\n        self._dependencies.clear()\n        self._dependents.clear()\n        self._initialized_plugins.clear()\n        self._load_order.clear()\n\n        logger.info(\"Cleared plugin registry\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize plugin registry.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize plugin registry.\"\"\"\n    # Registered plugins by name\n    self._plugins: Dict[str, BasePlugin] = {}\n\n    # Plugin metadata cache\n    self._plugin_info: Dict[str, PluginInfo] = {}\n\n    # Capability indexes\n    self._tools_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n    self._agents_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n    self._providers_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n\n    # Plugin dependencies\n    self._dependencies: Dict[str, Set[str]] = defaultdict(set)\n    self._dependents: Dict[str, Set[str]] = defaultdict(set)\n\n    # Lifecycle tracking\n    self._initialized_plugins: Set[str] = set()\n    self._load_order: List[str] = []\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.register","title":"<code>register(plugin)</code>","text":"<p>Register a plugin with the registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If plugin with same name already registered</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def register(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin with the registry.\n\n    Args:\n        plugin: Plugin instance to register\n\n    Raises:\n        ValueError: If plugin with same name already registered\n    \"\"\"\n    info = plugin.get_info()\n\n    if info.name in self._plugins:\n        raise ValueError(f\"Plugin '{info.name}' already registered\")\n\n    # Store plugin and info\n    self._plugins[info.name] = plugin\n    self._plugin_info[info.name] = info\n\n    # Update capability indexes\n    self._update_indexes(plugin, info)\n\n    # Track dependencies\n    self._update_dependencies(info)\n\n    # Add to load order\n    self._load_order.append(info.name)\n\n    logger.info(f\"Registered plugin: {info.name} v{info.version}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.unregister","title":"<code>unregister(plugin)</code>","text":"<p>Unregister a plugin from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to unregister</p> required Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def unregister(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Unregister a plugin from the registry.\n\n    Args:\n        plugin: Plugin instance to unregister\n    \"\"\"\n    info = plugin.get_info()\n\n    if info.name not in self._plugins:\n        return\n\n    # Check dependents\n    if info.name in self._dependents and self._dependents[info.name]:\n        dependents = \", \".join(self._dependents[info.name])\n        logger.warning(\n            f\"Unregistering plugin '{info.name}' which has dependents: {dependents}\"\n        )\n\n    # Remove from indexes\n    self._remove_from_indexes(plugin, info)\n\n    # Remove from tracking\n    del self._plugins[info.name]\n    del self._plugin_info[info.name]\n\n    if info.name in self._initialized_plugins:\n        self._initialized_plugins.remove(info.name)\n\n    if info.name in self._load_order:\n        self._load_order.remove(info.name)\n\n    # Clean up dependencies\n    if info.name in self._dependencies:\n        del self._dependencies[info.name]\n\n    for deps in self._dependents.values():\n        deps.discard(info.name)\n\n    logger.info(f\"Unregistered plugin: {info.name}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_plugin","title":"<code>get_plugin(name)</code>","text":"<p>Get a registered plugin by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <p>Returns:</p> Type Description <code>Optional[BasePlugin]</code> <p>Plugin instance or None</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin(self, name: str) -&gt; Optional[BasePlugin]:\n    \"\"\"Get a registered plugin by name.\n\n    Args:\n        name: Plugin name\n\n    Returns:\n        Plugin instance or None\n    \"\"\"\n    return self._plugins.get(name)\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(name)</code>","text":"<p>Get plugin information by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <p>Returns:</p> Type Description <code>Optional[PluginInfo]</code> <p>Plugin info or None</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_info(self, name: str) -&gt; Optional[PluginInfo]:\n    \"\"\"Get plugin information by name.\n\n    Args:\n        name: Plugin name\n\n    Returns:\n        Plugin info or None\n    \"\"\"\n    return self._plugin_info.get(name)\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.list_plugins","title":"<code>list_plugins()</code>","text":"<p>List all registered plugins.</p> <p>Returns:</p> Type Description <code>List[PluginInfo]</code> <p>List of plugin information</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def list_plugins(self) -&gt; List[PluginInfo]:\n    \"\"\"List all registered plugins.\n\n    Returns:\n        List of plugin information\n    \"\"\"\n    return list(self._plugin_info.values())\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_plugins_by_capability","title":"<code>get_plugins_by_capability(capability)</code>","text":"<p>Get plugins that provide a specific capability.</p> <p>Parameters:</p> Name Type Description Default <code>capability</code> <code>str</code> <p>Capability type (\"tools\", \"agents\", \"providers\")</p> required <p>Returns:</p> Type Description <code>List[BasePlugin]</code> <p>List of plugins with the capability</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugins_by_capability(self, capability: str) -&gt; List[BasePlugin]:\n    \"\"\"Get plugins that provide a specific capability.\n\n    Args:\n        capability: Capability type (\"tools\", \"agents\", \"providers\")\n\n    Returns:\n        List of plugins with the capability\n    \"\"\"\n    plugins = []\n\n    if capability == \"tools\":\n        for plugin_list in self._tools_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    elif capability == \"agents\":\n        for plugin_list in self._agents_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    elif capability == \"providers\":\n        for plugin_list in self._providers_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_all_tools","title":"<code>get_all_tools()</code>","text":"<p>Get all tools from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Tool]</code> <p>Dict mapping tool names to tool instances</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_tools(self) -&gt; Dict[str, \"Tool\"]:\n    \"\"\"Get all tools from registered plugins.\n\n    Returns:\n        Dict mapping tool names to tool instances\n    \"\"\"\n    tools = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_tools = plugin.get_tools()\n            for tool in plugin_tools:\n                if hasattr(tool, 'name'):\n                    tools[tool.name] = tool\n        except Exception as e:\n            logger.error(f\"Error getting tools from plugin '{plugin.name}': {e}\")\n\n    return tools\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_all_agents","title":"<code>get_all_agents()</code>","text":"<p>Get all agent classes from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping agent names to agent classes</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_agents(self) -&gt; Dict[str, type]:\n    \"\"\"Get all agent classes from registered plugins.\n\n    Returns:\n        Dict mapping agent names to agent classes\n    \"\"\"\n    agents = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_agents = plugin.get_agents()\n            for agent_class in plugin_agents:\n                agents[agent_class.__name__] = agent_class\n        except Exception as e:\n            logger.error(f\"Error getting agents from plugin '{plugin.name}': {e}\")\n\n    return agents\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_all_providers","title":"<code>get_all_providers()</code>","text":"<p>Get all providers from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping provider names to provider classes</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_providers(self) -&gt; Dict[str, type]:\n    \"\"\"Get all providers from registered plugins.\n\n    Returns:\n        Dict mapping provider names to provider classes\n    \"\"\"\n    providers = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_providers = plugin.get_providers()\n            providers.update(plugin_providers)\n        except Exception as e:\n            logger.error(f\"Error getting providers from plugin '{plugin.name}': {e}\")\n\n    return providers\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.enhance_agent","title":"<code>enhance_agent(agent)</code>","text":"<p>Apply all plugin enhancements to an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>Agent to enhance</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>Enhanced agent</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n    \"\"\"Apply all plugin enhancements to an agent.\n\n    Args:\n        agent: Agent to enhance\n\n    Returns:\n        Enhanced agent\n    \"\"\"\n    for plugin in self._plugins.values():\n        try:\n            agent = plugin.enhance_agent(agent)\n        except Exception as e:\n            logger.error(f\"Error enhancing agent with plugin '{plugin.name}': {e}\")\n\n    return agent\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.initialize_all","title":"<code>initialize_all()</code>","text":"<p>Initialize all registered plugins in dependency order.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def initialize_all(self) -&gt; None:\n    \"\"\"Initialize all registered plugins in dependency order.\"\"\"\n    # Get initialization order\n    init_order = self._get_initialization_order()\n\n    for plugin_name in init_order:\n        if plugin_name in self._initialized_plugins:\n            continue\n\n        plugin = self._plugins[plugin_name]\n\n        try:\n            plugin.initialize()\n            self._initialized_plugins.add(plugin_name)\n            logger.info(f\"Initialized plugin: {plugin_name}\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize plugin '{plugin_name}': {e}\")\n            raise\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.cleanup_all","title":"<code>cleanup_all()</code>","text":"<p>Clean up all plugins in reverse dependency order.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def cleanup_all(self) -&gt; None:\n    \"\"\"Clean up all plugins in reverse dependency order.\"\"\"\n    # Clean up in reverse order\n    cleanup_order = list(reversed(self._get_initialization_order()))\n\n    for plugin_name in cleanup_order:\n        if plugin_name not in self._initialized_plugins:\n            continue\n\n        plugin = self._plugins[plugin_name]\n\n        try:\n            plugin.cleanup()\n            self._initialized_plugins.remove(plugin_name)\n            logger.info(f\"Cleaned up plugin: {plugin_name}\")\n        except Exception as e:\n            logger.error(f\"Error cleaning up plugin '{plugin_name}': {e}\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.validate_dependencies","title":"<code>validate_dependencies()</code>","text":"<p>Validate all plugin dependencies are satisfied.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of missing dependencies</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def validate_dependencies(self) -&gt; List[str]:\n    \"\"\"Validate all plugin dependencies are satisfied.\n\n    Returns:\n        List of missing dependencies\n    \"\"\"\n    missing = []\n\n    for plugin_name, deps in self._dependencies.items():\n        for dep in deps:\n            if dep not in self._plugins:\n                missing.append(f\"{plugin_name} requires {dep}\")\n\n    return missing\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.get_plugin_stats","title":"<code>get_plugin_stats()</code>","text":"<p>Get statistics about registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of statistics</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_stats(self) -&gt; Dict[str, Any]:\n    \"\"\"Get statistics about registered plugins.\n\n    Returns:\n        Dictionary of statistics\n    \"\"\"\n    total_tools = sum(len(info.provides_tools) for info in self._plugin_info.values())\n    total_agents = sum(len(info.provides_agents) for info in self._plugin_info.values())\n    total_providers = sum(len(info.provides_providers) for info in self._plugin_info.values())\n\n    return {\n        \"total_plugins\": len(self._plugins),\n        \"initialized_plugins\": len(self._initialized_plugins),\n        \"total_tools\": total_tools,\n        \"total_agents\": total_agents,\n        \"total_providers\": total_providers,\n        \"unique_tools\": len(self._tools_index),\n        \"unique_agents\": len(self._agents_index),\n        \"unique_providers\": len(self._providers_index),\n        \"plugins_with_dependencies\": len([d for d in self._dependencies.values() if d]),\n        \"missing_dependencies\": len(self.validate_dependencies())\n    }\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered plugins.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered plugins.\"\"\"\n    # Clean up first\n    self.cleanup_all()\n\n    # Clear all data\n    self._plugins.clear()\n    self._plugin_info.clear()\n    self._tools_index.clear()\n    self._agents_index.clear()\n    self._providers_index.clear()\n    self._dependencies.clear()\n    self._dependents.clear()\n    self._initialized_plugins.clear()\n    self._load_order.clear()\n\n    logger.info(\"Cleared plugin registry\")\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.PluginDependencyError","title":"<code>PluginDependencyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when plugin dependencies cannot be resolved.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>class PluginDependencyError(Exception):\n    \"\"\"Raised when plugin dependencies cannot be resolved.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.get_plugin_loader","title":"<code>get_plugin_loader()</code>","text":"<p>Get the global plugin loader instance.</p> <p>Returns:</p> Type Description <code>PluginLoader</code> <p>Global PluginLoader instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_plugin_loader() -&gt; PluginLoader:\n    \"\"\"Get the global plugin loader instance.\n\n    Returns:\n        Global PluginLoader instance\n    \"\"\"\n    global _global_loader\n    if _global_loader is None:\n        _global_loader = PluginLoader()\n    return _global_loader\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.load_plugin","title":"<code>load_plugin(name, config=None)</code>","text":"<p>Load a plugin using the global loader.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Loaded plugin instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_plugin(name: str, config: Optional[PluginConfig] = None) -&gt; BasePlugin:\n    \"\"\"Load a plugin using the global loader.\n\n    Args:\n        name: Plugin name\n        config: Plugin configuration\n\n    Returns:\n        Loaded plugin instance\n    \"\"\"\n    loader = get_plugin_loader()\n    return loader.load_plugin(name, config)\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.discover_plugins","title":"<code>discover_plugins()</code>","text":"<p>Discover all available plugins.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_plugins() -&gt; List[str]:\n    \"\"\"Discover all available plugins.\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    loader = get_plugin_loader()\n    return loader.discover_all()\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.get_plugin_registry","title":"<code>get_plugin_registry()</code>","text":"<p>Get the global plugin registry.</p> <p>Returns:</p> Type Description <code>PluginRegistry</code> <p>Global PluginRegistry instance</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_registry() -&gt; PluginRegistry:\n    \"\"\"Get the global plugin registry.\n\n    Returns:\n        Global PluginRegistry instance\n    \"\"\"\n    global _global_registry\n    if _global_registry is None:\n        _global_registry = PluginRegistry()\n    return _global_registry\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.register_plugin","title":"<code>register_plugin(plugin)</code>","text":"<p>Register a plugin with the global registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin to register</p> required Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def register_plugin(plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin with the global registry.\n\n    Args:\n        plugin: Plugin to register\n    \"\"\"\n    registry = get_plugin_registry()\n    registry.register(plugin)\n</code></pre>"},{"location":"reference/plugins/__init__/#agenticraft.plugins.get_all_plugin_tools","title":"<code>get_all_plugin_tools()</code>","text":"<p>Get all tools from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Tool]</code> <p>Dict of tool name to tool instance</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_plugin_tools() -&gt; Dict[str, \"Tool\"]:\n    \"\"\"Get all tools from registered plugins.\n\n    Returns:\n        Dict of tool name to tool instance\n    \"\"\"\n    registry = get_plugin_registry()\n    return registry.get_all_tools()\n</code></pre>"},{"location":"reference/plugins/base/","title":"Base","text":""},{"location":"reference/plugins/base/#agenticraft.plugins.base","title":"<code>base</code>","text":"<p>Base plugin functionality for AgentiCraft.</p> <p>This module provides the base classes and interfaces for creating AgentiCraft plugins. Plugins can extend agents, add tools, modify behavior, and integrate with external systems.</p> Example <p>Creating a basic plugin::</p> <pre><code>from agenticraft.plugins import BasePlugin\n\nclass WeatherPlugin(BasePlugin):\n    '''Adds weather capabilities to agents.'''\n\n    name = \"weather\"\n    version = \"1.0.0\"\n\n    def get_tools(self):\n        return [\n            WeatherTool(),\n            ForecastTool()\n        ]\n\n    def enhance_agent(self, agent):\n        agent.add_capability(\"weather_aware\")\n        return agent\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.PluginInfo","title":"<code>PluginInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a plugin.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class PluginInfo(BaseModel):\n    \"\"\"Information about a plugin.\"\"\"\n\n    name: str = Field(..., description=\"Unique plugin name\")\n    version: str = Field(..., description=\"Plugin version (semantic)\")\n    description: str = Field(\"\", description=\"Plugin description\")\n    author: str = Field(\"\", description=\"Plugin author\")\n    author_email: str = Field(\"\", description=\"Author email\")\n    homepage: str = Field(\"\", description=\"Plugin homepage/docs\")\n    license: str = Field(\"Apache-2.0\", description=\"Plugin license\")\n\n    # Dependencies\n    requires_python: str = Field(\"&gt;=3.8\", description=\"Python version requirement\")\n    requires_agenticraft: str = Field(\"&gt;=0.1.0\", description=\"AgentiCraft version requirement\")\n    dependencies: List[str] = Field(default_factory=list, description=\"Python dependencies\")\n\n    # Capabilities\n    provides_tools: List[str] = Field(default_factory=list, description=\"Tool names provided\")\n    provides_agents: List[str] = Field(default_factory=list, description=\"Agent types provided\")\n    provides_providers: List[str] = Field(default_factory=list, description=\"LLM providers\")\n\n    # Configuration\n    config_schema: Optional[Dict[str, Any]] = Field(None, description=\"Configuration schema\")\n\n    class Config:\n        extra = \"allow\"\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.PluginConfig","title":"<code>PluginConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base configuration for plugins.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class PluginConfig(BaseModel):\n    \"\"\"Base configuration for plugins.\"\"\"\n\n    enabled: bool = Field(True, description=\"Whether plugin is enabled\")\n    config: Dict[str, Any] = Field(default_factory=dict, description=\"Plugin-specific config\")\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin","title":"<code>BasePlugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all AgentiCraft plugins.</p> <p>Plugins must inherit from this class and implement required methods. They can optionally override lifecycle hooks to customize behavior.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class BasePlugin(ABC):\n    \"\"\"Base class for all AgentiCraft plugins.\n\n    Plugins must inherit from this class and implement required methods.\n    They can optionally override lifecycle hooks to customize behavior.\n    \"\"\"\n\n    # Plugin metadata (should be overridden by subclasses)\n    name: str = \"unnamed_plugin\"\n    version: str = \"0.0.0\"\n    description: str = \"\"\n    author: str = \"\"\n\n    def __init__(self, config: Optional[PluginConfig] = None):\n        \"\"\"Initialize plugin with configuration.\n\n        Args:\n            config: Plugin configuration\n        \"\"\"\n        self.config = config or PluginConfig()\n        self._initialized = False\n\n    @abstractmethod\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Get plugin information.\n\n        Returns:\n            Plugin metadata and capabilities\n\n        Example:\n            def get_info(self) -&gt; PluginInfo:\n                return PluginInfo(\n                    name=\"my_plugin\",\n                    version=\"1.0.0\",\n                    description=\"Does amazing things\",\n                    provides_tools=[\"calculator\", \"converter\"]\n                )\n        \"\"\"\n        pass\n\n    # Initialization and cleanup\n\n    def initialize(self) -&gt; None:\n        \"\"\"Initialize the plugin.\n\n        Called once when the plugin is loaded. Use this for:\n        - Setting up connections\n        - Loading resources\n        - Validating configuration\n\n        Raises:\n            Exception: If initialization fails\n        \"\"\"\n        self._initialized = True\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up plugin resources.\n\n        Called when the plugin is being unloaded. Use this for:\n        - Closing connections\n        - Releasing resources\n        - Saving state\n        \"\"\"\n        self._initialized = False\n\n    @property\n    def is_initialized(self) -&gt; bool:\n        \"\"\"Check if plugin is initialized.\"\"\"\n        return self._initialized\n\n    # Tool provision\n\n    def get_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Get tools provided by this plugin.\n\n        Returns:\n            List of tool instances\n\n        Example:\n            def get_tools(self):\n                return [\n                    SearchTool(api_key=self.config.config[\"api_key\"]),\n                    CalculatorTool()\n                ]\n        \"\"\"\n        return []\n\n    # Agent enhancement\n\n    def get_agents(self) -&gt; List[type]:\n        \"\"\"Get agent classes provided by this plugin.\n\n        Returns:\n            List of agent classes (not instances)\n\n        Example:\n            def get_agents(self):\n                return [ResearchAgent, AnalysisAgent]\n        \"\"\"\n        return []\n\n    def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n        \"\"\"Enhance an existing agent with plugin capabilities.\n\n        Args:\n            agent: Agent to enhance\n\n        Returns:\n            Enhanced agent (can be same instance)\n\n        Example:\n            def enhance_agent(self, agent):\n                # Add tools\n                for tool in self.get_tools():\n                    agent.add_tool(tool)\n\n                # Add custom reasoning\n                agent.add_reasoning_pattern(\"research_mode\")\n\n                return agent\n        \"\"\"\n        return agent\n\n    # Provider support\n\n    def get_providers(self) -&gt; Dict[str, type]:\n        \"\"\"Get LLM providers offered by this plugin.\n\n        Returns:\n            Dict mapping provider name to provider class\n\n        Example:\n            def get_providers(self):\n                return {\n                    \"custom_llm\": CustomLLMProvider,\n                    \"local_model\": LocalModelProvider\n                }\n        \"\"\"\n        return {}\n\n    # Configuration\n\n    def validate_config(self) -&gt; bool:\n        \"\"\"Validate plugin configuration.\n\n        Returns:\n            True if configuration is valid\n\n        Raises:\n            ValueError: If configuration is invalid\n        \"\"\"\n        return True\n\n    def get_config_schema(self) -&gt; Optional[Dict[str, Any]]:\n        \"\"\"Get JSON schema for plugin configuration.\n\n        Returns:\n            JSON schema dict or None\n\n        Example:\n            def get_config_schema(self):\n                return {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"api_key\": {\"type\": \"string\"},\n                        \"timeout\": {\"type\": \"integer\", \"default\": 30}\n                    },\n                    \"required\": [\"api_key\"]\n                }\n        \"\"\"\n        return None\n\n    # Plugin discovery\n\n    @classmethod\n    def discover_plugins(cls, path: Path) -&gt; List[type]:\n        \"\"\"Discover plugin classes in a directory.\n\n        Args:\n            path: Directory to search\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        plugins = []\n\n        if not path.exists() or not path.is_dir():\n            return plugins\n\n        # Import all Python files and look for BasePlugin subclasses\n        import importlib.util\n        import inspect\n\n        for file_path in path.glob(\"*.py\"):\n            if file_path.name.startswith(\"_\"):\n                continue\n\n            # Load the module\n            spec = importlib.util.spec_from_file_location(\n                file_path.stem, file_path\n            )\n            if spec and spec.loader:\n                module = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(module)\n\n                # Find plugin classes\n                for name, obj in inspect.getmembers(module):\n                    if (inspect.isclass(obj) and \n                        issubclass(obj, BasePlugin) and \n                        obj != BasePlugin):\n                        plugins.append(obj)\n\n        return plugins\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.is_initialized","title":"<code>is_initialized</code>  <code>property</code>","text":"<p>Check if plugin is initialized.</p>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize plugin with configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def __init__(self, config: Optional[PluginConfig] = None):\n    \"\"\"Initialize plugin with configuration.\n\n    Args:\n        config: Plugin configuration\n    \"\"\"\n    self.config = config or PluginConfig()\n    self._initialized = False\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.get_info","title":"<code>get_info()</code>  <code>abstractmethod</code>","text":"<p>Get plugin information.</p> <p>Returns:</p> Type Description <code>PluginInfo</code> <p>Plugin metadata and capabilities</p> Example <p>def get_info(self) -&gt; PluginInfo:     return PluginInfo(         name=\"my_plugin\",         version=\"1.0.0\",         description=\"Does amazing things\",         provides_tools=[\"calculator\", \"converter\"]     )</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef get_info(self) -&gt; PluginInfo:\n    \"\"\"Get plugin information.\n\n    Returns:\n        Plugin metadata and capabilities\n\n    Example:\n        def get_info(self) -&gt; PluginInfo:\n            return PluginInfo(\n                name=\"my_plugin\",\n                version=\"1.0.0\",\n                description=\"Does amazing things\",\n                provides_tools=[\"calculator\", \"converter\"]\n            )\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the plugin.</p> <p>Called once when the plugin is loaded. Use this for: - Setting up connections - Loading resources - Validating configuration</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If initialization fails</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the plugin.\n\n    Called once when the plugin is loaded. Use this for:\n    - Setting up connections\n    - Loading resources\n    - Validating configuration\n\n    Raises:\n        Exception: If initialization fails\n    \"\"\"\n    self._initialized = True\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.cleanup","title":"<code>cleanup()</code>","text":"<p>Clean up plugin resources.</p> <p>Called when the plugin is being unloaded. Use this for: - Closing connections - Releasing resources - Saving state</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Clean up plugin resources.\n\n    Called when the plugin is being unloaded. Use this for:\n    - Closing connections\n    - Releasing resources\n    - Saving state\n    \"\"\"\n    self._initialized = False\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.get_tools","title":"<code>get_tools()</code>","text":"<p>Get tools provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[Tool]</code> <p>List of tool instances</p> Example <p>def get_tools(self):     return [         SearchTool(api_key=self.config.config[\"api_key\"]),         CalculatorTool()     ]</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Get tools provided by this plugin.\n\n    Returns:\n        List of tool instances\n\n    Example:\n        def get_tools(self):\n            return [\n                SearchTool(api_key=self.config.config[\"api_key\"]),\n                CalculatorTool()\n            ]\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.get_agents","title":"<code>get_agents()</code>","text":"<p>Get agent classes provided by this plugin.</p> <p>Returns:</p> Type Description <code>List[type]</code> <p>List of agent classes (not instances)</p> Example <p>def get_agents(self):     return [ResearchAgent, AnalysisAgent]</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_agents(self) -&gt; List[type]:\n    \"\"\"Get agent classes provided by this plugin.\n\n    Returns:\n        List of agent classes (not instances)\n\n    Example:\n        def get_agents(self):\n            return [ResearchAgent, AnalysisAgent]\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.enhance_agent","title":"<code>enhance_agent(agent)</code>","text":"<p>Enhance an existing agent with plugin capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>Agent to enhance</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>Enhanced agent (can be same instance)</p> Example <p>def enhance_agent(self, agent):     # Add tools     for tool in self.get_tools():         agent.add_tool(tool)</p> <pre><code># Add custom reasoning\nagent.add_reasoning_pattern(\"research_mode\")\n\nreturn agent\n</code></pre> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n    \"\"\"Enhance an existing agent with plugin capabilities.\n\n    Args:\n        agent: Agent to enhance\n\n    Returns:\n        Enhanced agent (can be same instance)\n\n    Example:\n        def enhance_agent(self, agent):\n            # Add tools\n            for tool in self.get_tools():\n                agent.add_tool(tool)\n\n            # Add custom reasoning\n            agent.add_reasoning_pattern(\"research_mode\")\n\n            return agent\n    \"\"\"\n    return agent\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.get_providers","title":"<code>get_providers()</code>","text":"<p>Get LLM providers offered by this plugin.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping provider name to provider class</p> Example <p>def get_providers(self):     return {         \"custom_llm\": CustomLLMProvider,         \"local_model\": LocalModelProvider     }</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_providers(self) -&gt; Dict[str, type]:\n    \"\"\"Get LLM providers offered by this plugin.\n\n    Returns:\n        Dict mapping provider name to provider class\n\n    Example:\n        def get_providers(self):\n            return {\n                \"custom_llm\": CustomLLMProvider,\n                \"local_model\": LocalModelProvider\n            }\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.validate_config","title":"<code>validate_config()</code>","text":"<p>Validate plugin configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration is valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If configuration is invalid</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def validate_config(self) -&gt; bool:\n    \"\"\"Validate plugin configuration.\n\n    Returns:\n        True if configuration is valid\n\n    Raises:\n        ValueError: If configuration is invalid\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.get_config_schema","title":"<code>get_config_schema()</code>","text":"<p>Get JSON schema for plugin configuration.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>JSON schema dict or None</p> Example <p>def get_config_schema(self):     return {         \"type\": \"object\",         \"properties\": {             \"api_key\": {\"type\": \"string\"},             \"timeout\": {\"type\": \"integer\", \"default\": 30}         },         \"required\": [\"api_key\"]     }</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_config_schema(self) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get JSON schema for plugin configuration.\n\n    Returns:\n        JSON schema dict or None\n\n    Example:\n        def get_config_schema(self):\n            return {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"api_key\": {\"type\": \"string\"},\n                    \"timeout\": {\"type\": \"integer\", \"default\": 30}\n                },\n                \"required\": [\"api_key\"]\n            }\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.BasePlugin.discover_plugins","title":"<code>discover_plugins(path)</code>  <code>classmethod</code>","text":"<p>Discover plugin classes in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Directory to search</p> required <p>Returns:</p> Type Description <code>List[type]</code> <p>List of plugin classes found</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@classmethod\ndef discover_plugins(cls, path: Path) -&gt; List[type]:\n    \"\"\"Discover plugin classes in a directory.\n\n    Args:\n        path: Directory to search\n\n    Returns:\n        List of plugin classes found\n    \"\"\"\n    plugins = []\n\n    if not path.exists() or not path.is_dir():\n        return plugins\n\n    # Import all Python files and look for BasePlugin subclasses\n    import importlib.util\n    import inspect\n\n    for file_path in path.glob(\"*.py\"):\n        if file_path.name.startswith(\"_\"):\n            continue\n\n        # Load the module\n        spec = importlib.util.spec_from_file_location(\n            file_path.stem, file_path\n        )\n        if spec and spec.loader:\n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n\n            # Find plugin classes\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin):\n                    plugins.append(obj)\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.ToolPlugin","title":"<code>ToolPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Specialized base class for tool-only plugins.</p> <p>Simplifies creating plugins that only provide tools.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class ToolPlugin(BasePlugin):\n    \"\"\"Specialized base class for tool-only plugins.\n\n    Simplifies creating plugins that only provide tools.\n    \"\"\"\n\n    @abstractmethod\n    def create_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Create and return tool instances.\n\n        Returns:\n            List of configured tools\n        \"\"\"\n        pass\n\n    def get_tools(self) -&gt; List[\"Tool\"]:\n        \"\"\"Get tools from create_tools method.\"\"\"\n        return self.create_tools()\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate info from tools.\"\"\"\n        tools = self.create_tools()\n        tool_names = [tool.name for tool in tools]\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description or f\"Provides tools: {', '.join(tool_names)}\",\n            author=self.author,\n            provides_tools=tool_names\n        )\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.ToolPlugin.create_tools","title":"<code>create_tools()</code>  <code>abstractmethod</code>","text":"<p>Create and return tool instances.</p> <p>Returns:</p> Type Description <code>List[Tool]</code> <p>List of configured tools</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef create_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Create and return tool instances.\n\n    Returns:\n        List of configured tools\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.ToolPlugin.get_tools","title":"<code>get_tools()</code>","text":"<p>Get tools from create_tools method.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_tools(self) -&gt; List[\"Tool\"]:\n    \"\"\"Get tools from create_tools method.\"\"\"\n    return self.create_tools()\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.ToolPlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate info from tools.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate info from tools.\"\"\"\n    tools = self.create_tools()\n    tool_names = [tool.name for tool in tools]\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description or f\"Provides tools: {', '.join(tool_names)}\",\n        author=self.author,\n        provides_tools=tool_names\n    )\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.AgentPlugin","title":"<code>AgentPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Specialized base class for agent-providing plugins.</p> <p>Simplifies creating plugins that provide custom agents.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class AgentPlugin(BasePlugin):\n    \"\"\"Specialized base class for agent-providing plugins.\n\n    Simplifies creating plugins that provide custom agents.\n    \"\"\"\n\n    @abstractmethod\n    def create_agents(self) -&gt; List[type]:\n        \"\"\"Create and return agent classes.\n\n        Returns:\n            List of agent classes\n        \"\"\"\n        pass\n\n    def get_agents(self) -&gt; List[type]:\n        \"\"\"Get agents from create_agents method.\"\"\"\n        return self.create_agents()\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate info from agents.\"\"\"\n        agents = self.create_agents()\n        agent_names = [agent.__name__ for agent in agents]\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description or f\"Provides agents: {', '.join(agent_names)}\",\n            author=self.author,\n            provides_agents=agent_names\n        )\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.AgentPlugin.create_agents","title":"<code>create_agents()</code>  <code>abstractmethod</code>","text":"<p>Create and return agent classes.</p> <p>Returns:</p> Type Description <code>List[type]</code> <p>List of agent classes</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>@abstractmethod\ndef create_agents(self) -&gt; List[type]:\n    \"\"\"Create and return agent classes.\n\n    Returns:\n        List of agent classes\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.AgentPlugin.get_agents","title":"<code>get_agents()</code>","text":"<p>Get agents from create_agents method.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_agents(self) -&gt; List[type]:\n    \"\"\"Get agents from create_agents method.\"\"\"\n    return self.create_agents()\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.AgentPlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate info from agents.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate info from agents.\"\"\"\n    agents = self.create_agents()\n    agent_names = [agent.__name__ for agent in agents]\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description or f\"Provides agents: {', '.join(agent_names)}\",\n        author=self.author,\n        provides_agents=agent_names\n    )\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.CompositePlugin","title":"<code>CompositePlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Base class for plugins that combine multiple capabilities.</p> <p>Useful for creating comprehensive plugins that provide tools, agents, providers, and enhancements.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>class CompositePlugin(BasePlugin):\n    \"\"\"Base class for plugins that combine multiple capabilities.\n\n    Useful for creating comprehensive plugins that provide tools,\n    agents, providers, and enhancements.\n    \"\"\"\n\n    def get_info(self) -&gt; PluginInfo:\n        \"\"\"Generate comprehensive plugin info.\"\"\"\n        tools = self.get_tools()\n        agents = self.get_agents()\n        providers = self.get_providers()\n\n        return PluginInfo(\n            name=self.name,\n            version=self.version,\n            description=self.description,\n            author=self.author,\n            provides_tools=[t.name for t in tools],\n            provides_agents=[a.__name__ for a in agents],\n            provides_providers=list(providers.keys()),\n            config_schema=self.get_config_schema()\n        )\n</code></pre>"},{"location":"reference/plugins/base/#agenticraft.plugins.base.CompositePlugin.get_info","title":"<code>get_info()</code>","text":"<p>Generate comprehensive plugin info.</p> Source code in <code>agenticraft/plugins/base.py</code> <pre><code>def get_info(self) -&gt; PluginInfo:\n    \"\"\"Generate comprehensive plugin info.\"\"\"\n    tools = self.get_tools()\n    agents = self.get_agents()\n    providers = self.get_providers()\n\n    return PluginInfo(\n        name=self.name,\n        version=self.version,\n        description=self.description,\n        author=self.author,\n        provides_tools=[t.name for t in tools],\n        provides_agents=[a.__name__ for a in agents],\n        provides_providers=list(providers.keys()),\n        config_schema=self.get_config_schema()\n    )\n</code></pre>"},{"location":"reference/plugins/loader/","title":"Loader","text":""},{"location":"reference/plugins/loader/#agenticraft.plugins.loader","title":"<code>loader</code>","text":"<p>Dynamic plugin loader for AgentiCraft.</p> <p>This module provides functionality for discovering, loading, and managing plugins at runtime. It supports loading plugins from: - Python packages - Plugin directories - Individual plugin files - Remote plugin repositories (future)</p> Example <p>Loading plugins::</p> <pre><code>from agenticraft.plugins import PluginLoader\n\nloader = PluginLoader()\n\n# Load from directory\nloader.load_from_directory(\"~/.agenticraft/plugins\")\n\n# Load specific plugin\nplugin = loader.load_plugin(\"weather_plugin\")\n\n# Get all loaded plugins\nplugins = loader.get_loaded_plugins()\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoadError","title":"<code>PluginLoadError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a plugin fails to load.</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>class PluginLoadError(Exception):\n    \"\"\"Raised when a plugin fails to load.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader","title":"<code>PluginLoader</code>","text":"<p>Manages dynamic loading of AgentiCraft plugins.</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>class PluginLoader:\n    \"\"\"Manages dynamic loading of AgentiCraft plugins.\"\"\"\n\n    def __init__(\n        self,\n        plugin_dirs: Optional[List[Union[str, Path]]] = None,\n        auto_discover: bool = True\n    ):\n        \"\"\"Initialize plugin loader.\n\n        Args:\n            plugin_dirs: Directories to search for plugins\n            auto_discover: Whether to auto-discover plugins on init\n        \"\"\"\n        self.plugin_dirs = []\n        if plugin_dirs:\n            for dir_path in plugin_dirs:\n                self.add_plugin_directory(dir_path)\n\n        # Add default plugin directories\n        self._add_default_directories()\n\n        # Plugin storage\n        self._loaded_plugins: Dict[str, BasePlugin] = {}\n        self._plugin_classes: Dict[str, Type[BasePlugin]] = {}\n        self._plugin_modules: Dict[str, Any] = {}\n\n        # Registry for plugin management\n        self.registry = PluginRegistry()\n\n        # Auto-discover if requested\n        if auto_discover:\n            self.discover_all()\n\n    def _add_default_directories(self) -&gt; None:\n        \"\"\"Add default plugin directories.\"\"\"\n        # User plugins directory\n        user_plugins = Path.home() / \".agenticraft\" / \"plugins\"\n        if user_plugins.exists():\n            self.plugin_dirs.append(user_plugins)\n\n        # Built-in plugins\n        builtin_plugins = Path(__file__).parent / \"builtin\"\n        if builtin_plugins.exists():\n            self.plugin_dirs.append(builtin_plugins)\n\n        # Environment variable\n        import os\n        if env_dirs := os.getenv(\"AGENTICRAFT_PLUGIN_PATH\"):\n            for dir_path in env_dirs.split(\":\"):\n                if Path(dir_path).exists():\n                    self.plugin_dirs.append(Path(dir_path))\n\n    def add_plugin_directory(self, directory: Union[str, Path]) -&gt; None:\n        \"\"\"Add a directory to search for plugins.\n\n        Args:\n            directory: Path to plugin directory\n        \"\"\"\n        path = Path(directory).expanduser().resolve()\n        if path.exists() and path.is_dir():\n            if path not in self.plugin_dirs:\n                self.plugin_dirs.append(path)\n                logger.info(f\"Added plugin directory: {path}\")\n        else:\n            logger.warning(f\"Plugin directory does not exist: {path}\")\n\n    def discover_all(self) -&gt; List[str]:\n        \"\"\"Discover all plugins in configured directories.\n\n        Returns:\n            List of discovered plugin names\n        \"\"\"\n        discovered = []\n\n        for plugin_dir in self.plugin_dirs:\n            plugins = self.discover_in_directory(plugin_dir)\n            discovered.extend(plugins)\n\n        logger.info(f\"Discovered {len(discovered)} plugins\")\n        return discovered\n\n    def discover_in_directory(self, directory: Union[str, Path]) -&gt; List[str]:\n        \"\"\"Discover plugins in a specific directory.\n\n        Args:\n            directory: Directory to search\n\n        Returns:\n            List of discovered plugin names\n        \"\"\"\n        path = Path(directory)\n        discovered = []\n\n        if not path.exists() or not path.is_dir():\n            return discovered\n\n        # Look for Python files and packages\n        for item in path.iterdir():\n            if item.is_file() and item.suffix == \".py\" and not item.name.startswith(\"_\"):\n                # Single file plugin\n                try:\n                    plugin_classes = self._load_plugin_from_file(item)\n                    for plugin_class in plugin_classes:\n                        self._plugin_classes[plugin_class.name] = plugin_class\n                        discovered.append(plugin_class.name)\n                except Exception as e:\n                    logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n            elif item.is_dir() and not item.name.startswith(\"_\"):\n                # Package plugin\n                init_file = item / \"__init__.py\"\n                if init_file.exists():\n                    try:\n                        plugin_classes = self._load_plugin_from_package(item)\n                        for plugin_class in plugin_classes:\n                            self._plugin_classes[plugin_class.name] = plugin_class\n                            discovered.append(plugin_class.name)\n                    except Exception as e:\n                        logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n        return discovered\n\n    def _load_plugin_from_file(self, file_path: Path) -&gt; List[Type[BasePlugin]]:\n        \"\"\"Load plugin classes from a Python file.\n\n        Args:\n            file_path: Path to Python file\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        # Create module spec\n        module_name = f\"agenticraft_plugin_{file_path.stem}\"\n        spec = importlib.util.spec_from_file_location(module_name, file_path)\n\n        if not spec or not spec.loader:\n            raise PluginLoadError(f\"Cannot create module spec for {file_path}\")\n\n        # Load module\n        module = importlib.util.module_from_spec(spec)\n        sys.modules[module_name] = module\n        spec.loader.exec_module(module)\n\n        # Find plugin classes\n        plugin_classes = []\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and \n                issubclass(obj, BasePlugin) and \n                obj != BasePlugin and\n                obj.__module__ == module_name):\n                plugin_classes.append(obj)\n                self._plugin_modules[obj.name] = module\n\n        return plugin_classes\n\n    def _load_plugin_from_package(self, package_path: Path) -&gt; List[Type[BasePlugin]]:\n        \"\"\"Load plugin classes from a Python package.\n\n        Args:\n            package_path: Path to package directory\n\n        Returns:\n            List of plugin classes found\n        \"\"\"\n        # Add to sys.path temporarily\n        parent_dir = str(package_path.parent)\n        if parent_dir not in sys.path:\n            sys.path.insert(0, parent_dir)\n            added_to_path = True\n        else:\n            added_to_path = False\n\n        try:\n            # Import the package\n            module_name = package_path.name\n            if module_name in sys.modules:\n                # Reload if already imported\n                module = importlib.reload(sys.modules[module_name])\n            else:\n                module = importlib.import_module(module_name)\n\n            # Find plugin classes\n            plugin_classes = []\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin):\n                    plugin_classes.append(obj)\n                    self._plugin_modules[obj.name] = module\n\n            # Also check for a 'plugin' attribute\n            if hasattr(module, 'plugin') and inspect.isclass(module.plugin):\n                if issubclass(module.plugin, BasePlugin):\n                    plugin_classes.append(module.plugin)\n                    self._plugin_modules[module.plugin.name] = module\n\n            return plugin_classes\n\n        finally:\n            # Clean up sys.path\n            if added_to_path:\n                sys.path.remove(parent_dir)\n\n    def load_plugin(\n        self,\n        plugin_name: str,\n        config: Optional[PluginConfig] = None\n    ) -&gt; BasePlugin:\n        \"\"\"Load and initialize a specific plugin.\n\n        Args:\n            plugin_name: Name of the plugin to load\n            config: Plugin configuration\n\n        Returns:\n            Initialized plugin instance\n\n        Raises:\n            PluginLoadError: If plugin cannot be loaded\n        \"\"\"\n        # Check if already loaded\n        if plugin_name in self._loaded_plugins:\n            return self._loaded_plugins[plugin_name]\n\n        # Check if plugin class is available\n        if plugin_name not in self._plugin_classes:\n            # Try to discover it\n            self.discover_all()\n            if plugin_name not in self._plugin_classes:\n                raise PluginLoadError(f\"Plugin '{plugin_name}' not found\")\n\n        # Create plugin instance\n        plugin_class = self._plugin_classes[plugin_name]\n        try:\n            plugin = plugin_class(config)\n\n            # Validate configuration\n            plugin.validate_config()\n\n            # Initialize plugin\n            plugin.initialize()\n\n            # Store loaded plugin\n            self._loaded_plugins[plugin_name] = plugin\n\n            # Register with registry\n            self.registry.register(plugin)\n\n            logger.info(f\"Loaded plugin: {plugin_name} v{plugin.version}\")\n            return plugin\n\n        except Exception as e:\n            raise PluginLoadError(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n    def load_all_discovered(\n        self,\n        configs: Optional[Dict[str, PluginConfig]] = None\n    ) -&gt; Dict[str, BasePlugin]:\n        \"\"\"Load all discovered plugins.\n\n        Args:\n            configs: Optional configurations for plugins\n\n        Returns:\n            Dict mapping plugin names to loaded instances\n        \"\"\"\n        configs = configs or {}\n        loaded = {}\n\n        for plugin_name in self._plugin_classes:\n            try:\n                config = configs.get(plugin_name)\n                plugin = self.load_plugin(plugin_name, config)\n                loaded[plugin_name] = plugin\n            except Exception as e:\n                logger.error(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n        return loaded\n\n    def unload_plugin(self, plugin_name: str) -&gt; None:\n        \"\"\"Unload a plugin and clean up its resources.\n\n        Args:\n            plugin_name: Name of plugin to unload\n        \"\"\"\n        if plugin_name not in self._loaded_plugins:\n            return\n\n        plugin = self._loaded_plugins[plugin_name]\n\n        # Cleanup plugin\n        try:\n            plugin.cleanup()\n        except Exception as e:\n            logger.error(f\"Error during plugin cleanup: {e}\")\n\n        # Unregister from registry\n        self.registry.unregister(plugin)\n\n        # Remove from loaded plugins\n        del self._loaded_plugins[plugin_name]\n\n        logger.info(f\"Unloaded plugin: {plugin_name}\")\n\n    def reload_plugin(\n        self,\n        plugin_name: str,\n        config: Optional[PluginConfig] = None\n    ) -&gt; BasePlugin:\n        \"\"\"Reload a plugin (unload and load again).\n\n        Args:\n            plugin_name: Name of plugin to reload\n            config: New configuration\n\n        Returns:\n            Reloaded plugin instance\n        \"\"\"\n        # Unload if loaded\n        if plugin_name in self._loaded_plugins:\n            self.unload_plugin(plugin_name)\n\n        # Reload module if available\n        if plugin_name in self._plugin_modules:\n            module = self._plugin_modules[plugin_name]\n            importlib.reload(module)\n\n            # Re-discover classes from reloaded module\n            plugin_classes = []\n            for name, obj in inspect.getmembers(module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, BasePlugin) and \n                    obj != BasePlugin and\n                    obj.name == plugin_name):\n                    plugin_classes.append(obj)\n\n            if plugin_classes:\n                self._plugin_classes[plugin_name] = plugin_classes[0]\n\n        # Load plugin\n        return self.load_plugin(plugin_name, config)\n\n    def get_loaded_plugins(self) -&gt; Dict[str, BasePlugin]:\n        \"\"\"Get all currently loaded plugins.\n\n        Returns:\n            Dict mapping plugin names to instances\n        \"\"\"\n        return self._loaded_plugins.copy()\n\n    def get_discovered_plugins(self) -&gt; Dict[str, Type[BasePlugin]]:\n        \"\"\"Get all discovered plugin classes.\n\n        Returns:\n            Dict mapping plugin names to classes\n        \"\"\"\n        return self._plugin_classes.copy()\n\n    def get_plugin_info(self, plugin_name: str) -&gt; Optional[PluginInfo]:\n        \"\"\"Get information about a plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n\n        Returns:\n            Plugin info or None if not found\n        \"\"\"\n        # Check loaded plugins first\n        if plugin_name in self._loaded_plugins:\n            return self._loaded_plugins[plugin_name].get_info()\n\n        # Check discovered plugins\n        if plugin_name in self._plugin_classes:\n            # Create temporary instance to get info\n            try:\n                plugin = self._plugin_classes[plugin_name]()\n                return plugin.get_info()\n            except Exception:\n                pass\n\n        return None\n\n    def list_plugins(self, loaded_only: bool = False) -&gt; List[Dict[str, Any]]:\n        \"\"\"List all plugins with their status.\n\n        Args:\n            loaded_only: Only list loaded plugins\n\n        Returns:\n            List of plugin information dicts\n        \"\"\"\n        plugins = []\n\n        if loaded_only:\n            # Only loaded plugins\n            for name, plugin in self._loaded_plugins.items():\n                info = plugin.get_info()\n                plugins.append({\n                    \"name\": name,\n                    \"version\": info.version,\n                    \"description\": info.description,\n                    \"loaded\": True,\n                    \"provides\": {\n                        \"tools\": info.provides_tools,\n                        \"agents\": info.provides_agents,\n                        \"providers\": info.provides_providers\n                    }\n                })\n        else:\n            # All discovered plugins\n            for name, plugin_class in self._plugin_classes.items():\n                loaded = name in self._loaded_plugins\n\n                if loaded:\n                    info = self._loaded_plugins[name].get_info()\n                else:\n                    try:\n                        # Create temporary instance\n                        plugin = plugin_class()\n                        info = plugin.get_info()\n                    except Exception:\n                        # Minimal info if can't instantiate\n                        info = PluginInfo(\n                            name=name,\n                            version=getattr(plugin_class, 'version', 'unknown'),\n                            description=getattr(plugin_class, 'description', '')\n                        )\n\n                plugins.append({\n                    \"name\": name,\n                    \"version\": info.version,\n                    \"description\": info.description,\n                    \"loaded\": loaded,\n                    \"provides\": {\n                        \"tools\": info.provides_tools,\n                        \"agents\": info.provides_agents,\n                        \"providers\": info.provides_providers\n                    }\n                })\n\n        return plugins\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.__init__","title":"<code>__init__(plugin_dirs=None, auto_discover=True)</code>","text":"<p>Initialize plugin loader.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_dirs</code> <code>Optional[List[Union[str, Path]]]</code> <p>Directories to search for plugins</p> <code>None</code> <code>auto_discover</code> <code>bool</code> <p>Whether to auto-discover plugins on init</p> <code>True</code> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def __init__(\n    self,\n    plugin_dirs: Optional[List[Union[str, Path]]] = None,\n    auto_discover: bool = True\n):\n    \"\"\"Initialize plugin loader.\n\n    Args:\n        plugin_dirs: Directories to search for plugins\n        auto_discover: Whether to auto-discover plugins on init\n    \"\"\"\n    self.plugin_dirs = []\n    if plugin_dirs:\n        for dir_path in plugin_dirs:\n            self.add_plugin_directory(dir_path)\n\n    # Add default plugin directories\n    self._add_default_directories()\n\n    # Plugin storage\n    self._loaded_plugins: Dict[str, BasePlugin] = {}\n    self._plugin_classes: Dict[str, Type[BasePlugin]] = {}\n    self._plugin_modules: Dict[str, Any] = {}\n\n    # Registry for plugin management\n    self.registry = PluginRegistry()\n\n    # Auto-discover if requested\n    if auto_discover:\n        self.discover_all()\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.add_plugin_directory","title":"<code>add_plugin_directory(directory)</code>","text":"<p>Add a directory to search for plugins.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, Path]</code> <p>Path to plugin directory</p> required Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def add_plugin_directory(self, directory: Union[str, Path]) -&gt; None:\n    \"\"\"Add a directory to search for plugins.\n\n    Args:\n        directory: Path to plugin directory\n    \"\"\"\n    path = Path(directory).expanduser().resolve()\n    if path.exists() and path.is_dir():\n        if path not in self.plugin_dirs:\n            self.plugin_dirs.append(path)\n            logger.info(f\"Added plugin directory: {path}\")\n    else:\n        logger.warning(f\"Plugin directory does not exist: {path}\")\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.discover_all","title":"<code>discover_all()</code>","text":"<p>Discover all plugins in configured directories.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_all(self) -&gt; List[str]:\n    \"\"\"Discover all plugins in configured directories.\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    discovered = []\n\n    for plugin_dir in self.plugin_dirs:\n        plugins = self.discover_in_directory(plugin_dir)\n        discovered.extend(plugins)\n\n    logger.info(f\"Discovered {len(discovered)} plugins\")\n    return discovered\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.discover_in_directory","title":"<code>discover_in_directory(directory)</code>","text":"<p>Discover plugins in a specific directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Union[str, Path]</code> <p>Directory to search</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_in_directory(self, directory: Union[str, Path]) -&gt; List[str]:\n    \"\"\"Discover plugins in a specific directory.\n\n    Args:\n        directory: Directory to search\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    path = Path(directory)\n    discovered = []\n\n    if not path.exists() or not path.is_dir():\n        return discovered\n\n    # Look for Python files and packages\n    for item in path.iterdir():\n        if item.is_file() and item.suffix == \".py\" and not item.name.startswith(\"_\"):\n            # Single file plugin\n            try:\n                plugin_classes = self._load_plugin_from_file(item)\n                for plugin_class in plugin_classes:\n                    self._plugin_classes[plugin_class.name] = plugin_class\n                    discovered.append(plugin_class.name)\n            except Exception as e:\n                logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n        elif item.is_dir() and not item.name.startswith(\"_\"):\n            # Package plugin\n            init_file = item / \"__init__.py\"\n            if init_file.exists():\n                try:\n                    plugin_classes = self._load_plugin_from_package(item)\n                    for plugin_class in plugin_classes:\n                        self._plugin_classes[plugin_class.name] = plugin_class\n                        discovered.append(plugin_class.name)\n                except Exception as e:\n                    logger.error(f\"Failed to load plugin from {item}: {e}\")\n\n    return discovered\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.load_plugin","title":"<code>load_plugin(plugin_name, config=None)</code>","text":"<p>Load and initialize a specific plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin to load</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Initialized plugin instance</p> <p>Raises:</p> Type Description <code>PluginLoadError</code> <p>If plugin cannot be loaded</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_plugin(\n    self,\n    plugin_name: str,\n    config: Optional[PluginConfig] = None\n) -&gt; BasePlugin:\n    \"\"\"Load and initialize a specific plugin.\n\n    Args:\n        plugin_name: Name of the plugin to load\n        config: Plugin configuration\n\n    Returns:\n        Initialized plugin instance\n\n    Raises:\n        PluginLoadError: If plugin cannot be loaded\n    \"\"\"\n    # Check if already loaded\n    if plugin_name in self._loaded_plugins:\n        return self._loaded_plugins[plugin_name]\n\n    # Check if plugin class is available\n    if plugin_name not in self._plugin_classes:\n        # Try to discover it\n        self.discover_all()\n        if plugin_name not in self._plugin_classes:\n            raise PluginLoadError(f\"Plugin '{plugin_name}' not found\")\n\n    # Create plugin instance\n    plugin_class = self._plugin_classes[plugin_name]\n    try:\n        plugin = plugin_class(config)\n\n        # Validate configuration\n        plugin.validate_config()\n\n        # Initialize plugin\n        plugin.initialize()\n\n        # Store loaded plugin\n        self._loaded_plugins[plugin_name] = plugin\n\n        # Register with registry\n        self.registry.register(plugin)\n\n        logger.info(f\"Loaded plugin: {plugin_name} v{plugin.version}\")\n        return plugin\n\n    except Exception as e:\n        raise PluginLoadError(f\"Failed to load plugin '{plugin_name}': {e}\")\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.load_all_discovered","title":"<code>load_all_discovered(configs=None)</code>","text":"<p>Load all discovered plugins.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>Optional[Dict[str, PluginConfig]]</code> <p>Optional configurations for plugins</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, BasePlugin]</code> <p>Dict mapping plugin names to loaded instances</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_all_discovered(\n    self,\n    configs: Optional[Dict[str, PluginConfig]] = None\n) -&gt; Dict[str, BasePlugin]:\n    \"\"\"Load all discovered plugins.\n\n    Args:\n        configs: Optional configurations for plugins\n\n    Returns:\n        Dict mapping plugin names to loaded instances\n    \"\"\"\n    configs = configs or {}\n    loaded = {}\n\n    for plugin_name in self._plugin_classes:\n        try:\n            config = configs.get(plugin_name)\n            plugin = self.load_plugin(plugin_name, config)\n            loaded[plugin_name] = plugin\n        except Exception as e:\n            logger.error(f\"Failed to load plugin '{plugin_name}': {e}\")\n\n    return loaded\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.unload_plugin","title":"<code>unload_plugin(plugin_name)</code>","text":"<p>Unload a plugin and clean up its resources.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of plugin to unload</p> required Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def unload_plugin(self, plugin_name: str) -&gt; None:\n    \"\"\"Unload a plugin and clean up its resources.\n\n    Args:\n        plugin_name: Name of plugin to unload\n    \"\"\"\n    if plugin_name not in self._loaded_plugins:\n        return\n\n    plugin = self._loaded_plugins[plugin_name]\n\n    # Cleanup plugin\n    try:\n        plugin.cleanup()\n    except Exception as e:\n        logger.error(f\"Error during plugin cleanup: {e}\")\n\n    # Unregister from registry\n    self.registry.unregister(plugin)\n\n    # Remove from loaded plugins\n    del self._loaded_plugins[plugin_name]\n\n    logger.info(f\"Unloaded plugin: {plugin_name}\")\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.reload_plugin","title":"<code>reload_plugin(plugin_name, config=None)</code>","text":"<p>Reload a plugin (unload and load again).</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of plugin to reload</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>New configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Reloaded plugin instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def reload_plugin(\n    self,\n    plugin_name: str,\n    config: Optional[PluginConfig] = None\n) -&gt; BasePlugin:\n    \"\"\"Reload a plugin (unload and load again).\n\n    Args:\n        plugin_name: Name of plugin to reload\n        config: New configuration\n\n    Returns:\n        Reloaded plugin instance\n    \"\"\"\n    # Unload if loaded\n    if plugin_name in self._loaded_plugins:\n        self.unload_plugin(plugin_name)\n\n    # Reload module if available\n    if plugin_name in self._plugin_modules:\n        module = self._plugin_modules[plugin_name]\n        importlib.reload(module)\n\n        # Re-discover classes from reloaded module\n        plugin_classes = []\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and \n                issubclass(obj, BasePlugin) and \n                obj != BasePlugin and\n                obj.name == plugin_name):\n                plugin_classes.append(obj)\n\n        if plugin_classes:\n            self._plugin_classes[plugin_name] = plugin_classes[0]\n\n    # Load plugin\n    return self.load_plugin(plugin_name, config)\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.get_loaded_plugins","title":"<code>get_loaded_plugins()</code>","text":"<p>Get all currently loaded plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, BasePlugin]</code> <p>Dict mapping plugin names to instances</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_loaded_plugins(self) -&gt; Dict[str, BasePlugin]:\n    \"\"\"Get all currently loaded plugins.\n\n    Returns:\n        Dict mapping plugin names to instances\n    \"\"\"\n    return self._loaded_plugins.copy()\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.get_discovered_plugins","title":"<code>get_discovered_plugins()</code>","text":"<p>Get all discovered plugin classes.</p> <p>Returns:</p> Type Description <code>Dict[str, Type[BasePlugin]]</code> <p>Dict mapping plugin names to classes</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_discovered_plugins(self) -&gt; Dict[str, Type[BasePlugin]]:\n    \"\"\"Get all discovered plugin classes.\n\n    Returns:\n        Dict mapping plugin names to classes\n    \"\"\"\n    return self._plugin_classes.copy()\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.get_plugin_info","title":"<code>get_plugin_info(plugin_name)</code>","text":"<p>Get information about a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>Name of the plugin</p> required <p>Returns:</p> Type Description <code>Optional[PluginInfo]</code> <p>Plugin info or None if not found</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_plugin_info(self, plugin_name: str) -&gt; Optional[PluginInfo]:\n    \"\"\"Get information about a plugin.\n\n    Args:\n        plugin_name: Name of the plugin\n\n    Returns:\n        Plugin info or None if not found\n    \"\"\"\n    # Check loaded plugins first\n    if plugin_name in self._loaded_plugins:\n        return self._loaded_plugins[plugin_name].get_info()\n\n    # Check discovered plugins\n    if plugin_name in self._plugin_classes:\n        # Create temporary instance to get info\n        try:\n            plugin = self._plugin_classes[plugin_name]()\n            return plugin.get_info()\n        except Exception:\n            pass\n\n    return None\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.PluginLoader.list_plugins","title":"<code>list_plugins(loaded_only=False)</code>","text":"<p>List all plugins with their status.</p> <p>Parameters:</p> Name Type Description Default <code>loaded_only</code> <code>bool</code> <p>Only list loaded plugins</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of plugin information dicts</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def list_plugins(self, loaded_only: bool = False) -&gt; List[Dict[str, Any]]:\n    \"\"\"List all plugins with their status.\n\n    Args:\n        loaded_only: Only list loaded plugins\n\n    Returns:\n        List of plugin information dicts\n    \"\"\"\n    plugins = []\n\n    if loaded_only:\n        # Only loaded plugins\n        for name, plugin in self._loaded_plugins.items():\n            info = plugin.get_info()\n            plugins.append({\n                \"name\": name,\n                \"version\": info.version,\n                \"description\": info.description,\n                \"loaded\": True,\n                \"provides\": {\n                    \"tools\": info.provides_tools,\n                    \"agents\": info.provides_agents,\n                    \"providers\": info.provides_providers\n                }\n            })\n    else:\n        # All discovered plugins\n        for name, plugin_class in self._plugin_classes.items():\n            loaded = name in self._loaded_plugins\n\n            if loaded:\n                info = self._loaded_plugins[name].get_info()\n            else:\n                try:\n                    # Create temporary instance\n                    plugin = plugin_class()\n                    info = plugin.get_info()\n                except Exception:\n                    # Minimal info if can't instantiate\n                    info = PluginInfo(\n                        name=name,\n                        version=getattr(plugin_class, 'version', 'unknown'),\n                        description=getattr(plugin_class, 'description', '')\n                    )\n\n            plugins.append({\n                \"name\": name,\n                \"version\": info.version,\n                \"description\": info.description,\n                \"loaded\": loaded,\n                \"provides\": {\n                    \"tools\": info.provides_tools,\n                    \"agents\": info.provides_agents,\n                    \"providers\": info.provides_providers\n                }\n            })\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.get_plugin_loader","title":"<code>get_plugin_loader()</code>","text":"<p>Get the global plugin loader instance.</p> <p>Returns:</p> Type Description <code>PluginLoader</code> <p>Global PluginLoader instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def get_plugin_loader() -&gt; PluginLoader:\n    \"\"\"Get the global plugin loader instance.\n\n    Returns:\n        Global PluginLoader instance\n    \"\"\"\n    global _global_loader\n    if _global_loader is None:\n        _global_loader = PluginLoader()\n    return _global_loader\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.load_plugin","title":"<code>load_plugin(name, config=None)</code>","text":"<p>Load a plugin using the global loader.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <code>config</code> <code>Optional[PluginConfig]</code> <p>Plugin configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>BasePlugin</code> <p>Loaded plugin instance</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def load_plugin(name: str, config: Optional[PluginConfig] = None) -&gt; BasePlugin:\n    \"\"\"Load a plugin using the global loader.\n\n    Args:\n        name: Plugin name\n        config: Plugin configuration\n\n    Returns:\n        Loaded plugin instance\n    \"\"\"\n    loader = get_plugin_loader()\n    return loader.load_plugin(name, config)\n</code></pre>"},{"location":"reference/plugins/loader/#agenticraft.plugins.loader.discover_plugins","title":"<code>discover_plugins()</code>","text":"<p>Discover all available plugins.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of discovered plugin names</p> Source code in <code>agenticraft/plugins/loader.py</code> <pre><code>def discover_plugins() -&gt; List[str]:\n    \"\"\"Discover all available plugins.\n\n    Returns:\n        List of discovered plugin names\n    \"\"\"\n    loader = get_plugin_loader()\n    return loader.discover_all()\n</code></pre>"},{"location":"reference/plugins/registry/","title":"Registry","text":""},{"location":"reference/plugins/registry/#agenticraft.plugins.registry","title":"<code>registry</code>","text":"<p>Plugin registry for AgentiCraft.</p> <p>This module provides a centralized registry for managing plugins, their dependencies, and lifecycle. It ensures plugins are loaded in the correct order and handles plugin interactions.</p> Example <p>Using the plugin registry::</p> <pre><code>from agenticraft.plugins import PluginRegistry\n\nregistry = PluginRegistry()\n\n# Register a plugin\nregistry.register(weather_plugin)\n\n# Get tools from all plugins\nall_tools = registry.get_all_tools()\n\n# Get plugins by capability\ntool_plugins = registry.get_plugins_by_capability(\"tools\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginDependencyError","title":"<code>PluginDependencyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when plugin dependencies cannot be resolved.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>class PluginDependencyError(Exception):\n    \"\"\"Raised when plugin dependencies cannot be resolved.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for managing AgentiCraft plugins.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>class PluginRegistry:\n    \"\"\"Central registry for managing AgentiCraft plugins.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize plugin registry.\"\"\"\n        # Registered plugins by name\n        self._plugins: Dict[str, BasePlugin] = {}\n\n        # Plugin metadata cache\n        self._plugin_info: Dict[str, PluginInfo] = {}\n\n        # Capability indexes\n        self._tools_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n        self._agents_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n        self._providers_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n\n        # Plugin dependencies\n        self._dependencies: Dict[str, Set[str]] = defaultdict(set)\n        self._dependents: Dict[str, Set[str]] = defaultdict(set)\n\n        # Lifecycle tracking\n        self._initialized_plugins: Set[str] = set()\n        self._load_order: List[str] = []\n\n    def register(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Register a plugin with the registry.\n\n        Args:\n            plugin: Plugin instance to register\n\n        Raises:\n            ValueError: If plugin with same name already registered\n        \"\"\"\n        info = plugin.get_info()\n\n        if info.name in self._plugins:\n            raise ValueError(f\"Plugin '{info.name}' already registered\")\n\n        # Store plugin and info\n        self._plugins[info.name] = plugin\n        self._plugin_info[info.name] = info\n\n        # Update capability indexes\n        self._update_indexes(plugin, info)\n\n        # Track dependencies\n        self._update_dependencies(info)\n\n        # Add to load order\n        self._load_order.append(info.name)\n\n        logger.info(f\"Registered plugin: {info.name} v{info.version}\")\n\n    def unregister(self, plugin: BasePlugin) -&gt; None:\n        \"\"\"Unregister a plugin from the registry.\n\n        Args:\n            plugin: Plugin instance to unregister\n        \"\"\"\n        info = plugin.get_info()\n\n        if info.name not in self._plugins:\n            return\n\n        # Check dependents\n        if info.name in self._dependents and self._dependents[info.name]:\n            dependents = \", \".join(self._dependents[info.name])\n            logger.warning(\n                f\"Unregistering plugin '{info.name}' which has dependents: {dependents}\"\n            )\n\n        # Remove from indexes\n        self._remove_from_indexes(plugin, info)\n\n        # Remove from tracking\n        del self._plugins[info.name]\n        del self._plugin_info[info.name]\n\n        if info.name in self._initialized_plugins:\n            self._initialized_plugins.remove(info.name)\n\n        if info.name in self._load_order:\n            self._load_order.remove(info.name)\n\n        # Clean up dependencies\n        if info.name in self._dependencies:\n            del self._dependencies[info.name]\n\n        for deps in self._dependents.values():\n            deps.discard(info.name)\n\n        logger.info(f\"Unregistered plugin: {info.name}\")\n\n    def _update_indexes(self, plugin: BasePlugin, info: PluginInfo) -&gt; None:\n        \"\"\"Update capability indexes for a plugin.\"\"\"\n        # Tool index\n        for tool_name in info.provides_tools:\n            self._tools_index[tool_name].append(plugin)\n\n        # Agent index\n        for agent_name in info.provides_agents:\n            self._agents_index[agent_name].append(plugin)\n\n        # Provider index\n        for provider_name in info.provides_providers:\n            self._providers_index[provider_name].append(plugin)\n\n    def _remove_from_indexes(self, plugin: BasePlugin, info: PluginInfo) -&gt; None:\n        \"\"\"Remove plugin from capability indexes.\"\"\"\n        # Tool index\n        for tool_name in info.provides_tools:\n            if plugin in self._tools_index[tool_name]:\n                self._tools_index[tool_name].remove(plugin)\n\n        # Agent index  \n        for agent_name in info.provides_agents:\n            if plugin in self._agents_index[agent_name]:\n                self._agents_index[agent_name].remove(plugin)\n\n        # Provider index\n        for provider_name in info.provides_providers:\n            if plugin in self._providers_index[provider_name]:\n                self._providers_index[provider_name].remove(plugin)\n\n    def _update_dependencies(self, info: PluginInfo) -&gt; None:\n        \"\"\"Update dependency tracking for a plugin.\"\"\"\n        # Parse dependencies from info\n        deps = set()\n        if hasattr(info, 'depends_on'):\n            deps.update(info.depends_on)\n\n        self._dependencies[info.name] = deps\n\n        # Update dependents\n        for dep in deps:\n            self._dependents[dep].add(info.name)\n\n    def get_plugin(self, name: str) -&gt; Optional[BasePlugin]:\n        \"\"\"Get a registered plugin by name.\n\n        Args:\n            name: Plugin name\n\n        Returns:\n            Plugin instance or None\n        \"\"\"\n        return self._plugins.get(name)\n\n    def get_plugin_info(self, name: str) -&gt; Optional[PluginInfo]:\n        \"\"\"Get plugin information by name.\n\n        Args:\n            name: Plugin name\n\n        Returns:\n            Plugin info or None\n        \"\"\"\n        return self._plugin_info.get(name)\n\n    def list_plugins(self) -&gt; List[PluginInfo]:\n        \"\"\"List all registered plugins.\n\n        Returns:\n            List of plugin information\n        \"\"\"\n        return list(self._plugin_info.values())\n\n    def get_plugins_by_capability(self, capability: str) -&gt; List[BasePlugin]:\n        \"\"\"Get plugins that provide a specific capability.\n\n        Args:\n            capability: Capability type (\"tools\", \"agents\", \"providers\")\n\n        Returns:\n            List of plugins with the capability\n        \"\"\"\n        plugins = []\n\n        if capability == \"tools\":\n            for plugin_list in self._tools_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        elif capability == \"agents\":\n            for plugin_list in self._agents_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        elif capability == \"providers\":\n            for plugin_list in self._providers_index.values():\n                for plugin in plugin_list:\n                    if plugin not in plugins:\n                        plugins.append(plugin)\n\n        return plugins\n\n    def get_all_tools(self) -&gt; Dict[str, \"Tool\"]:\n        \"\"\"Get all tools from registered plugins.\n\n        Returns:\n            Dict mapping tool names to tool instances\n        \"\"\"\n        tools = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_tools = plugin.get_tools()\n                for tool in plugin_tools:\n                    if hasattr(tool, 'name'):\n                        tools[tool.name] = tool\n            except Exception as e:\n                logger.error(f\"Error getting tools from plugin '{plugin.name}': {e}\")\n\n        return tools\n\n    def get_all_agents(self) -&gt; Dict[str, type]:\n        \"\"\"Get all agent classes from registered plugins.\n\n        Returns:\n            Dict mapping agent names to agent classes\n        \"\"\"\n        agents = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_agents = plugin.get_agents()\n                for agent_class in plugin_agents:\n                    agents[agent_class.__name__] = agent_class\n            except Exception as e:\n                logger.error(f\"Error getting agents from plugin '{plugin.name}': {e}\")\n\n        return agents\n\n    def get_all_providers(self) -&gt; Dict[str, type]:\n        \"\"\"Get all providers from registered plugins.\n\n        Returns:\n            Dict mapping provider names to provider classes\n        \"\"\"\n        providers = {}\n\n        for plugin in self._plugins.values():\n            try:\n                plugin_providers = plugin.get_providers()\n                providers.update(plugin_providers)\n            except Exception as e:\n                logger.error(f\"Error getting providers from plugin '{plugin.name}': {e}\")\n\n        return providers\n\n    def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n        \"\"\"Apply all plugin enhancements to an agent.\n\n        Args:\n            agent: Agent to enhance\n\n        Returns:\n            Enhanced agent\n        \"\"\"\n        for plugin in self._plugins.values():\n            try:\n                agent = plugin.enhance_agent(agent)\n            except Exception as e:\n                logger.error(f\"Error enhancing agent with plugin '{plugin.name}': {e}\")\n\n        return agent\n\n    def initialize_all(self) -&gt; None:\n        \"\"\"Initialize all registered plugins in dependency order.\"\"\"\n        # Get initialization order\n        init_order = self._get_initialization_order()\n\n        for plugin_name in init_order:\n            if plugin_name in self._initialized_plugins:\n                continue\n\n            plugin = self._plugins[plugin_name]\n\n            try:\n                plugin.initialize()\n                self._initialized_plugins.add(plugin_name)\n                logger.info(f\"Initialized plugin: {plugin_name}\")\n            except Exception as e:\n                logger.error(f\"Failed to initialize plugin '{plugin_name}': {e}\")\n                raise\n\n    def cleanup_all(self) -&gt; None:\n        \"\"\"Clean up all plugins in reverse dependency order.\"\"\"\n        # Clean up in reverse order\n        cleanup_order = list(reversed(self._get_initialization_order()))\n\n        for plugin_name in cleanup_order:\n            if plugin_name not in self._initialized_plugins:\n                continue\n\n            plugin = self._plugins[plugin_name]\n\n            try:\n                plugin.cleanup()\n                self._initialized_plugins.remove(plugin_name)\n                logger.info(f\"Cleaned up plugin: {plugin_name}\")\n            except Exception as e:\n                logger.error(f\"Error cleaning up plugin '{plugin_name}': {e}\")\n\n    def _get_initialization_order(self) -&gt; List[str]:\n        \"\"\"Get plugin initialization order based on dependencies.\n\n        Returns:\n            List of plugin names in initialization order\n\n        Raises:\n            PluginDependencyError: If circular dependencies detected\n        \"\"\"\n        # Topological sort\n        visited = set()\n        temp_visited = set()\n        order = []\n\n        def visit(name: str):\n            if name in temp_visited:\n                raise PluginDependencyError(f\"Circular dependency detected involving '{name}'\")\n\n            if name in visited:\n                return\n\n            temp_visited.add(name)\n\n            # Visit dependencies first\n            if name in self._dependencies:\n                for dep in self._dependencies[name]:\n                    if dep in self._plugins:  # Only if dependency is registered\n                        visit(dep)\n\n            temp_visited.remove(name)\n            visited.add(name)\n            order.append(name)\n\n        # Visit all plugins\n        for plugin_name in self._plugins:\n            if plugin_name not in visited:\n                visit(plugin_name)\n\n        return order\n\n    def validate_dependencies(self) -&gt; List[str]:\n        \"\"\"Validate all plugin dependencies are satisfied.\n\n        Returns:\n            List of missing dependencies\n        \"\"\"\n        missing = []\n\n        for plugin_name, deps in self._dependencies.items():\n            for dep in deps:\n                if dep not in self._plugins:\n                    missing.append(f\"{plugin_name} requires {dep}\")\n\n        return missing\n\n    def get_plugin_stats(self) -&gt; Dict[str, Any]:\n        \"\"\"Get statistics about registered plugins.\n\n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        total_tools = sum(len(info.provides_tools) for info in self._plugin_info.values())\n        total_agents = sum(len(info.provides_agents) for info in self._plugin_info.values())\n        total_providers = sum(len(info.provides_providers) for info in self._plugin_info.values())\n\n        return {\n            \"total_plugins\": len(self._plugins),\n            \"initialized_plugins\": len(self._initialized_plugins),\n            \"total_tools\": total_tools,\n            \"total_agents\": total_agents,\n            \"total_providers\": total_providers,\n            \"unique_tools\": len(self._tools_index),\n            \"unique_agents\": len(self._agents_index),\n            \"unique_providers\": len(self._providers_index),\n            \"plugins_with_dependencies\": len([d for d in self._dependencies.values() if d]),\n            \"missing_dependencies\": len(self.validate_dependencies())\n        }\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered plugins.\"\"\"\n        # Clean up first\n        self.cleanup_all()\n\n        # Clear all data\n        self._plugins.clear()\n        self._plugin_info.clear()\n        self._tools_index.clear()\n        self._agents_index.clear()\n        self._providers_index.clear()\n        self._dependencies.clear()\n        self._dependents.clear()\n        self._initialized_plugins.clear()\n        self._load_order.clear()\n\n        logger.info(\"Cleared plugin registry\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize plugin registry.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize plugin registry.\"\"\"\n    # Registered plugins by name\n    self._plugins: Dict[str, BasePlugin] = {}\n\n    # Plugin metadata cache\n    self._plugin_info: Dict[str, PluginInfo] = {}\n\n    # Capability indexes\n    self._tools_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n    self._agents_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n    self._providers_index: Dict[str, List[BasePlugin]] = defaultdict(list)\n\n    # Plugin dependencies\n    self._dependencies: Dict[str, Set[str]] = defaultdict(set)\n    self._dependents: Dict[str, Set[str]] = defaultdict(set)\n\n    # Lifecycle tracking\n    self._initialized_plugins: Set[str] = set()\n    self._load_order: List[str] = []\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.register","title":"<code>register(plugin)</code>","text":"<p>Register a plugin with the registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to register</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If plugin with same name already registered</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def register(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin with the registry.\n\n    Args:\n        plugin: Plugin instance to register\n\n    Raises:\n        ValueError: If plugin with same name already registered\n    \"\"\"\n    info = plugin.get_info()\n\n    if info.name in self._plugins:\n        raise ValueError(f\"Plugin '{info.name}' already registered\")\n\n    # Store plugin and info\n    self._plugins[info.name] = plugin\n    self._plugin_info[info.name] = info\n\n    # Update capability indexes\n    self._update_indexes(plugin, info)\n\n    # Track dependencies\n    self._update_dependencies(info)\n\n    # Add to load order\n    self._load_order.append(info.name)\n\n    logger.info(f\"Registered plugin: {info.name} v{info.version}\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.unregister","title":"<code>unregister(plugin)</code>","text":"<p>Unregister a plugin from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin instance to unregister</p> required Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def unregister(self, plugin: BasePlugin) -&gt; None:\n    \"\"\"Unregister a plugin from the registry.\n\n    Args:\n        plugin: Plugin instance to unregister\n    \"\"\"\n    info = plugin.get_info()\n\n    if info.name not in self._plugins:\n        return\n\n    # Check dependents\n    if info.name in self._dependents and self._dependents[info.name]:\n        dependents = \", \".join(self._dependents[info.name])\n        logger.warning(\n            f\"Unregistering plugin '{info.name}' which has dependents: {dependents}\"\n        )\n\n    # Remove from indexes\n    self._remove_from_indexes(plugin, info)\n\n    # Remove from tracking\n    del self._plugins[info.name]\n    del self._plugin_info[info.name]\n\n    if info.name in self._initialized_plugins:\n        self._initialized_plugins.remove(info.name)\n\n    if info.name in self._load_order:\n        self._load_order.remove(info.name)\n\n    # Clean up dependencies\n    if info.name in self._dependencies:\n        del self._dependencies[info.name]\n\n    for deps in self._dependents.values():\n        deps.discard(info.name)\n\n    logger.info(f\"Unregistered plugin: {info.name}\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_plugin","title":"<code>get_plugin(name)</code>","text":"<p>Get a registered plugin by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <p>Returns:</p> Type Description <code>Optional[BasePlugin]</code> <p>Plugin instance or None</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin(self, name: str) -&gt; Optional[BasePlugin]:\n    \"\"\"Get a registered plugin by name.\n\n    Args:\n        name: Plugin name\n\n    Returns:\n        Plugin instance or None\n    \"\"\"\n    return self._plugins.get(name)\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(name)</code>","text":"<p>Get plugin information by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Plugin name</p> required <p>Returns:</p> Type Description <code>Optional[PluginInfo]</code> <p>Plugin info or None</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_info(self, name: str) -&gt; Optional[PluginInfo]:\n    \"\"\"Get plugin information by name.\n\n    Args:\n        name: Plugin name\n\n    Returns:\n        Plugin info or None\n    \"\"\"\n    return self._plugin_info.get(name)\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.list_plugins","title":"<code>list_plugins()</code>","text":"<p>List all registered plugins.</p> <p>Returns:</p> Type Description <code>List[PluginInfo]</code> <p>List of plugin information</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def list_plugins(self) -&gt; List[PluginInfo]:\n    \"\"\"List all registered plugins.\n\n    Returns:\n        List of plugin information\n    \"\"\"\n    return list(self._plugin_info.values())\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_plugins_by_capability","title":"<code>get_plugins_by_capability(capability)</code>","text":"<p>Get plugins that provide a specific capability.</p> <p>Parameters:</p> Name Type Description Default <code>capability</code> <code>str</code> <p>Capability type (\"tools\", \"agents\", \"providers\")</p> required <p>Returns:</p> Type Description <code>List[BasePlugin]</code> <p>List of plugins with the capability</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugins_by_capability(self, capability: str) -&gt; List[BasePlugin]:\n    \"\"\"Get plugins that provide a specific capability.\n\n    Args:\n        capability: Capability type (\"tools\", \"agents\", \"providers\")\n\n    Returns:\n        List of plugins with the capability\n    \"\"\"\n    plugins = []\n\n    if capability == \"tools\":\n        for plugin_list in self._tools_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    elif capability == \"agents\":\n        for plugin_list in self._agents_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    elif capability == \"providers\":\n        for plugin_list in self._providers_index.values():\n            for plugin in plugin_list:\n                if plugin not in plugins:\n                    plugins.append(plugin)\n\n    return plugins\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_all_tools","title":"<code>get_all_tools()</code>","text":"<p>Get all tools from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Tool]</code> <p>Dict mapping tool names to tool instances</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_tools(self) -&gt; Dict[str, \"Tool\"]:\n    \"\"\"Get all tools from registered plugins.\n\n    Returns:\n        Dict mapping tool names to tool instances\n    \"\"\"\n    tools = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_tools = plugin.get_tools()\n            for tool in plugin_tools:\n                if hasattr(tool, 'name'):\n                    tools[tool.name] = tool\n        except Exception as e:\n            logger.error(f\"Error getting tools from plugin '{plugin.name}': {e}\")\n\n    return tools\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_all_agents","title":"<code>get_all_agents()</code>","text":"<p>Get all agent classes from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping agent names to agent classes</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_agents(self) -&gt; Dict[str, type]:\n    \"\"\"Get all agent classes from registered plugins.\n\n    Returns:\n        Dict mapping agent names to agent classes\n    \"\"\"\n    agents = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_agents = plugin.get_agents()\n            for agent_class in plugin_agents:\n                agents[agent_class.__name__] = agent_class\n        except Exception as e:\n            logger.error(f\"Error getting agents from plugin '{plugin.name}': {e}\")\n\n    return agents\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_all_providers","title":"<code>get_all_providers()</code>","text":"<p>Get all providers from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, type]</code> <p>Dict mapping provider names to provider classes</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_providers(self) -&gt; Dict[str, type]:\n    \"\"\"Get all providers from registered plugins.\n\n    Returns:\n        Dict mapping provider names to provider classes\n    \"\"\"\n    providers = {}\n\n    for plugin in self._plugins.values():\n        try:\n            plugin_providers = plugin.get_providers()\n            providers.update(plugin_providers)\n        except Exception as e:\n            logger.error(f\"Error getting providers from plugin '{plugin.name}': {e}\")\n\n    return providers\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.enhance_agent","title":"<code>enhance_agent(agent)</code>","text":"<p>Apply all plugin enhancements to an agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>Agent to enhance</p> required <p>Returns:</p> Type Description <code>Agent</code> <p>Enhanced agent</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def enhance_agent(self, agent: \"Agent\") -&gt; \"Agent\":\n    \"\"\"Apply all plugin enhancements to an agent.\n\n    Args:\n        agent: Agent to enhance\n\n    Returns:\n        Enhanced agent\n    \"\"\"\n    for plugin in self._plugins.values():\n        try:\n            agent = plugin.enhance_agent(agent)\n        except Exception as e:\n            logger.error(f\"Error enhancing agent with plugin '{plugin.name}': {e}\")\n\n    return agent\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.initialize_all","title":"<code>initialize_all()</code>","text":"<p>Initialize all registered plugins in dependency order.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def initialize_all(self) -&gt; None:\n    \"\"\"Initialize all registered plugins in dependency order.\"\"\"\n    # Get initialization order\n    init_order = self._get_initialization_order()\n\n    for plugin_name in init_order:\n        if plugin_name in self._initialized_plugins:\n            continue\n\n        plugin = self._plugins[plugin_name]\n\n        try:\n            plugin.initialize()\n            self._initialized_plugins.add(plugin_name)\n            logger.info(f\"Initialized plugin: {plugin_name}\")\n        except Exception as e:\n            logger.error(f\"Failed to initialize plugin '{plugin_name}': {e}\")\n            raise\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.cleanup_all","title":"<code>cleanup_all()</code>","text":"<p>Clean up all plugins in reverse dependency order.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def cleanup_all(self) -&gt; None:\n    \"\"\"Clean up all plugins in reverse dependency order.\"\"\"\n    # Clean up in reverse order\n    cleanup_order = list(reversed(self._get_initialization_order()))\n\n    for plugin_name in cleanup_order:\n        if plugin_name not in self._initialized_plugins:\n            continue\n\n        plugin = self._plugins[plugin_name]\n\n        try:\n            plugin.cleanup()\n            self._initialized_plugins.remove(plugin_name)\n            logger.info(f\"Cleaned up plugin: {plugin_name}\")\n        except Exception as e:\n            logger.error(f\"Error cleaning up plugin '{plugin_name}': {e}\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.validate_dependencies","title":"<code>validate_dependencies()</code>","text":"<p>Validate all plugin dependencies are satisfied.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of missing dependencies</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def validate_dependencies(self) -&gt; List[str]:\n    \"\"\"Validate all plugin dependencies are satisfied.\n\n    Returns:\n        List of missing dependencies\n    \"\"\"\n    missing = []\n\n    for plugin_name, deps in self._dependencies.items():\n        for dep in deps:\n            if dep not in self._plugins:\n                missing.append(f\"{plugin_name} requires {dep}\")\n\n    return missing\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.get_plugin_stats","title":"<code>get_plugin_stats()</code>","text":"<p>Get statistics about registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of statistics</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_stats(self) -&gt; Dict[str, Any]:\n    \"\"\"Get statistics about registered plugins.\n\n    Returns:\n        Dictionary of statistics\n    \"\"\"\n    total_tools = sum(len(info.provides_tools) for info in self._plugin_info.values())\n    total_agents = sum(len(info.provides_agents) for info in self._plugin_info.values())\n    total_providers = sum(len(info.provides_providers) for info in self._plugin_info.values())\n\n    return {\n        \"total_plugins\": len(self._plugins),\n        \"initialized_plugins\": len(self._initialized_plugins),\n        \"total_tools\": total_tools,\n        \"total_agents\": total_agents,\n        \"total_providers\": total_providers,\n        \"unique_tools\": len(self._tools_index),\n        \"unique_agents\": len(self._agents_index),\n        \"unique_providers\": len(self._providers_index),\n        \"plugins_with_dependencies\": len([d for d in self._dependencies.values() if d]),\n        \"missing_dependencies\": len(self.validate_dependencies())\n    }\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.PluginRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered plugins.</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered plugins.\"\"\"\n    # Clean up first\n    self.cleanup_all()\n\n    # Clear all data\n    self._plugins.clear()\n    self._plugin_info.clear()\n    self._tools_index.clear()\n    self._agents_index.clear()\n    self._providers_index.clear()\n    self._dependencies.clear()\n    self._dependents.clear()\n    self._initialized_plugins.clear()\n    self._load_order.clear()\n\n    logger.info(\"Cleared plugin registry\")\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.get_plugin_registry","title":"<code>get_plugin_registry()</code>","text":"<p>Get the global plugin registry.</p> <p>Returns:</p> Type Description <code>PluginRegistry</code> <p>Global PluginRegistry instance</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_plugin_registry() -&gt; PluginRegistry:\n    \"\"\"Get the global plugin registry.\n\n    Returns:\n        Global PluginRegistry instance\n    \"\"\"\n    global _global_registry\n    if _global_registry is None:\n        _global_registry = PluginRegistry()\n    return _global_registry\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.register_plugin","title":"<code>register_plugin(plugin)</code>","text":"<p>Register a plugin with the global registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>BasePlugin</code> <p>Plugin to register</p> required Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def register_plugin(plugin: BasePlugin) -&gt; None:\n    \"\"\"Register a plugin with the global registry.\n\n    Args:\n        plugin: Plugin to register\n    \"\"\"\n    registry = get_plugin_registry()\n    registry.register(plugin)\n</code></pre>"},{"location":"reference/plugins/registry/#agenticraft.plugins.registry.get_all_plugin_tools","title":"<code>get_all_plugin_tools()</code>","text":"<p>Get all tools from registered plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Tool]</code> <p>Dict of tool name to tool instance</p> Source code in <code>agenticraft/plugins/registry.py</code> <pre><code>def get_all_plugin_tools() -&gt; Dict[str, \"Tool\"]:\n    \"\"\"Get all tools from registered plugins.\n\n    Returns:\n        Dict of tool name to tool instance\n    \"\"\"\n    registry = get_plugin_registry()\n    return registry.get_all_tools()\n</code></pre>"},{"location":"reference/protocols/__init__/","title":"init","text":""},{"location":"reference/protocols/__init__/#agenticraft.protocols","title":"<code>protocols</code>","text":"<p>AgentiCraft protocols module.</p> <p>This module contains protocol implementations for interoperability with external systems.</p>"},{"location":"reference/protocols/mcp/__init__/","title":"init","text":""},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp","title":"<code>mcp</code>","text":"<p>Model Context Protocol (MCP) implementation for AgentiCraft.</p> <p>The MCP module provides integration with the Model Context Protocol, allowing AgentiCraft agents to discover and use tools from MCP servers.</p> <p>Key components: - Client: Connect to MCP servers and discover tools - Server: Expose AgentiCraft tools via MCP - Registry: Manage MCP tool registrations - Adapters: Convert between AgentiCraft and MCP formats</p> Example <p>Using MCP tools with an agent::</p> <pre><code>from agenticraft import Agent\nfrom agenticraft.protocols.mcp import MCPClient\n\n# Connect to MCP server\nmcp_client = MCPClient(\"ws://localhost:3000\")\nawait mcp_client.connect()\n\n# Create agent with MCP tools\nagent = Agent(\n    name=\"MCPAgent\",\n    tools=mcp_client.get_tools()\n)\n\n# Use MCP tools transparently\nresponse = agent.run(\"Search for Python tutorials\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient","title":"<code>MCPClient</code>","text":"<p>Client for connecting to MCP servers.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>class MCPClient:\n    \"\"\"Client for connecting to MCP servers.\"\"\"\n\n    def __init__(self, url: str, **kwargs: Any):\n        \"\"\"Initialize MCP client.\n\n        Args:\n            url: MCP server URL (WebSocket or HTTP)\n            **kwargs: Additional connection configuration\n        \"\"\"\n        self.config = MCPConnectionConfig(url=url, **kwargs)\n        self._ws = None\n        self._http_client = None\n        self._tools: Dict[str, MCPTool] = {}\n        self._server_info: Optional[MCPServerInfo] = None\n        self._request_id = 0\n        self._pending_requests: Dict[Union[str, int], asyncio.Future] = {}\n\n        # Check WebSocket support\n        if self.config.is_websocket and not HAS_WEBSOCKETS:\n            raise ImportError(\n                \"WebSocket support requires 'websockets' package. \"\n                \"Install with: pip install agenticraft[websocket]\"\n            )\n\n    async def connect(self) -&gt; None:\n        \"\"\"Connect to the MCP server.\"\"\"\n        try:\n            if self.config.is_websocket:\n                await self._connect_websocket()\n            else:\n                await self._connect_http()\n\n            # Initialize connection\n            await self._initialize()\n\n            # Discover tools\n            await self._discover_tools()\n\n            logger.info(f\"Connected to MCP server at {self.config.url}\")\n\n        except Exception as e:\n            logger.error(f\"Failed to connect to MCP server: {e}\")\n            raise ToolError(f\"MCP connection failed: {e}\")\n\n    async def _connect_websocket(self) -&gt; None:\n        \"\"\"Connect via WebSocket.\"\"\"\n        self._ws = await websockets.connect(\n            self.config.url,\n            extra_headers=self.config.headers\n        )\n\n        # Start message handler\n        asyncio.create_task(self._handle_websocket_messages())\n\n    async def _connect_http(self) -&gt; None:\n        \"\"\"Connect via HTTP.\"\"\"\n        self._http_client = httpx.AsyncClient(\n            base_url=self.config.url,\n            headers=self.config.headers,\n            timeout=self.config.timeout\n        )\n\n    async def _handle_websocket_messages(self) -&gt; None:\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        try:\n            async for message in self._ws:\n                data = json.loads(message)\n                response = MCPResponse(**data)\n\n                # Handle response\n                if response.id in self._pending_requests:\n                    future = self._pending_requests.pop(response.id)\n                    if response.is_error:\n                        future.set_exception(\n                            ToolError(f\"MCP error: {response.error.message}\")\n                        )\n                    else:\n                        future.set_result(response.result)\n\n        except Exception as e:\n            logger.error(f\"WebSocket handler error: {e}\")\n            # Cancel all pending requests\n            for future in self._pending_requests.values():\n                future.set_exception(e)\n            self._pending_requests.clear()\n\n    async def _send_request(\n        self,\n        method: MCPMethod,\n        params: Optional[Dict[str, Any]] = None\n    ) -&gt; Any:\n        \"\"\"Send a request to the MCP server.\n\n        Args:\n            method: The MCP method to call\n            params: Optional parameters\n\n        Returns:\n            The response result\n        \"\"\"\n        self._request_id += 1\n        request = MCPRequest(\n            method=method,\n            params=params,\n            id=self._request_id\n        )\n\n        if self.config.is_websocket:\n            return await self._send_websocket_request(request)\n        else:\n            return await self._send_http_request(request)\n\n    async def _send_websocket_request(self, request: MCPRequest) -&gt; Any:\n        \"\"\"Send request via WebSocket.\"\"\"\n        if not self._ws:\n            raise ToolError(\"WebSocket not connected\")\n\n        # Create future for response\n        future = asyncio.Future()\n        self._pending_requests[request.id] = future\n\n        try:\n            # Send request\n            await self._ws.send(json.dumps(request.to_dict()))\n\n            # Wait for response\n            result = await asyncio.wait_for(\n                future,\n                timeout=self.config.timeout\n            )\n            return result\n\n        except asyncio.TimeoutError:\n            self._pending_requests.pop(request.id, None)\n            raise ToolError(f\"MCP request timeout: {request.method}\")\n        except Exception as e:\n            self._pending_requests.pop(request.id, None)\n            raise\n\n    async def _send_http_request(self, request: MCPRequest) -&gt; Any:\n        \"\"\"Send request via HTTP.\"\"\"\n        if not self._http_client:\n            raise ToolError(\"HTTP client not connected\")\n\n        try:\n            response = await self._http_client.post(\n                \"/rpc\",\n                json=request.to_dict()\n            )\n            response.raise_for_status()\n\n            data = response.json()\n            mcp_response = MCPResponse(**data)\n\n            if mcp_response.is_error:\n                raise ToolError(f\"MCP error: {mcp_response.error.message}\")\n\n            return mcp_response.result\n\n        except httpx.HTTPError as e:\n            raise ToolError(f\"MCP HTTP error: {e}\")\n\n    async def _initialize(self) -&gt; None:\n        \"\"\"Initialize the MCP connection.\"\"\"\n        result = await self._send_request(\n            MCPMethod.INITIALIZE,\n            {\"client\": \"agenticraft\", \"version\": \"0.1.0\"}\n        )\n\n        # Get server info\n        info_result = await self._send_request(MCPMethod.GET_INFO)\n        self._server_info = MCPServerInfo(**info_result)\n\n        logger.info(\n            f\"Connected to {self._server_info.name} \"\n            f\"v{self._server_info.version}\"\n        )\n\n    async def _discover_tools(self) -&gt; None:\n        \"\"\"Discover available tools from the server.\"\"\"\n        result = await self._send_request(MCPMethod.LIST_TOOLS)\n\n        self._tools.clear()\n        for tool_data in result.get(\"tools\", []):\n            tool = MCPTool(**tool_data)\n            self._tools[tool.name] = tool\n\n        logger.info(f\"Discovered {len(self._tools)} MCP tools\")\n\n    async def call_tool(\n        self,\n        tool_name: str,\n        arguments: Dict[str, Any]\n    ) -&gt; Any:\n        \"\"\"Call a tool on the MCP server.\n\n        Args:\n            tool_name: Name of the tool to call\n            arguments: Tool arguments\n\n        Returns:\n            Tool execution result\n        \"\"\"\n        if tool_name not in self._tools:\n            raise ToolNotFoundError(tool_name)\n\n        tool_call = MCPToolCall(tool=tool_name, arguments=arguments)\n\n        try:\n            result = await self._send_request(\n                MCPMethod.CALL_TOOL,\n                tool_call.to_dict()\n            )\n\n            # Handle result\n            if isinstance(result, dict) and \"error\" in result:\n                raise ToolError(f\"Tool execution failed: {result['error']}\")\n\n            return result\n\n        except Exception as e:\n            logger.error(f\"Tool execution failed: {tool_name} - {e}\")\n            raise ToolError(f\"Failed to execute tool {tool_name}: {e}\")\n\n    def get_tools(self) -&gt; List[BaseTool]:\n        \"\"\"Get all available tools as AgentiCraft tools.\n\n        Returns:\n            List of tool adapters\n        \"\"\"\n        tools = []\n        for mcp_tool in self._tools.values():\n            adapter = MCPToolAdapter(mcp_tool, self)\n            tools.append(adapter)\n        return tools\n\n    def get_tool(self, name: str) -&gt; BaseTool:\n        \"\"\"Get a specific tool by name.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            Tool adapter\n\n        Raises:\n            ToolNotFoundError: If tool not found\n        \"\"\"\n        if name not in self._tools:\n            raise ToolNotFoundError(name)\n\n        return MCPToolAdapter(self._tools[name], self)\n\n    @property\n    def server_info(self) -&gt; Optional[MCPServerInfo]:\n        \"\"\"Get server information.\"\"\"\n        return self._server_info\n\n    @property\n    def available_tools(self) -&gt; List[str]:\n        \"\"\"Get list of available tool names.\"\"\"\n        return list(self._tools.keys())\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the MCP server.\"\"\"\n        try:\n            # Send shutdown\n            await self._send_request(MCPMethod.SHUTDOWN)\n        except Exception:\n            pass  # Ignore shutdown errors\n\n        # Close connections\n        if self._ws:\n            await self._ws.close()\n            self._ws = None\n\n        if self._http_client:\n            await self._http_client.aclose()\n            self._http_client = None\n\n        self._tools.clear()\n        self._server_info = None\n\n        logger.info(\"Disconnected from MCP server\")\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.disconnect()\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.server_info","title":"<code>server_info</code>  <code>property</code>","text":"<p>Get server information.</p>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.available_tools","title":"<code>available_tools</code>  <code>property</code>","text":"<p>Get list of available tool names.</p>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.__init__","title":"<code>__init__(url, **kwargs)</code>","text":"<p>Initialize MCP client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>MCP server URL (WebSocket or HTTP)</p> required <code>**kwargs</code> <code>Any</code> <p>Additional connection configuration</p> <code>{}</code> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def __init__(self, url: str, **kwargs: Any):\n    \"\"\"Initialize MCP client.\n\n    Args:\n        url: MCP server URL (WebSocket or HTTP)\n        **kwargs: Additional connection configuration\n    \"\"\"\n    self.config = MCPConnectionConfig(url=url, **kwargs)\n    self._ws = None\n    self._http_client = None\n    self._tools: Dict[str, MCPTool] = {}\n    self._server_info: Optional[MCPServerInfo] = None\n    self._request_id = 0\n    self._pending_requests: Dict[Union[str, int], asyncio.Future] = {}\n\n    # Check WebSocket support\n    if self.config.is_websocket and not HAS_WEBSOCKETS:\n        raise ImportError(\n            \"WebSocket support requires 'websockets' package. \"\n            \"Install with: pip install agenticraft[websocket]\"\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to the MCP server.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to the MCP server.\"\"\"\n    try:\n        if self.config.is_websocket:\n            await self._connect_websocket()\n        else:\n            await self._connect_http()\n\n        # Initialize connection\n        await self._initialize()\n\n        # Discover tools\n        await self._discover_tools()\n\n        logger.info(f\"Connected to MCP server at {self.config.url}\")\n\n    except Exception as e:\n        logger.error(f\"Failed to connect to MCP server: {e}\")\n        raise ToolError(f\"MCP connection failed: {e}\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.call_tool","title":"<code>call_tool(tool_name, arguments)</code>  <code>async</code>","text":"<p>Call a tool on the MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to call</p> required <code>arguments</code> <code>Dict[str, Any]</code> <p>Tool arguments</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Tool execution result</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def call_tool(\n    self,\n    tool_name: str,\n    arguments: Dict[str, Any]\n) -&gt; Any:\n    \"\"\"Call a tool on the MCP server.\n\n    Args:\n        tool_name: Name of the tool to call\n        arguments: Tool arguments\n\n    Returns:\n        Tool execution result\n    \"\"\"\n    if tool_name not in self._tools:\n        raise ToolNotFoundError(tool_name)\n\n    tool_call = MCPToolCall(tool=tool_name, arguments=arguments)\n\n    try:\n        result = await self._send_request(\n            MCPMethod.CALL_TOOL,\n            tool_call.to_dict()\n        )\n\n        # Handle result\n        if isinstance(result, dict) and \"error\" in result:\n            raise ToolError(f\"Tool execution failed: {result['error']}\")\n\n        return result\n\n    except Exception as e:\n        logger.error(f\"Tool execution failed: {tool_name} - {e}\")\n        raise ToolError(f\"Failed to execute tool {tool_name}: {e}\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all available tools as AgentiCraft tools.</p> <p>Returns:</p> Type Description <code>List[BaseTool]</code> <p>List of tool adapters</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def get_tools(self) -&gt; List[BaseTool]:\n    \"\"\"Get all available tools as AgentiCraft tools.\n\n    Returns:\n        List of tool adapters\n    \"\"\"\n    tools = []\n    for mcp_tool in self._tools.values():\n        adapter = MCPToolAdapter(mcp_tool, self)\n        tools.append(adapter)\n    return tools\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.get_tool","title":"<code>get_tool(name)</code>","text":"<p>Get a specific tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>Tool adapter</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def get_tool(self, name: str) -&gt; BaseTool:\n    \"\"\"Get a specific tool by name.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        Tool adapter\n\n    Raises:\n        ToolNotFoundError: If tool not found\n    \"\"\"\n    if name not in self._tools:\n        raise ToolNotFoundError(name)\n\n    return MCPToolAdapter(self._tools[name], self)\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from the MCP server.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the MCP server.\"\"\"\n    try:\n        # Send shutdown\n        await self._send_request(MCPMethod.SHUTDOWN)\n    except Exception:\n        pass  # Ignore shutdown errors\n\n    # Close connections\n    if self._ws:\n        await self._ws.close()\n        self._ws = None\n\n    if self._http_client:\n        await self._http_client.aclose()\n        self._http_client = None\n\n    self._tools.clear()\n    self._server_info = None\n\n    logger.info(\"Disconnected from MCP server\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    await self.connect()\n    return self\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    await self.disconnect()\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer","title":"<code>MCPServer</code>","text":"<p>Server that exposes AgentiCraft tools via MCP.</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>class MCPServer:\n    \"\"\"Server that exposes AgentiCraft tools via MCP.\"\"\"\n\n    def __init__(\n        self,\n        name: str = \"AgentiCraft MCP Server\",\n        version: str = \"0.1.0\",\n        description: Optional[str] = None\n    ):\n        \"\"\"Initialize MCP server.\n\n        Args:\n            name: Server name\n            version: Server version\n            description: Optional server description\n        \"\"\"\n        self.server_info = MCPServerInfo(\n            name=name,\n            version=version,\n            description=description or \"AgentiCraft tools exposed via MCP\",\n            capabilities=[\n                MCPCapability.TOOLS,\n                MCPCapability.CANCELLATION,\n            ]\n        )\n\n        self._tool_registry = ToolRegistry()\n        self._handlers: Dict[str, Callable] = {\n            MCPMethod.INITIALIZE.value: self._handle_initialize,\n            MCPMethod.SHUTDOWN.value: self._handle_shutdown,\n            MCPMethod.GET_INFO.value: self._handle_get_info,\n            MCPMethod.GET_CAPABILITIES.value: self._handle_get_capabilities,\n            MCPMethod.LIST_TOOLS.value: self._handle_list_tools,\n            MCPMethod.DESCRIBE_TOOL.value: self._handle_describe_tool,\n            MCPMethod.CALL_TOOL.value: self._handle_call_tool,\n        }\n\n        # For HTTP mode\n        self._app: Optional[FastAPI] = None\n\n    def register_tool(self, tool: Union[BaseTool, Callable]) -&gt; None:\n        \"\"\"Register a tool to expose via MCP.\n\n        Args:\n            tool: Tool to register\n        \"\"\"\n        self._tool_registry.register(tool)\n        logger.info(f\"Registered tool for MCP: {tool.name if hasattr(tool, 'name') else tool.__name__}\")\n\n    def register_tools(self, tools: List[Union[BaseTool, Callable]]) -&gt; None:\n        \"\"\"Register multiple tools.\n\n        Args:\n            tools: List of tools to register\n        \"\"\"\n        for tool in tools:\n            self.register_tool(tool)\n\n    async def handle_request(self, request: MCPRequest) -&gt; MCPResponse:\n        \"\"\"Handle an MCP request.\n\n        Args:\n            request: The MCP request\n\n        Returns:\n            The MCP response\n        \"\"\"\n        try:\n            # Validate request\n            if not request.method:\n                return self._error_response(\n                    MCPErrorCode.INVALID_REQUEST,\n                    \"Missing method\",\n                    request.id\n                )\n\n            # Get handler\n            handler = self._handlers.get(request.method)\n            if not handler:\n                return self._error_response(\n                    MCPErrorCode.METHOD_NOT_FOUND,\n                    f\"Unknown method: {request.method}\",\n                    request.id\n                )\n\n            # Execute handler\n            result = await handler(request.params or {})\n\n            return MCPResponse(\n                id=request.id,\n                result=result\n            )\n\n        except Exception as e:\n            logger.error(f\"Request handling error: {e}\")\n            return self._error_response(\n                MCPErrorCode.INTERNAL_ERROR,\n                str(e),\n                request.id\n            )\n\n    def _error_response(\n        self,\n        code: MCPErrorCode,\n        message: str,\n        request_id: Union[str, int, None] = None\n    ) -&gt; MCPResponse:\n        \"\"\"Create an error response.\"\"\"\n        return MCPResponse(\n            id=request_id,\n            error=MCPError(code=code, message=message)\n        )\n\n    async def _handle_initialize(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle initialization request.\"\"\"\n        return {\n            \"protocolVersion\": \"1.0\",\n            \"serverInfo\": self.server_info.to_dict()\n        }\n\n    async def _handle_shutdown(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle shutdown request.\"\"\"\n        return {\"status\": \"ok\"}\n\n    async def _handle_get_info(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle server info request.\"\"\"\n        return self.server_info.to_dict()\n\n    async def _handle_get_capabilities(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle capabilities request.\"\"\"\n        return {\n            \"capabilities\": [cap.value for cap in self.server_info.capabilities]\n        }\n\n    async def _handle_list_tools(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle list tools request.\"\"\"\n        tools = []\n\n        for tool_name in self._tool_registry.list_tools():\n            tool = self._tool_registry.get(tool_name)\n            mcp_tool = self._convert_to_mcp_tool(tool)\n            tools.append(mcp_tool.to_json_schema())\n\n        return {\"tools\": tools}\n\n    async def _handle_describe_tool(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle describe tool request.\"\"\"\n        tool_name = params.get(\"name\")\n        if not tool_name:\n            raise ValueError(\"Missing tool name\")\n\n        try:\n            tool = self._tool_registry.get(tool_name)\n            mcp_tool = self._convert_to_mcp_tool(tool)\n            return mcp_tool.to_json_schema()\n        except ToolNotFoundError:\n            raise ValueError(f\"Tool not found: {tool_name}\")\n\n    async def _handle_call_tool(self, params: Dict[str, Any]) -&gt; Any:\n        \"\"\"Handle tool call request.\"\"\"\n        tool_name = params.get(\"tool\")\n        arguments = params.get(\"arguments\", {})\n\n        if not tool_name:\n            raise ValueError(\"Missing tool name\")\n\n        try:\n            result = await self._tool_registry.execute(tool_name, **arguments)\n            return result\n        except ToolNotFoundError:\n            raise ValueError(f\"Tool not found: {tool_name}\")\n        except Exception as e:\n            logger.error(f\"Tool execution error: {e}\")\n            raise\n\n    def _convert_to_mcp_tool(self, tool: BaseTool) -&gt; MCPTool:\n        \"\"\"Convert AgentiCraft tool to MCP tool.\"\"\"\n        definition = tool.get_definition()\n\n        parameters = []\n        for param in definition.parameters:\n            mcp_param = MCPToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description,\n                required=param.required,\n                default=param.default,\n                enum=param.enum\n            )\n            parameters.append(mcp_param)\n\n        return MCPTool(\n            name=definition.name,\n            description=definition.description,\n            parameters=parameters\n        )\n\n    # WebSocket server methods\n    async def start_websocket_server(\n        self,\n        host: str = \"localhost\",\n        port: int = 3000\n    ) -&gt; None:\n        \"\"\"Start WebSocket server.\n\n        Args:\n            host: Host to bind to\n            port: Port to bind to\n        \"\"\"\n        if not HAS_WEBSOCKETS:\n            raise ImportError(\n                \"WebSocket support requires 'websockets' package. \"\n                \"Install with: pip install agenticraft[websocket]\"\n            )\n\n        logger.info(f\"Starting MCP WebSocket server on {host}:{port}\")\n\n        async with websockets.serve(\n            self._handle_websocket_connection,\n            host,\n            port\n        ):\n            await asyncio.Future()  # Run forever\n\n    async def _handle_websocket_connection(\n        self,\n        websocket: WebSocketServerProtocol,\n        path: str\n    ) -&gt; None:\n        \"\"\"Handle WebSocket connection.\"\"\"\n        logger.info(f\"New WebSocket connection from {websocket.remote_address}\")\n\n        try:\n            async for message in websocket:\n                try:\n                    # Parse request\n                    data = json.loads(message)\n                    request = MCPRequest(**data)\n\n                    # Handle request\n                    response = await self.handle_request(request)\n\n                    # Send response\n                    await websocket.send(json.dumps(response.to_dict()))\n\n                except json.JSONDecodeError:\n                    error_response = self._error_response(\n                        MCPErrorCode.PARSE_ERROR,\n                        \"Invalid JSON\"\n                    )\n                    await websocket.send(json.dumps(error_response.to_dict()))\n                except Exception as e:\n                    logger.error(f\"Message handling error: {e}\")\n                    error_response = self._error_response(\n                        MCPErrorCode.INTERNAL_ERROR,\n                        str(e)\n                    )\n                    await websocket.send(json.dumps(error_response.to_dict()))\n\n        except websockets.exceptions.ConnectionClosed:\n            logger.info(\"WebSocket connection closed\")\n        except Exception as e:\n            logger.error(f\"WebSocket error: {e}\")\n\n    # HTTP server methods\n    def create_fastapi_app(self) -&gt; FastAPI:\n        \"\"\"Create FastAPI app for HTTP mode.\n\n        Returns:\n            FastAPI application\n        \"\"\"\n        if self._app is None:\n            self._app = FastAPI(\n                title=self.server_info.name,\n                version=self.server_info.version,\n                description=self.server_info.description\n            )\n\n            # Add RPC endpoint\n            @self._app.post(\"/rpc\")\n            async def handle_rpc(request: Request) -&gt; JSONResponse:\n                try:\n                    data = await request.json()\n                    mcp_request = MCPRequest(**data)\n                    response = await self.handle_request(mcp_request)\n                    return JSONResponse(content=response.to_dict())\n                except Exception as e:\n                    logger.error(f\"HTTP request error: {e}\")\n                    error_response = self._error_response(\n                        MCPErrorCode.INTERNAL_ERROR,\n                        str(e)\n                    )\n                    return JSONResponse(\n                        content=error_response.to_dict(),\n                        status_code=500\n                    )\n\n            # Add health check\n            @self._app.get(\"/health\")\n            async def health_check():\n                return {\"status\": \"ok\", \"server\": self.server_info.name}\n\n        return self._app\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.__init__","title":"<code>__init__(name='AgentiCraft MCP Server', version='0.1.0', description=None)</code>","text":"<p>Initialize MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> <code>'AgentiCraft MCP Server'</code> <code>version</code> <code>str</code> <p>Server version</p> <code>'0.1.0'</code> <code>description</code> <code>Optional[str]</code> <p>Optional server description</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"AgentiCraft MCP Server\",\n    version: str = \"0.1.0\",\n    description: Optional[str] = None\n):\n    \"\"\"Initialize MCP server.\n\n    Args:\n        name: Server name\n        version: Server version\n        description: Optional server description\n    \"\"\"\n    self.server_info = MCPServerInfo(\n        name=name,\n        version=version,\n        description=description or \"AgentiCraft tools exposed via MCP\",\n        capabilities=[\n            MCPCapability.TOOLS,\n            MCPCapability.CANCELLATION,\n        ]\n    )\n\n    self._tool_registry = ToolRegistry()\n    self._handlers: Dict[str, Callable] = {\n        MCPMethod.INITIALIZE.value: self._handle_initialize,\n        MCPMethod.SHUTDOWN.value: self._handle_shutdown,\n        MCPMethod.GET_INFO.value: self._handle_get_info,\n        MCPMethod.GET_CAPABILITIES.value: self._handle_get_capabilities,\n        MCPMethod.LIST_TOOLS.value: self._handle_list_tools,\n        MCPMethod.DESCRIBE_TOOL.value: self._handle_describe_tool,\n        MCPMethod.CALL_TOOL.value: self._handle_call_tool,\n    }\n\n    # For HTTP mode\n    self._app: Optional[FastAPI] = None\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.register_tool","title":"<code>register_tool(tool)</code>","text":"<p>Register a tool to expose via MCP.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, Callable]</code> <p>Tool to register</p> required Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def register_tool(self, tool: Union[BaseTool, Callable]) -&gt; None:\n    \"\"\"Register a tool to expose via MCP.\n\n    Args:\n        tool: Tool to register\n    \"\"\"\n    self._tool_registry.register(tool)\n    logger.info(f\"Registered tool for MCP: {tool.name if hasattr(tool, 'name') else tool.__name__}\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.register_tools","title":"<code>register_tools(tools)</code>","text":"<p>Register multiple tools.</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>List[Union[BaseTool, Callable]]</code> <p>List of tools to register</p> required Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def register_tools(self, tools: List[Union[BaseTool, Callable]]) -&gt; None:\n    \"\"\"Register multiple tools.\n\n    Args:\n        tools: List of tools to register\n    \"\"\"\n    for tool in tools:\n        self.register_tool(tool)\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.handle_request","title":"<code>handle_request(request)</code>  <code>async</code>","text":"<p>Handle an MCP request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>MCPRequest</code> <p>The MCP request</p> required <p>Returns:</p> Type Description <code>MCPResponse</code> <p>The MCP response</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>async def handle_request(self, request: MCPRequest) -&gt; MCPResponse:\n    \"\"\"Handle an MCP request.\n\n    Args:\n        request: The MCP request\n\n    Returns:\n        The MCP response\n    \"\"\"\n    try:\n        # Validate request\n        if not request.method:\n            return self._error_response(\n                MCPErrorCode.INVALID_REQUEST,\n                \"Missing method\",\n                request.id\n            )\n\n        # Get handler\n        handler = self._handlers.get(request.method)\n        if not handler:\n            return self._error_response(\n                MCPErrorCode.METHOD_NOT_FOUND,\n                f\"Unknown method: {request.method}\",\n                request.id\n            )\n\n        # Execute handler\n        result = await handler(request.params or {})\n\n        return MCPResponse(\n            id=request.id,\n            result=result\n        )\n\n    except Exception as e:\n        logger.error(f\"Request handling error: {e}\")\n        return self._error_response(\n            MCPErrorCode.INTERNAL_ERROR,\n            str(e),\n            request.id\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.start_websocket_server","title":"<code>start_websocket_server(host='localhost', port=3000)</code>  <code>async</code>","text":"<p>Start WebSocket server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host to bind to</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port to bind to</p> <code>3000</code> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>async def start_websocket_server(\n    self,\n    host: str = \"localhost\",\n    port: int = 3000\n) -&gt; None:\n    \"\"\"Start WebSocket server.\n\n    Args:\n        host: Host to bind to\n        port: Port to bind to\n    \"\"\"\n    if not HAS_WEBSOCKETS:\n        raise ImportError(\n            \"WebSocket support requires 'websockets' package. \"\n            \"Install with: pip install agenticraft[websocket]\"\n        )\n\n    logger.info(f\"Starting MCP WebSocket server on {host}:{port}\")\n\n    async with websockets.serve(\n        self._handle_websocket_connection,\n        host,\n        port\n    ):\n        await asyncio.Future()  # Run forever\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPServer.create_fastapi_app","title":"<code>create_fastapi_app()</code>","text":"<p>Create FastAPI app for HTTP mode.</p> <p>Returns:</p> Type Description <code>FastAPI</code> <p>FastAPI application</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def create_fastapi_app(self) -&gt; FastAPI:\n    \"\"\"Create FastAPI app for HTTP mode.\n\n    Returns:\n        FastAPI application\n    \"\"\"\n    if self._app is None:\n        self._app = FastAPI(\n            title=self.server_info.name,\n            version=self.server_info.version,\n            description=self.server_info.description\n        )\n\n        # Add RPC endpoint\n        @self._app.post(\"/rpc\")\n        async def handle_rpc(request: Request) -&gt; JSONResponse:\n            try:\n                data = await request.json()\n                mcp_request = MCPRequest(**data)\n                response = await self.handle_request(mcp_request)\n                return JSONResponse(content=response.to_dict())\n            except Exception as e:\n                logger.error(f\"HTTP request error: {e}\")\n                error_response = self._error_response(\n                    MCPErrorCode.INTERNAL_ERROR,\n                    str(e)\n                )\n                return JSONResponse(\n                    content=error_response.to_dict(),\n                    status_code=500\n                )\n\n        # Add health check\n        @self._app.get(\"/health\")\n        async def health_check():\n            return {\"status\": \"ok\", \"server\": self.server_info.name}\n\n    return self._app\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry","title":"<code>MCPRegistry</code>","text":"<p>Registry for MCP tools.</p> <p>This registry manages MCP tool definitions and provides methods for tool discovery and validation.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>class MCPRegistry:\n    \"\"\"Registry for MCP tools.\n\n    This registry manages MCP tool definitions and provides\n    methods for tool discovery and validation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP registry.\"\"\"\n        self._tools: Dict[str, MCPTool] = {}\n        self._categories: Dict[str, Set[str]] = {}\n        self._adapters: Dict[str, BaseTool] = {}\n\n    def register_mcp_tool(\n        self,\n        tool: MCPTool,\n        category: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Register an MCP tool.\n\n        Args:\n            tool: MCP tool to register\n            category: Optional category for organization\n        \"\"\"\n        if tool.name in self._tools:\n            logger.warning(f\"Overwriting existing MCP tool: {tool.name}\")\n\n        self._tools[tool.name] = tool\n\n        if category:\n            if category not in self._categories:\n                self._categories[category] = set()\n            self._categories[category].add(tool.name)\n\n        logger.info(f\"Registered MCP tool: {tool.name}\")\n\n    def register_agenticraft_tool(\n        self,\n        tool: BaseTool,\n        category: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Register an AgentiCraft tool as MCP tool.\n\n        Args:\n            tool: AgentiCraft tool to register\n            category: Optional category\n        \"\"\"\n        # Convert to MCP tool\n        mcp_tool = self._convert_to_mcp_tool(tool)\n        self.register_mcp_tool(mcp_tool, category)\n\n        # Store adapter\n        self._adapters[tool.name] = tool\n\n    def _convert_to_mcp_tool(self, tool: BaseTool) -&gt; MCPTool:\n        \"\"\"Convert AgentiCraft tool to MCP tool.\"\"\"\n        definition = tool.get_definition()\n\n        parameters = []\n        for param in definition.parameters:\n            mcp_param = MCPToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description,\n                required=param.required,\n                default=param.default,\n                enum=param.enum\n            )\n            parameters.append(mcp_param)\n\n        return MCPTool(\n            name=definition.name,\n            description=definition.description,\n            parameters=parameters\n        )\n\n    def get_tool(self, name: str) -&gt; MCPTool:\n        \"\"\"Get an MCP tool by name.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            MCP tool\n\n        Raises:\n            ToolNotFoundError: If tool not found\n        \"\"\"\n        if name not in self._tools:\n            raise ToolNotFoundError(name)\n        return self._tools[name]\n\n    def get_adapter(self, name: str) -&gt; Optional[BaseTool]:\n        \"\"\"Get AgentiCraft adapter for a tool.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            AgentiCraft tool adapter if available\n        \"\"\"\n        return self._adapters.get(name)\n\n    def list_tools(self, category: Optional[str] = None) -&gt; List[str]:\n        \"\"\"List tool names.\n\n        Args:\n            category: Optional category filter\n\n        Returns:\n            List of tool names\n        \"\"\"\n        if category:\n            return list(self._categories.get(category, set()))\n        return list(self._tools.keys())\n\n    def list_categories(self) -&gt; List[str]:\n        \"\"\"List available categories.\n\n        Returns:\n            List of category names\n        \"\"\"\n        return list(self._categories.keys())\n\n    def get_tools_by_category(self, category: str) -&gt; List[MCPTool]:\n        \"\"\"Get all tools in a category.\n\n        Args:\n            category: Category name\n\n        Returns:\n            List of MCP tools\n        \"\"\"\n        tool_names = self._categories.get(category, set())\n        return [self._tools[name] for name in tool_names if name in self._tools]\n\n    def search_tools(self, query: str) -&gt; List[MCPTool]:\n        \"\"\"Search for tools by name or description.\n\n        Args:\n            query: Search query\n\n        Returns:\n            List of matching tools\n        \"\"\"\n        query_lower = query.lower()\n        matches = []\n\n        for tool in self._tools.values():\n            if (query_lower in tool.name.lower() or \n                query_lower in tool.description.lower()):\n                matches.append(tool)\n\n        return matches\n\n    def validate_tool_call(\n        self,\n        tool_name: str,\n        arguments: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Validate tool call arguments.\n\n        Args:\n            tool_name: Tool name\n            arguments: Tool arguments\n\n        Raises:\n            ToolNotFoundError: If tool not found\n            ToolError: If arguments are invalid\n        \"\"\"\n        tool = self.get_tool(tool_name)\n\n        # Check required parameters\n        required_params = {\n            param.name for param in tool.parameters if param.required\n        }\n        provided_params = set(arguments.keys())\n\n        missing = required_params - provided_params\n        if missing:\n            raise ToolError(\n                f\"Missing required parameters for {tool_name}: {missing}\"\n            )\n\n        # Check parameter types (basic validation)\n        for param in tool.parameters:\n            if param.name in arguments:\n                value = arguments[param.name]\n\n                # Check enum values\n                if param.enum and value not in param.enum:\n                    raise ToolError(\n                        f\"Invalid value for {param.name}: {value}. \"\n                        f\"Must be one of: {param.enum}\"\n                    )\n\n    def export_tools(self) -&gt; Dict[str, Any]:\n        \"\"\"Export all tools as JSON-serializable dict.\n\n        Returns:\n            Dictionary of tools\n        \"\"\"\n        return {\n            \"tools\": [tool.to_json_schema() for tool in self._tools.values()],\n            \"categories\": {\n                cat: list(tools) for cat, tools in self._categories.items()\n            }\n        }\n\n    def import_tools(self, data: Dict[str, Any]) -&gt; None:\n        \"\"\"Import tools from exported data.\n\n        Args:\n            data: Exported tools data\n        \"\"\"\n        # Clear existing\n        self._tools.clear()\n        self._categories.clear()\n\n        # Import tools\n        for tool_data in data.get(\"tools\", []):\n            tool = MCPTool(**tool_data)\n            self._tools[tool.name] = tool\n\n        # Import categories\n        for category, tool_names in data.get(\"categories\", {}).items():\n            self._categories[category] = set(tool_names)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered tools.\"\"\"\n        self._tools.clear()\n        self._categories.clear()\n        self._adapters.clear()\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get number of registered tools.\"\"\"\n        return len(self._tools)\n\n    def __contains__(self, tool_name: str) -&gt; bool:\n        \"\"\"Check if tool is registered.\"\"\"\n        return tool_name in self._tools\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the MCP registry.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the MCP registry.\"\"\"\n    self._tools: Dict[str, MCPTool] = {}\n    self._categories: Dict[str, Set[str]] = {}\n    self._adapters: Dict[str, BaseTool] = {}\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.register_mcp_tool","title":"<code>register_mcp_tool(tool, category=None)</code>","text":"<p>Register an MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>MCPTool</code> <p>MCP tool to register</p> required <code>category</code> <code>Optional[str]</code> <p>Optional category for organization</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def register_mcp_tool(\n    self,\n    tool: MCPTool,\n    category: Optional[str] = None\n) -&gt; None:\n    \"\"\"Register an MCP tool.\n\n    Args:\n        tool: MCP tool to register\n        category: Optional category for organization\n    \"\"\"\n    if tool.name in self._tools:\n        logger.warning(f\"Overwriting existing MCP tool: {tool.name}\")\n\n    self._tools[tool.name] = tool\n\n    if category:\n        if category not in self._categories:\n            self._categories[category] = set()\n        self._categories[category].add(tool.name)\n\n    logger.info(f\"Registered MCP tool: {tool.name}\")\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.register_agenticraft_tool","title":"<code>register_agenticraft_tool(tool, category=None)</code>","text":"<p>Register an AgentiCraft tool as MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>BaseTool</code> <p>AgentiCraft tool to register</p> required <code>category</code> <code>Optional[str]</code> <p>Optional category</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def register_agenticraft_tool(\n    self,\n    tool: BaseTool,\n    category: Optional[str] = None\n) -&gt; None:\n    \"\"\"Register an AgentiCraft tool as MCP tool.\n\n    Args:\n        tool: AgentiCraft tool to register\n        category: Optional category\n    \"\"\"\n    # Convert to MCP tool\n    mcp_tool = self._convert_to_mcp_tool(tool)\n    self.register_mcp_tool(mcp_tool, category)\n\n    # Store adapter\n    self._adapters[tool.name] = tool\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.get_tool","title":"<code>get_tool(name)</code>","text":"<p>Get an MCP tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>MCPTool</code> <p>MCP tool</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_tool(self, name: str) -&gt; MCPTool:\n    \"\"\"Get an MCP tool by name.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        MCP tool\n\n    Raises:\n        ToolNotFoundError: If tool not found\n    \"\"\"\n    if name not in self._tools:\n        raise ToolNotFoundError(name)\n    return self._tools[name]\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.get_adapter","title":"<code>get_adapter(name)</code>","text":"<p>Get AgentiCraft adapter for a tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>Optional[BaseTool]</code> <p>AgentiCraft tool adapter if available</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_adapter(self, name: str) -&gt; Optional[BaseTool]:\n    \"\"\"Get AgentiCraft adapter for a tool.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        AgentiCraft tool adapter if available\n    \"\"\"\n    return self._adapters.get(name)\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.list_tools","title":"<code>list_tools(category=None)</code>","text":"<p>List tool names.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>Optional[str]</code> <p>Optional category filter</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of tool names</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def list_tools(self, category: Optional[str] = None) -&gt; List[str]:\n    \"\"\"List tool names.\n\n    Args:\n        category: Optional category filter\n\n    Returns:\n        List of tool names\n    \"\"\"\n    if category:\n        return list(self._categories.get(category, set()))\n    return list(self._tools.keys())\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.list_categories","title":"<code>list_categories()</code>","text":"<p>List available categories.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of category names</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def list_categories(self) -&gt; List[str]:\n    \"\"\"List available categories.\n\n    Returns:\n        List of category names\n    \"\"\"\n    return list(self._categories.keys())\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.get_tools_by_category","title":"<code>get_tools_by_category(category)</code>","text":"<p>Get all tools in a category.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Category name</p> required <p>Returns:</p> Type Description <code>List[MCPTool]</code> <p>List of MCP tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_tools_by_category(self, category: str) -&gt; List[MCPTool]:\n    \"\"\"Get all tools in a category.\n\n    Args:\n        category: Category name\n\n    Returns:\n        List of MCP tools\n    \"\"\"\n    tool_names = self._categories.get(category, set())\n    return [self._tools[name] for name in tool_names if name in self._tools]\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.search_tools","title":"<code>search_tools(query)</code>","text":"<p>Search for tools by name or description.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <p>Returns:</p> Type Description <code>List[MCPTool]</code> <p>List of matching tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def search_tools(self, query: str) -&gt; List[MCPTool]:\n    \"\"\"Search for tools by name or description.\n\n    Args:\n        query: Search query\n\n    Returns:\n        List of matching tools\n    \"\"\"\n    query_lower = query.lower()\n    matches = []\n\n    for tool in self._tools.values():\n        if (query_lower in tool.name.lower() or \n            query_lower in tool.description.lower()):\n            matches.append(tool)\n\n    return matches\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.validate_tool_call","title":"<code>validate_tool_call(tool_name, arguments)</code>","text":"<p>Validate tool call arguments.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Tool name</p> required <code>arguments</code> <code>Dict[str, Any]</code> <p>Tool arguments</p> required <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> <code>ToolError</code> <p>If arguments are invalid</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def validate_tool_call(\n    self,\n    tool_name: str,\n    arguments: Dict[str, Any]\n) -&gt; None:\n    \"\"\"Validate tool call arguments.\n\n    Args:\n        tool_name: Tool name\n        arguments: Tool arguments\n\n    Raises:\n        ToolNotFoundError: If tool not found\n        ToolError: If arguments are invalid\n    \"\"\"\n    tool = self.get_tool(tool_name)\n\n    # Check required parameters\n    required_params = {\n        param.name for param in tool.parameters if param.required\n    }\n    provided_params = set(arguments.keys())\n\n    missing = required_params - provided_params\n    if missing:\n        raise ToolError(\n            f\"Missing required parameters for {tool_name}: {missing}\"\n        )\n\n    # Check parameter types (basic validation)\n    for param in tool.parameters:\n        if param.name in arguments:\n            value = arguments[param.name]\n\n            # Check enum values\n            if param.enum and value not in param.enum:\n                raise ToolError(\n                    f\"Invalid value for {param.name}: {value}. \"\n                    f\"Must be one of: {param.enum}\"\n                )\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.export_tools","title":"<code>export_tools()</code>","text":"<p>Export all tools as JSON-serializable dict.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def export_tools(self) -&gt; Dict[str, Any]:\n    \"\"\"Export all tools as JSON-serializable dict.\n\n    Returns:\n        Dictionary of tools\n    \"\"\"\n    return {\n        \"tools\": [tool.to_json_schema() for tool in self._tools.values()],\n        \"categories\": {\n            cat: list(tools) for cat, tools in self._categories.items()\n        }\n    }\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.import_tools","title":"<code>import_tools(data)</code>","text":"<p>Import tools from exported data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Exported tools data</p> required Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def import_tools(self, data: Dict[str, Any]) -&gt; None:\n    \"\"\"Import tools from exported data.\n\n    Args:\n        data: Exported tools data\n    \"\"\"\n    # Clear existing\n    self._tools.clear()\n    self._categories.clear()\n\n    # Import tools\n    for tool_data in data.get(\"tools\", []):\n        tool = MCPTool(**tool_data)\n        self._tools[tool.name] = tool\n\n    # Import categories\n    for category, tool_names in data.get(\"categories\", {}).items():\n        self._categories[category] = set(tool_names)\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered tools.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered tools.\"\"\"\n    self._tools.clear()\n    self._categories.clear()\n    self._adapters.clear()\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.__len__","title":"<code>__len__()</code>","text":"<p>Get number of registered tools.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get number of registered tools.\"\"\"\n    return len(self._tools)\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRegistry.__contains__","title":"<code>__contains__(tool_name)</code>","text":"<p>Check if tool is registered.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __contains__(self, tool_name: str) -&gt; bool:\n    \"\"\"Check if tool is registered.\"\"\"\n    return tool_name in self._tools\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRequest","title":"<code>MCPRequest</code>  <code>dataclass</code>","text":"<p>MCP request message.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPRequest:\n    \"\"\"MCP request message.\"\"\"\n\n    jsonrpc: str = \"2.0\"\n    method: MCPMethod = MCPMethod.LIST_TOOLS\n    params: Optional[Dict[str, Any]] = None\n    id: Union[str, int] = field(default_factory=lambda: str(uuid4()))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        data = {\n            \"jsonrpc\": self.jsonrpc,\n            \"method\": self.method.value,\n            \"id\": self.id\n        }\n        if self.params is not None:\n            data[\"params\"] = self.params\n        return data\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPRequest.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    data = {\n        \"jsonrpc\": self.jsonrpc,\n        \"method\": self.method.value,\n        \"id\": self.id\n    }\n    if self.params is not None:\n        data[\"params\"] = self.params\n    return data\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPResponse","title":"<code>MCPResponse</code>  <code>dataclass</code>","text":"<p>MCP response message.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPResponse:\n    \"\"\"MCP response message.\"\"\"\n\n    jsonrpc: str = \"2.0\"\n    id: Union[str, int, None] = None\n    result: Optional[Any] = None\n    error: Optional[\"MCPError\"] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        data = {\n            \"jsonrpc\": self.jsonrpc,\n            \"id\": self.id\n        }\n\n        if self.error is not None:\n            data[\"error\"] = self.error.to_dict()\n        else:\n            data[\"result\"] = self.result\n\n        return data\n\n    @property\n    def is_error(self) -&gt; bool:\n        \"\"\"Check if response is an error.\"\"\"\n        return self.error is not None\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPResponse.is_error","title":"<code>is_error</code>  <code>property</code>","text":"<p>Check if response is an error.</p>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPResponse.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    data = {\n        \"jsonrpc\": self.jsonrpc,\n        \"id\": self.id\n    }\n\n    if self.error is not None:\n        data[\"error\"] = self.error.to_dict()\n    else:\n        data[\"result\"] = self.result\n\n    return data\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPTool","title":"<code>MCPTool</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>MCP tool definition.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPTool(BaseModel):\n    \"\"\"MCP tool definition.\"\"\"\n\n    name: str\n    description: str\n    parameters: List[MCPToolParameter] = Field(default_factory=list)\n    returns: Optional[Dict[str, Any]] = None  # JSON Schema for return type\n    examples: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def to_json_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to JSON Schema format for tool definition.\"\"\"\n        properties = {}\n        required = []\n\n        for param in self.parameters:\n            properties[param.name] = param.to_json_schema()\n            if param.required:\n                required.append(param.name)\n\n        schema = {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required\n            }\n        }\n\n        if self.returns:\n            schema[\"returnSchema\"] = self.returns\n\n        if self.examples:\n            schema[\"examples\"] = self.examples\n\n        return schema\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPTool.to_json_schema","title":"<code>to_json_schema()</code>","text":"<p>Convert to JSON Schema format for tool definition.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_json_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to JSON Schema format for tool definition.\"\"\"\n    properties = {}\n    required = []\n\n    for param in self.parameters:\n        properties[param.name] = param.to_json_schema()\n        if param.required:\n            required.append(param.name)\n\n    schema = {\n        \"name\": self.name,\n        \"description\": self.description,\n        \"inputSchema\": {\n            \"type\": \"object\",\n            \"properties\": properties,\n            \"required\": required\n        }\n    }\n\n    if self.returns:\n        schema[\"returnSchema\"] = self.returns\n\n    if self.examples:\n        schema[\"examples\"] = self.examples\n\n    return schema\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPError","title":"<code>MCPError</code>  <code>dataclass</code>","text":"<p>MCP error structure.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPError:\n    \"\"\"MCP error structure.\"\"\"\n\n    code: MCPErrorCode\n    message: str\n    data: Optional[Any] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        error_dict = {\n            \"code\": self.code.value,\n            \"message\": self.message\n        }\n        if self.data is not None:\n            error_dict[\"data\"] = self.data\n        return error_dict\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPError.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    error_dict = {\n        \"code\": self.code.value,\n        \"message\": self.message\n    }\n    if self.data is not None:\n        error_dict[\"data\"] = self.data\n    return error_dict\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.MCPCapability","title":"<code>MCPCapability</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>MCP server capabilities.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPCapability(str, Enum):\n    \"\"\"MCP server capabilities.\"\"\"\n\n    TOOLS = \"tools\"\n    STREAMING = \"streaming\"\n    CANCELLATION = \"cancellation\"\n    PROGRESS = \"progress\"\n    MULTI_TOOL = \"multi_tool\"\n</code></pre>"},{"location":"reference/protocols/mcp/__init__/#agenticraft.protocols.mcp.mcp_tool","title":"<code>mcp_tool(*args, name=None, description=None, returns=None, examples=None, **kwargs)</code>","text":"<p>Decorator for creating MCP tools with additional metadata.</p> <p>This is an enhanced version of the @tool decorator that allows specifying MCP-specific metadata like return schemas and examples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override tool description</p> <code>None</code> <code>returns</code> <code>Optional[Dict[str, Any]]</code> <p>JSON schema for return value</p> <code>None</code> <code>examples</code> <code>Optional[List[Dict[str, Any]]]</code> <p>List of input/output examples</p> <code>None</code> <code>**kwargs</code> <p>Additional metadata</p> <code>{}</code> Example <p>@mcp_tool(     returns={\"type\": \"object\", \"properties\": {\"result\": {\"type\": \"string\"}}},     examples=[{\"input\": {\"text\": \"hello\"}, \"output\": {\"result\": \"HELLO\"}}] ) def uppercase(text: str) -&gt; Dict[str, str]:     return {\"result\": text.upper()}</p> Source code in <code>agenticraft/protocols/mcp/decorators.py</code> <pre><code>def mcp_tool(\n    *args,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    returns: Optional[Dict[str, Any]] = None,\n    examples: Optional[List[Dict[str, Any]]] = None,\n    **kwargs\n) -&gt; Callable:\n    \"\"\"Decorator for creating MCP tools with additional metadata.\n\n    This is an enhanced version of the @tool decorator that allows\n    specifying MCP-specific metadata like return schemas and examples.\n\n    Args:\n        name: Override tool name\n        description: Override tool description\n        returns: JSON schema for return value\n        examples: List of input/output examples\n        **kwargs: Additional metadata\n\n    Example:\n        @mcp_tool(\n            returns={\"type\": \"object\", \"properties\": {\"result\": {\"type\": \"string\"}}},\n            examples=[{\"input\": {\"text\": \"hello\"}, \"output\": {\"result\": \"HELLO\"}}]\n        )\n        def uppercase(text: str) -&gt; Dict[str, str]:\n            return {\"result\": text.upper()}\n    \"\"\"\n    def decorator(func: Callable) -&gt; Any:\n        # Create tool using base decorator\n        tool_instance = base_tool(name=name, description=description)(func)\n\n        # Add MCP-specific metadata\n        if returns is not None:\n            tool_instance._mcp_returns = returns\n        if examples is not None:\n            tool_instance._mcp_examples = examples\n\n        # Add any additional metadata\n        for key, value in kwargs.items():\n            setattr(tool_instance, f\"_mcp_{key}\", value)\n\n        return tool_instance\n\n    # Handle both @mcp_tool and @mcp_tool() syntax\n    if len(args) == 1 and callable(args[0]) and not any([name, description, returns, examples, kwargs]):\n        # Direct decoration: @mcp_tool\n        func = args[0]\n        return decorator(func)\n    else:\n        # With parameters: @mcp_tool(...)\n        return decorator\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/","title":"Adapters","text":""},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters","title":"<code>adapters</code>","text":"<p>Adapters for converting between AgentiCraft and MCP formats.</p> <p>This module provides adapters to seamlessly use MCP tools in AgentiCraft and expose AgentiCraft tools via MCP.</p>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.MCPToolWrapper","title":"<code>MCPToolWrapper</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Wrapper to use any Python function as an MCP tool.</p> <p>This wrapper allows exposing arbitrary Python functions via MCP without modifying the original function.</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>class MCPToolWrapper(BaseTool):\n    \"\"\"Wrapper to use any Python function as an MCP tool.\n\n    This wrapper allows exposing arbitrary Python functions via MCP\n    without modifying the original function.\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        parameters: Optional[List[MCPToolParameter]] = None,\n        returns: Optional[Dict[str, Any]] = None,\n        examples: Optional[List[Dict[str, Any]]] = None\n    ):\n        \"\"\"Initialize the wrapper.\n\n        Args:\n            func: Function to wrap\n            name: Tool name (defaults to function name)\n            description: Tool description (defaults to docstring)\n            parameters: Explicit parameter definitions\n            returns: Return type schema\n            examples: Example inputs/outputs\n        \"\"\"\n        import inspect\n\n        # Extract metadata\n        self.func = func\n        tool_name = name or func.__name__\n        tool_desc = description or func.__doc__ or f\"Function {func.__name__}\"\n\n        super().__init__(name=tool_name, description=tool_desc)\n\n        # Parse or use provided parameters\n        if parameters:\n            self.parameters = parameters\n        else:\n            self.parameters = self._parse_function_parameters(func)\n\n        self.returns = returns\n        self.examples = examples or []\n\n    def _parse_function_parameters(self, func: Callable) -&gt; List[MCPToolParameter]:\n        \"\"\"Parse function signature to extract parameters.\"\"\"\n        import inspect\n\n        sig = inspect.signature(func)\n        parameters = []\n\n        for param_name, param in sig.parameters.items():\n            if param_name == 'self':\n                continue\n\n            # Determine type\n            param_type = \"string\"  # default\n            if param.annotation != inspect.Parameter.empty:\n                type_map = {\n                    int: \"integer\",\n                    float: \"number\",\n                    str: \"string\",\n                    bool: \"boolean\",\n                    list: \"array\",\n                    dict: \"object\"\n                }\n                param_type = type_map.get(param.annotation, \"string\")\n\n            # Check if required\n            required = param.default == inspect.Parameter.empty\n\n            parameters.append(MCPToolParameter(\n                name=param_name,\n                type=param_type,\n                description=f\"Parameter {param_name}\",\n                required=required,\n                default=None if required else param.default\n            ))\n\n        return parameters\n\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Execute the wrapped function.\"\"\"\n        import asyncio\n\n        if asyncio.iscoroutinefunction(self.func):\n            return await self.func(**kwargs)\n        else:\n            return self.func(**kwargs)\n\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get tool definition.\"\"\"\n        parameters = []\n\n        for param in self.parameters:\n            tool_param = ToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description or f\"Parameter {param.name}\",\n                required=param.required,\n                default=param.default,\n                enum=param.enum\n            )\n            parameters.append(tool_param)\n\n        return ToolDefinition(\n            name=self.name,\n            description=self.description,\n            parameters=parameters\n        )\n\n    def get_mcp_tool(self) -&gt; MCPTool:\n        \"\"\"Get as MCP tool.\"\"\"\n        return MCPTool(\n            name=self.name,\n            description=self.description,\n            parameters=self.parameters,\n            returns=self.returns,\n            examples=self.examples\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.MCPToolWrapper.__init__","title":"<code>__init__(func, name=None, description=None, parameters=None, returns=None, examples=None)</code>","text":"<p>Initialize the wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to wrap</p> required <code>name</code> <code>Optional[str]</code> <p>Tool name (defaults to function name)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Tool description (defaults to docstring)</p> <code>None</code> <code>parameters</code> <code>Optional[List[MCPToolParameter]]</code> <p>Explicit parameter definitions</p> <code>None</code> <code>returns</code> <code>Optional[Dict[str, Any]]</code> <p>Return type schema</p> <code>None</code> <code>examples</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Example inputs/outputs</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def __init__(\n    self,\n    func: Callable,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    parameters: Optional[List[MCPToolParameter]] = None,\n    returns: Optional[Dict[str, Any]] = None,\n    examples: Optional[List[Dict[str, Any]]] = None\n):\n    \"\"\"Initialize the wrapper.\n\n    Args:\n        func: Function to wrap\n        name: Tool name (defaults to function name)\n        description: Tool description (defaults to docstring)\n        parameters: Explicit parameter definitions\n        returns: Return type schema\n        examples: Example inputs/outputs\n    \"\"\"\n    import inspect\n\n    # Extract metadata\n    self.func = func\n    tool_name = name or func.__name__\n    tool_desc = description or func.__doc__ or f\"Function {func.__name__}\"\n\n    super().__init__(name=tool_name, description=tool_desc)\n\n    # Parse or use provided parameters\n    if parameters:\n        self.parameters = parameters\n    else:\n        self.parameters = self._parse_function_parameters(func)\n\n    self.returns = returns\n    self.examples = examples or []\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.MCPToolWrapper.arun","title":"<code>arun(**kwargs)</code>  <code>async</code>","text":"<p>Execute the wrapped function.</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>async def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Execute the wrapped function.\"\"\"\n    import asyncio\n\n    if asyncio.iscoroutinefunction(self.func):\n        return await self.func(**kwargs)\n    else:\n        return self.func(**kwargs)\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.MCPToolWrapper.get_definition","title":"<code>get_definition()</code>","text":"<p>Get tool definition.</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get tool definition.\"\"\"\n    parameters = []\n\n    for param in self.parameters:\n        tool_param = ToolParameter(\n            name=param.name,\n            type=param.type,\n            description=param.description or f\"Parameter {param.name}\",\n            required=param.required,\n            default=param.default,\n            enum=param.enum\n        )\n        parameters.append(tool_param)\n\n    return ToolDefinition(\n        name=self.name,\n        description=self.description,\n        parameters=parameters\n    )\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.MCPToolWrapper.get_mcp_tool","title":"<code>get_mcp_tool()</code>","text":"<p>Get as MCP tool.</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def get_mcp_tool(self) -&gt; MCPTool:\n    \"\"\"Get as MCP tool.\"\"\"\n    return MCPTool(\n        name=self.name,\n        description=self.description,\n        parameters=self.parameters,\n        returns=self.returns,\n        examples=self.examples\n    )\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.mcp_tool_to_agenticraft","title":"<code>mcp_tool_to_agenticraft(mcp_tool)</code>","text":"<p>Convert MCP tool to AgentiCraft tool definition.</p> <p>Parameters:</p> Name Type Description Default <code>mcp_tool</code> <code>MCPTool</code> <p>MCP tool to convert</p> required <p>Returns:</p> Type Description <code>ToolDefinition</code> <p>AgentiCraft tool definition</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def mcp_tool_to_agenticraft(mcp_tool: MCPTool) -&gt; ToolDefinition:\n    \"\"\"Convert MCP tool to AgentiCraft tool definition.\n\n    Args:\n        mcp_tool: MCP tool to convert\n\n    Returns:\n        AgentiCraft tool definition\n    \"\"\"\n    parameters = []\n\n    for param in mcp_tool.parameters:\n        tool_param = ToolParameter(\n            name=param.name,\n            type=param.type,\n            description=param.description or f\"Parameter {param.name}\",\n            required=param.required,\n            default=param.default,\n            enum=param.enum\n        )\n        parameters.append(tool_param)\n\n    return ToolDefinition(\n        name=mcp_tool.name,\n        description=mcp_tool.description,\n        parameters=parameters\n    )\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.agenticraft_tool_to_mcp","title":"<code>agenticraft_tool_to_mcp(tool_def)</code>","text":"<p>Convert AgentiCraft tool definition to MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_def</code> <code>ToolDefinition</code> <p>AgentiCraft tool definition</p> required <p>Returns:</p> Type Description <code>MCPTool</code> <p>MCP tool</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def agenticraft_tool_to_mcp(tool_def: ToolDefinition) -&gt; MCPTool:\n    \"\"\"Convert AgentiCraft tool definition to MCP tool.\n\n    Args:\n        tool_def: AgentiCraft tool definition\n\n    Returns:\n        MCP tool\n    \"\"\"\n    parameters = []\n\n    for param in tool_def.parameters:\n        mcp_param = MCPToolParameter(\n            name=param.name,\n            type=param.type,\n            description=param.description,\n            required=param.required,\n            default=param.default,\n            enum=param.enum\n        )\n        parameters.append(mcp_param)\n\n    return MCPTool(\n        name=tool_def.name,\n        description=tool_def.description,\n        parameters=parameters\n    )\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.mcp_tool","title":"<code>mcp_tool(name=None, description=None, returns=None, examples=None)</code>","text":"<p>Decorator for MCP-compatible tools.</p> <p>This decorator creates tools that include MCP-specific metadata like return schemas and examples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[Union[str, Callable]]</code> <p>Tool name override (or function if used without parentheses)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Tool description override</p> <code>None</code> <code>returns</code> <code>Optional[Dict[str, Any]]</code> <p>JSON Schema for return type</p> <code>None</code> <code>examples</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Example inputs and outputs</p> <code>None</code> Example <p>Using the MCP tool decorator::</p> <pre><code>@mcp_tool(\n    name=\"weather\",\n    returns={\"type\": \"object\", \"properties\": {...}},\n    examples=[{\"input\": {\"city\": \"NYC\"}, \"output\": {...}}]\n)\ndef get_weather(city: str) -&gt; dict:\n    '''Get weather for a city.'''\n    return {\"temp\": 72, \"conditions\": \"sunny\"}\n\n# Or without parentheses:\n@mcp_tool\ndef simple_tool(x: int) -&gt; int:\n    '''Double a number.'''\n    return x * 2\n</code></pre> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def mcp_tool(\n    name: Optional[Union[str, Callable]] = None,\n    description: Optional[str] = None,\n    returns: Optional[Dict[str, Any]] = None,\n    examples: Optional[List[Dict[str, Any]]] = None\n):\n    \"\"\"Decorator for MCP-compatible tools.\n\n    This decorator creates tools that include MCP-specific metadata\n    like return schemas and examples.\n\n    Args:\n        name: Tool name override (or function if used without parentheses)\n        description: Tool description override\n        returns: JSON Schema for return type\n        examples: Example inputs and outputs\n\n    Example:\n        Using the MCP tool decorator::\n\n            @mcp_tool(\n                name=\"weather\",\n                returns={\"type\": \"object\", \"properties\": {...}},\n                examples=[{\"input\": {\"city\": \"NYC\"}, \"output\": {...}}]\n            )\n            def get_weather(city: str) -&gt; dict:\n                '''Get weather for a city.'''\n                return {\"temp\": 72, \"conditions\": \"sunny\"}\n\n            # Or without parentheses:\n            @mcp_tool\n            def simple_tool(x: int) -&gt; int:\n                '''Double a number.'''\n                return x * 2\n    \"\"\"\n    def decorator(func):\n        # Create base tool\n        base_tool = tool(name=name if isinstance(name, str) else None, description=description)(func)\n\n        # Add MCP metadata\n        base_tool._mcp_returns = returns\n        base_tool._mcp_examples = examples\n\n        # Override get_definition to include MCP data\n        original_get_definition = base_tool.get_definition\n\n        def get_definition_with_mcp():\n            definition = original_get_definition()\n\n            # Convert to MCP tool to include extra fields\n            mcp_tool_obj = agenticraft_tool_to_mcp(definition)\n            mcp_tool_obj.returns = returns\n            mcp_tool_obj.examples = examples or []\n\n            return definition\n\n        base_tool.get_definition = get_definition_with_mcp\n\n        # Add method to get MCP tool directly\n        def get_mcp_tool():\n            definition = original_get_definition()\n            mcp_tool_obj = agenticraft_tool_to_mcp(definition)\n            mcp_tool_obj.returns = returns\n            mcp_tool_obj.examples = examples or []\n            return mcp_tool_obj\n\n        base_tool.get_mcp_tool = get_mcp_tool\n\n        return base_tool\n\n    # Handle both @mcp_tool and @mcp_tool() syntax\n    if callable(name):\n        func = name\n        name = None\n        return decorator(func)\n\n    return decorator\n</code></pre>"},{"location":"reference/protocols/mcp/adapters/#agenticraft.protocols.mcp.adapters.wrap_function_as_mcp_tool","title":"<code>wrap_function_as_mcp_tool(func, **kwargs)</code>","text":"<p>Wrap a function as an MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to wrap</p> required <code>**kwargs</code> <code>Any</code> <p>Additional configuration</p> <code>{}</code> <p>Returns:</p> Type Description <code>MCPToolWrapper</code> <p>MCP tool wrapper</p> Source code in <code>agenticraft/protocols/mcp/adapters.py</code> <pre><code>def wrap_function_as_mcp_tool(\n    func: Callable,\n    **kwargs: Any\n) -&gt; MCPToolWrapper:\n    \"\"\"Wrap a function as an MCP tool.\n\n    Args:\n        func: Function to wrap\n        **kwargs: Additional configuration\n\n    Returns:\n        MCP tool wrapper\n    \"\"\"\n    return MCPToolWrapper(func, **kwargs)\n</code></pre>"},{"location":"reference/protocols/mcp/client/","title":"Client","text":""},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client","title":"<code>client</code>","text":"<p>MCP client implementation for AgentiCraft.</p> <p>This module provides the client for connecting to MCP servers, discovering tools, and executing them.</p>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPToolAdapter","title":"<code>MCPToolAdapter</code>","text":"<p>               Bases: <code>BaseTool</code></p> <p>Adapter to use MCP tools as AgentiCraft tools.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>class MCPToolAdapter(BaseTool):\n    \"\"\"Adapter to use MCP tools as AgentiCraft tools.\"\"\"\n\n    def __init__(self, mcp_tool: MCPTool, client: \"MCPClient\"):\n        \"\"\"Initialize the adapter.\n\n        Args:\n            mcp_tool: The MCP tool definition\n            client: The MCP client for executing the tool\n        \"\"\"\n        super().__init__(\n            name=mcp_tool.name,\n            description=mcp_tool.description\n        )\n        self.mcp_tool = mcp_tool\n        self.client = client\n\n    async def arun(self, **kwargs: Any) -&gt; Any:\n        \"\"\"Execute the MCP tool.\"\"\"\n        result = await self.client.call_tool(self.name, kwargs)\n        return result\n\n    def get_definition(self) -&gt; ToolDefinition:\n        \"\"\"Get tool definition in AgentiCraft format.\"\"\"\n        parameters = []\n\n        for param in self.mcp_tool.parameters:\n            parameters.append(ToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description or f\"Parameter {param.name}\",\n                required=param.required,\n                default=param.default\n            ))\n\n        return ToolDefinition(\n            name=self.name,\n            description=self.description,\n            parameters=parameters\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPToolAdapter.__init__","title":"<code>__init__(mcp_tool, client)</code>","text":"<p>Initialize the adapter.</p> <p>Parameters:</p> Name Type Description Default <code>mcp_tool</code> <code>MCPTool</code> <p>The MCP tool definition</p> required <code>client</code> <code>MCPClient</code> <p>The MCP client for executing the tool</p> required Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def __init__(self, mcp_tool: MCPTool, client: \"MCPClient\"):\n    \"\"\"Initialize the adapter.\n\n    Args:\n        mcp_tool: The MCP tool definition\n        client: The MCP client for executing the tool\n    \"\"\"\n    super().__init__(\n        name=mcp_tool.name,\n        description=mcp_tool.description\n    )\n    self.mcp_tool = mcp_tool\n    self.client = client\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPToolAdapter.arun","title":"<code>arun(**kwargs)</code>  <code>async</code>","text":"<p>Execute the MCP tool.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def arun(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Execute the MCP tool.\"\"\"\n    result = await self.client.call_tool(self.name, kwargs)\n    return result\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPToolAdapter.get_definition","title":"<code>get_definition()</code>","text":"<p>Get tool definition in AgentiCraft format.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def get_definition(self) -&gt; ToolDefinition:\n    \"\"\"Get tool definition in AgentiCraft format.\"\"\"\n    parameters = []\n\n    for param in self.mcp_tool.parameters:\n        parameters.append(ToolParameter(\n            name=param.name,\n            type=param.type,\n            description=param.description or f\"Parameter {param.name}\",\n            required=param.required,\n            default=param.default\n        ))\n\n    return ToolDefinition(\n        name=self.name,\n        description=self.description,\n        parameters=parameters\n    )\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient","title":"<code>MCPClient</code>","text":"<p>Client for connecting to MCP servers.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>class MCPClient:\n    \"\"\"Client for connecting to MCP servers.\"\"\"\n\n    def __init__(self, url: str, **kwargs: Any):\n        \"\"\"Initialize MCP client.\n\n        Args:\n            url: MCP server URL (WebSocket or HTTP)\n            **kwargs: Additional connection configuration\n        \"\"\"\n        self.config = MCPConnectionConfig(url=url, **kwargs)\n        self._ws = None\n        self._http_client = None\n        self._tools: Dict[str, MCPTool] = {}\n        self._server_info: Optional[MCPServerInfo] = None\n        self._request_id = 0\n        self._pending_requests: Dict[Union[str, int], asyncio.Future] = {}\n\n        # Check WebSocket support\n        if self.config.is_websocket and not HAS_WEBSOCKETS:\n            raise ImportError(\n                \"WebSocket support requires 'websockets' package. \"\n                \"Install with: pip install agenticraft[websocket]\"\n            )\n\n    async def connect(self) -&gt; None:\n        \"\"\"Connect to the MCP server.\"\"\"\n        try:\n            if self.config.is_websocket:\n                await self._connect_websocket()\n            else:\n                await self._connect_http()\n\n            # Initialize connection\n            await self._initialize()\n\n            # Discover tools\n            await self._discover_tools()\n\n            logger.info(f\"Connected to MCP server at {self.config.url}\")\n\n        except Exception as e:\n            logger.error(f\"Failed to connect to MCP server: {e}\")\n            raise ToolError(f\"MCP connection failed: {e}\")\n\n    async def _connect_websocket(self) -&gt; None:\n        \"\"\"Connect via WebSocket.\"\"\"\n        self._ws = await websockets.connect(\n            self.config.url,\n            extra_headers=self.config.headers\n        )\n\n        # Start message handler\n        asyncio.create_task(self._handle_websocket_messages())\n\n    async def _connect_http(self) -&gt; None:\n        \"\"\"Connect via HTTP.\"\"\"\n        self._http_client = httpx.AsyncClient(\n            base_url=self.config.url,\n            headers=self.config.headers,\n            timeout=self.config.timeout\n        )\n\n    async def _handle_websocket_messages(self) -&gt; None:\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        try:\n            async for message in self._ws:\n                data = json.loads(message)\n                response = MCPResponse(**data)\n\n                # Handle response\n                if response.id in self._pending_requests:\n                    future = self._pending_requests.pop(response.id)\n                    if response.is_error:\n                        future.set_exception(\n                            ToolError(f\"MCP error: {response.error.message}\")\n                        )\n                    else:\n                        future.set_result(response.result)\n\n        except Exception as e:\n            logger.error(f\"WebSocket handler error: {e}\")\n            # Cancel all pending requests\n            for future in self._pending_requests.values():\n                future.set_exception(e)\n            self._pending_requests.clear()\n\n    async def _send_request(\n        self,\n        method: MCPMethod,\n        params: Optional[Dict[str, Any]] = None\n    ) -&gt; Any:\n        \"\"\"Send a request to the MCP server.\n\n        Args:\n            method: The MCP method to call\n            params: Optional parameters\n\n        Returns:\n            The response result\n        \"\"\"\n        self._request_id += 1\n        request = MCPRequest(\n            method=method,\n            params=params,\n            id=self._request_id\n        )\n\n        if self.config.is_websocket:\n            return await self._send_websocket_request(request)\n        else:\n            return await self._send_http_request(request)\n\n    async def _send_websocket_request(self, request: MCPRequest) -&gt; Any:\n        \"\"\"Send request via WebSocket.\"\"\"\n        if not self._ws:\n            raise ToolError(\"WebSocket not connected\")\n\n        # Create future for response\n        future = asyncio.Future()\n        self._pending_requests[request.id] = future\n\n        try:\n            # Send request\n            await self._ws.send(json.dumps(request.to_dict()))\n\n            # Wait for response\n            result = await asyncio.wait_for(\n                future,\n                timeout=self.config.timeout\n            )\n            return result\n\n        except asyncio.TimeoutError:\n            self._pending_requests.pop(request.id, None)\n            raise ToolError(f\"MCP request timeout: {request.method}\")\n        except Exception as e:\n            self._pending_requests.pop(request.id, None)\n            raise\n\n    async def _send_http_request(self, request: MCPRequest) -&gt; Any:\n        \"\"\"Send request via HTTP.\"\"\"\n        if not self._http_client:\n            raise ToolError(\"HTTP client not connected\")\n\n        try:\n            response = await self._http_client.post(\n                \"/rpc\",\n                json=request.to_dict()\n            )\n            response.raise_for_status()\n\n            data = response.json()\n            mcp_response = MCPResponse(**data)\n\n            if mcp_response.is_error:\n                raise ToolError(f\"MCP error: {mcp_response.error.message}\")\n\n            return mcp_response.result\n\n        except httpx.HTTPError as e:\n            raise ToolError(f\"MCP HTTP error: {e}\")\n\n    async def _initialize(self) -&gt; None:\n        \"\"\"Initialize the MCP connection.\"\"\"\n        result = await self._send_request(\n            MCPMethod.INITIALIZE,\n            {\"client\": \"agenticraft\", \"version\": \"0.1.0\"}\n        )\n\n        # Get server info\n        info_result = await self._send_request(MCPMethod.GET_INFO)\n        self._server_info = MCPServerInfo(**info_result)\n\n        logger.info(\n            f\"Connected to {self._server_info.name} \"\n            f\"v{self._server_info.version}\"\n        )\n\n    async def _discover_tools(self) -&gt; None:\n        \"\"\"Discover available tools from the server.\"\"\"\n        result = await self._send_request(MCPMethod.LIST_TOOLS)\n\n        self._tools.clear()\n        for tool_data in result.get(\"tools\", []):\n            tool = MCPTool(**tool_data)\n            self._tools[tool.name] = tool\n\n        logger.info(f\"Discovered {len(self._tools)} MCP tools\")\n\n    async def call_tool(\n        self,\n        tool_name: str,\n        arguments: Dict[str, Any]\n    ) -&gt; Any:\n        \"\"\"Call a tool on the MCP server.\n\n        Args:\n            tool_name: Name of the tool to call\n            arguments: Tool arguments\n\n        Returns:\n            Tool execution result\n        \"\"\"\n        if tool_name not in self._tools:\n            raise ToolNotFoundError(tool_name)\n\n        tool_call = MCPToolCall(tool=tool_name, arguments=arguments)\n\n        try:\n            result = await self._send_request(\n                MCPMethod.CALL_TOOL,\n                tool_call.to_dict()\n            )\n\n            # Handle result\n            if isinstance(result, dict) and \"error\" in result:\n                raise ToolError(f\"Tool execution failed: {result['error']}\")\n\n            return result\n\n        except Exception as e:\n            logger.error(f\"Tool execution failed: {tool_name} - {e}\")\n            raise ToolError(f\"Failed to execute tool {tool_name}: {e}\")\n\n    def get_tools(self) -&gt; List[BaseTool]:\n        \"\"\"Get all available tools as AgentiCraft tools.\n\n        Returns:\n            List of tool adapters\n        \"\"\"\n        tools = []\n        for mcp_tool in self._tools.values():\n            adapter = MCPToolAdapter(mcp_tool, self)\n            tools.append(adapter)\n        return tools\n\n    def get_tool(self, name: str) -&gt; BaseTool:\n        \"\"\"Get a specific tool by name.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            Tool adapter\n\n        Raises:\n            ToolNotFoundError: If tool not found\n        \"\"\"\n        if name not in self._tools:\n            raise ToolNotFoundError(name)\n\n        return MCPToolAdapter(self._tools[name], self)\n\n    @property\n    def server_info(self) -&gt; Optional[MCPServerInfo]:\n        \"\"\"Get server information.\"\"\"\n        return self._server_info\n\n    @property\n    def available_tools(self) -&gt; List[str]:\n        \"\"\"Get list of available tool names.\"\"\"\n        return list(self._tools.keys())\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the MCP server.\"\"\"\n        try:\n            # Send shutdown\n            await self._send_request(MCPMethod.SHUTDOWN)\n        except Exception:\n            pass  # Ignore shutdown errors\n\n        # Close connections\n        if self._ws:\n            await self._ws.close()\n            self._ws = None\n\n        if self._http_client:\n            await self._http_client.aclose()\n            self._http_client = None\n\n        self._tools.clear()\n        self._server_info = None\n\n        logger.info(\"Disconnected from MCP server\")\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit.\"\"\"\n        await self.disconnect()\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.server_info","title":"<code>server_info</code>  <code>property</code>","text":"<p>Get server information.</p>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.available_tools","title":"<code>available_tools</code>  <code>property</code>","text":"<p>Get list of available tool names.</p>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.__init__","title":"<code>__init__(url, **kwargs)</code>","text":"<p>Initialize MCP client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>MCP server URL (WebSocket or HTTP)</p> required <code>**kwargs</code> <code>Any</code> <p>Additional connection configuration</p> <code>{}</code> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def __init__(self, url: str, **kwargs: Any):\n    \"\"\"Initialize MCP client.\n\n    Args:\n        url: MCP server URL (WebSocket or HTTP)\n        **kwargs: Additional connection configuration\n    \"\"\"\n    self.config = MCPConnectionConfig(url=url, **kwargs)\n    self._ws = None\n    self._http_client = None\n    self._tools: Dict[str, MCPTool] = {}\n    self._server_info: Optional[MCPServerInfo] = None\n    self._request_id = 0\n    self._pending_requests: Dict[Union[str, int], asyncio.Future] = {}\n\n    # Check WebSocket support\n    if self.config.is_websocket and not HAS_WEBSOCKETS:\n        raise ImportError(\n            \"WebSocket support requires 'websockets' package. \"\n            \"Install with: pip install agenticraft[websocket]\"\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to the MCP server.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to the MCP server.\"\"\"\n    try:\n        if self.config.is_websocket:\n            await self._connect_websocket()\n        else:\n            await self._connect_http()\n\n        # Initialize connection\n        await self._initialize()\n\n        # Discover tools\n        await self._discover_tools()\n\n        logger.info(f\"Connected to MCP server at {self.config.url}\")\n\n    except Exception as e:\n        logger.error(f\"Failed to connect to MCP server: {e}\")\n        raise ToolError(f\"MCP connection failed: {e}\")\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.call_tool","title":"<code>call_tool(tool_name, arguments)</code>  <code>async</code>","text":"<p>Call a tool on the MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool to call</p> required <code>arguments</code> <code>Dict[str, Any]</code> <p>Tool arguments</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Tool execution result</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def call_tool(\n    self,\n    tool_name: str,\n    arguments: Dict[str, Any]\n) -&gt; Any:\n    \"\"\"Call a tool on the MCP server.\n\n    Args:\n        tool_name: Name of the tool to call\n        arguments: Tool arguments\n\n    Returns:\n        Tool execution result\n    \"\"\"\n    if tool_name not in self._tools:\n        raise ToolNotFoundError(tool_name)\n\n    tool_call = MCPToolCall(tool=tool_name, arguments=arguments)\n\n    try:\n        result = await self._send_request(\n            MCPMethod.CALL_TOOL,\n            tool_call.to_dict()\n        )\n\n        # Handle result\n        if isinstance(result, dict) and \"error\" in result:\n            raise ToolError(f\"Tool execution failed: {result['error']}\")\n\n        return result\n\n    except Exception as e:\n        logger.error(f\"Tool execution failed: {tool_name} - {e}\")\n        raise ToolError(f\"Failed to execute tool {tool_name}: {e}\")\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.get_tools","title":"<code>get_tools()</code>","text":"<p>Get all available tools as AgentiCraft tools.</p> <p>Returns:</p> Type Description <code>List[BaseTool]</code> <p>List of tool adapters</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def get_tools(self) -&gt; List[BaseTool]:\n    \"\"\"Get all available tools as AgentiCraft tools.\n\n    Returns:\n        List of tool adapters\n    \"\"\"\n    tools = []\n    for mcp_tool in self._tools.values():\n        adapter = MCPToolAdapter(mcp_tool, self)\n        tools.append(adapter)\n    return tools\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.get_tool","title":"<code>get_tool(name)</code>","text":"<p>Get a specific tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>BaseTool</code> <p>Tool adapter</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>def get_tool(self, name: str) -&gt; BaseTool:\n    \"\"\"Get a specific tool by name.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        Tool adapter\n\n    Raises:\n        ToolNotFoundError: If tool not found\n    \"\"\"\n    if name not in self._tools:\n        raise ToolNotFoundError(name)\n\n    return MCPToolAdapter(self._tools[name], self)\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from the MCP server.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the MCP server.\"\"\"\n    try:\n        # Send shutdown\n        await self._send_request(MCPMethod.SHUTDOWN)\n    except Exception:\n        pass  # Ignore shutdown errors\n\n    # Close connections\n    if self._ws:\n        await self._ws.close()\n        self._ws = None\n\n    if self._http_client:\n        await self._http_client.aclose()\n        self._http_client = None\n\n    self._tools.clear()\n    self._server_info = None\n\n    logger.info(\"Disconnected from MCP server\")\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    await self.connect()\n    return self\n</code></pre>"},{"location":"reference/protocols/mcp/client/#agenticraft.protocols.mcp.client.MCPClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>agenticraft/protocols/mcp/client.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit.\"\"\"\n    await self.disconnect()\n</code></pre>"},{"location":"reference/protocols/mcp/decorators/","title":"Decorators","text":""},{"location":"reference/protocols/mcp/decorators/#agenticraft.protocols.mcp.decorators","title":"<code>decorators</code>","text":"<p>MCP-specific decorators for AgentiCraft.</p> <p>This module provides decorators for adding MCP-specific metadata to AgentiCraft tools.</p>"},{"location":"reference/protocols/mcp/decorators/#agenticraft.protocols.mcp.decorators.mcp_tool","title":"<code>mcp_tool(*args, name=None, description=None, returns=None, examples=None, **kwargs)</code>","text":"<p>Decorator for creating MCP tools with additional metadata.</p> <p>This is an enhanced version of the @tool decorator that allows specifying MCP-specific metadata like return schemas and examples.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Override tool name</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Override tool description</p> <code>None</code> <code>returns</code> <code>Optional[Dict[str, Any]]</code> <p>JSON schema for return value</p> <code>None</code> <code>examples</code> <code>Optional[List[Dict[str, Any]]]</code> <p>List of input/output examples</p> <code>None</code> <code>**kwargs</code> <p>Additional metadata</p> <code>{}</code> Example <p>@mcp_tool(     returns={\"type\": \"object\", \"properties\": {\"result\": {\"type\": \"string\"}}},     examples=[{\"input\": {\"text\": \"hello\"}, \"output\": {\"result\": \"HELLO\"}}] ) def uppercase(text: str) -&gt; Dict[str, str]:     return {\"result\": text.upper()}</p> Source code in <code>agenticraft/protocols/mcp/decorators.py</code> <pre><code>def mcp_tool(\n    *args,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    returns: Optional[Dict[str, Any]] = None,\n    examples: Optional[List[Dict[str, Any]]] = None,\n    **kwargs\n) -&gt; Callable:\n    \"\"\"Decorator for creating MCP tools with additional metadata.\n\n    This is an enhanced version of the @tool decorator that allows\n    specifying MCP-specific metadata like return schemas and examples.\n\n    Args:\n        name: Override tool name\n        description: Override tool description\n        returns: JSON schema for return value\n        examples: List of input/output examples\n        **kwargs: Additional metadata\n\n    Example:\n        @mcp_tool(\n            returns={\"type\": \"object\", \"properties\": {\"result\": {\"type\": \"string\"}}},\n            examples=[{\"input\": {\"text\": \"hello\"}, \"output\": {\"result\": \"HELLO\"}}]\n        )\n        def uppercase(text: str) -&gt; Dict[str, str]:\n            return {\"result\": text.upper()}\n    \"\"\"\n    def decorator(func: Callable) -&gt; Any:\n        # Create tool using base decorator\n        tool_instance = base_tool(name=name, description=description)(func)\n\n        # Add MCP-specific metadata\n        if returns is not None:\n            tool_instance._mcp_returns = returns\n        if examples is not None:\n            tool_instance._mcp_examples = examples\n\n        # Add any additional metadata\n        for key, value in kwargs.items():\n            setattr(tool_instance, f\"_mcp_{key}\", value)\n\n        return tool_instance\n\n    # Handle both @mcp_tool and @mcp_tool() syntax\n    if len(args) == 1 and callable(args[0]) and not any([name, description, returns, examples, kwargs]):\n        # Direct decoration: @mcp_tool\n        func = args[0]\n        return decorator(func)\n    else:\n        # With parameters: @mcp_tool(...)\n        return decorator\n</code></pre>"},{"location":"reference/protocols/mcp/registry/","title":"Registry","text":""},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry","title":"<code>registry</code>","text":"<p>MCP tool registry for managing tool registrations.</p> <p>This module provides a registry for MCP tools that can be shared between clients and servers.</p>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry","title":"<code>MCPRegistry</code>","text":"<p>Registry for MCP tools.</p> <p>This registry manages MCP tool definitions and provides methods for tool discovery and validation.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>class MCPRegistry:\n    \"\"\"Registry for MCP tools.\n\n    This registry manages MCP tool definitions and provides\n    methods for tool discovery and validation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the MCP registry.\"\"\"\n        self._tools: Dict[str, MCPTool] = {}\n        self._categories: Dict[str, Set[str]] = {}\n        self._adapters: Dict[str, BaseTool] = {}\n\n    def register_mcp_tool(\n        self,\n        tool: MCPTool,\n        category: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Register an MCP tool.\n\n        Args:\n            tool: MCP tool to register\n            category: Optional category for organization\n        \"\"\"\n        if tool.name in self._tools:\n            logger.warning(f\"Overwriting existing MCP tool: {tool.name}\")\n\n        self._tools[tool.name] = tool\n\n        if category:\n            if category not in self._categories:\n                self._categories[category] = set()\n            self._categories[category].add(tool.name)\n\n        logger.info(f\"Registered MCP tool: {tool.name}\")\n\n    def register_agenticraft_tool(\n        self,\n        tool: BaseTool,\n        category: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Register an AgentiCraft tool as MCP tool.\n\n        Args:\n            tool: AgentiCraft tool to register\n            category: Optional category\n        \"\"\"\n        # Convert to MCP tool\n        mcp_tool = self._convert_to_mcp_tool(tool)\n        self.register_mcp_tool(mcp_tool, category)\n\n        # Store adapter\n        self._adapters[tool.name] = tool\n\n    def _convert_to_mcp_tool(self, tool: BaseTool) -&gt; MCPTool:\n        \"\"\"Convert AgentiCraft tool to MCP tool.\"\"\"\n        definition = tool.get_definition()\n\n        parameters = []\n        for param in definition.parameters:\n            mcp_param = MCPToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description,\n                required=param.required,\n                default=param.default,\n                enum=param.enum\n            )\n            parameters.append(mcp_param)\n\n        return MCPTool(\n            name=definition.name,\n            description=definition.description,\n            parameters=parameters\n        )\n\n    def get_tool(self, name: str) -&gt; MCPTool:\n        \"\"\"Get an MCP tool by name.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            MCP tool\n\n        Raises:\n            ToolNotFoundError: If tool not found\n        \"\"\"\n        if name not in self._tools:\n            raise ToolNotFoundError(name)\n        return self._tools[name]\n\n    def get_adapter(self, name: str) -&gt; Optional[BaseTool]:\n        \"\"\"Get AgentiCraft adapter for a tool.\n\n        Args:\n            name: Tool name\n\n        Returns:\n            AgentiCraft tool adapter if available\n        \"\"\"\n        return self._adapters.get(name)\n\n    def list_tools(self, category: Optional[str] = None) -&gt; List[str]:\n        \"\"\"List tool names.\n\n        Args:\n            category: Optional category filter\n\n        Returns:\n            List of tool names\n        \"\"\"\n        if category:\n            return list(self._categories.get(category, set()))\n        return list(self._tools.keys())\n\n    def list_categories(self) -&gt; List[str]:\n        \"\"\"List available categories.\n\n        Returns:\n            List of category names\n        \"\"\"\n        return list(self._categories.keys())\n\n    def get_tools_by_category(self, category: str) -&gt; List[MCPTool]:\n        \"\"\"Get all tools in a category.\n\n        Args:\n            category: Category name\n\n        Returns:\n            List of MCP tools\n        \"\"\"\n        tool_names = self._categories.get(category, set())\n        return [self._tools[name] for name in tool_names if name in self._tools]\n\n    def search_tools(self, query: str) -&gt; List[MCPTool]:\n        \"\"\"Search for tools by name or description.\n\n        Args:\n            query: Search query\n\n        Returns:\n            List of matching tools\n        \"\"\"\n        query_lower = query.lower()\n        matches = []\n\n        for tool in self._tools.values():\n            if (query_lower in tool.name.lower() or \n                query_lower in tool.description.lower()):\n                matches.append(tool)\n\n        return matches\n\n    def validate_tool_call(\n        self,\n        tool_name: str,\n        arguments: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Validate tool call arguments.\n\n        Args:\n            tool_name: Tool name\n            arguments: Tool arguments\n\n        Raises:\n            ToolNotFoundError: If tool not found\n            ToolError: If arguments are invalid\n        \"\"\"\n        tool = self.get_tool(tool_name)\n\n        # Check required parameters\n        required_params = {\n            param.name for param in tool.parameters if param.required\n        }\n        provided_params = set(arguments.keys())\n\n        missing = required_params - provided_params\n        if missing:\n            raise ToolError(\n                f\"Missing required parameters for {tool_name}: {missing}\"\n            )\n\n        # Check parameter types (basic validation)\n        for param in tool.parameters:\n            if param.name in arguments:\n                value = arguments[param.name]\n\n                # Check enum values\n                if param.enum and value not in param.enum:\n                    raise ToolError(\n                        f\"Invalid value for {param.name}: {value}. \"\n                        f\"Must be one of: {param.enum}\"\n                    )\n\n    def export_tools(self) -&gt; Dict[str, Any]:\n        \"\"\"Export all tools as JSON-serializable dict.\n\n        Returns:\n            Dictionary of tools\n        \"\"\"\n        return {\n            \"tools\": [tool.to_json_schema() for tool in self._tools.values()],\n            \"categories\": {\n                cat: list(tools) for cat, tools in self._categories.items()\n            }\n        }\n\n    def import_tools(self, data: Dict[str, Any]) -&gt; None:\n        \"\"\"Import tools from exported data.\n\n        Args:\n            data: Exported tools data\n        \"\"\"\n        # Clear existing\n        self._tools.clear()\n        self._categories.clear()\n\n        # Import tools\n        for tool_data in data.get(\"tools\", []):\n            tool = MCPTool(**tool_data)\n            self._tools[tool.name] = tool\n\n        # Import categories\n        for category, tool_names in data.get(\"categories\", {}).items():\n            self._categories[category] = set(tool_names)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all registered tools.\"\"\"\n        self._tools.clear()\n        self._categories.clear()\n        self._adapters.clear()\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get number of registered tools.\"\"\"\n        return len(self._tools)\n\n    def __contains__(self, tool_name: str) -&gt; bool:\n        \"\"\"Check if tool is registered.\"\"\"\n        return tool_name in self._tools\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the MCP registry.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the MCP registry.\"\"\"\n    self._tools: Dict[str, MCPTool] = {}\n    self._categories: Dict[str, Set[str]] = {}\n    self._adapters: Dict[str, BaseTool] = {}\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.register_mcp_tool","title":"<code>register_mcp_tool(tool, category=None)</code>","text":"<p>Register an MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>MCPTool</code> <p>MCP tool to register</p> required <code>category</code> <code>Optional[str]</code> <p>Optional category for organization</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def register_mcp_tool(\n    self,\n    tool: MCPTool,\n    category: Optional[str] = None\n) -&gt; None:\n    \"\"\"Register an MCP tool.\n\n    Args:\n        tool: MCP tool to register\n        category: Optional category for organization\n    \"\"\"\n    if tool.name in self._tools:\n        logger.warning(f\"Overwriting existing MCP tool: {tool.name}\")\n\n    self._tools[tool.name] = tool\n\n    if category:\n        if category not in self._categories:\n            self._categories[category] = set()\n        self._categories[category].add(tool.name)\n\n    logger.info(f\"Registered MCP tool: {tool.name}\")\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.register_agenticraft_tool","title":"<code>register_agenticraft_tool(tool, category=None)</code>","text":"<p>Register an AgentiCraft tool as MCP tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>BaseTool</code> <p>AgentiCraft tool to register</p> required <code>category</code> <code>Optional[str]</code> <p>Optional category</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def register_agenticraft_tool(\n    self,\n    tool: BaseTool,\n    category: Optional[str] = None\n) -&gt; None:\n    \"\"\"Register an AgentiCraft tool as MCP tool.\n\n    Args:\n        tool: AgentiCraft tool to register\n        category: Optional category\n    \"\"\"\n    # Convert to MCP tool\n    mcp_tool = self._convert_to_mcp_tool(tool)\n    self.register_mcp_tool(mcp_tool, category)\n\n    # Store adapter\n    self._adapters[tool.name] = tool\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.get_tool","title":"<code>get_tool(name)</code>","text":"<p>Get an MCP tool by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>MCPTool</code> <p>MCP tool</p> <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_tool(self, name: str) -&gt; MCPTool:\n    \"\"\"Get an MCP tool by name.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        MCP tool\n\n    Raises:\n        ToolNotFoundError: If tool not found\n    \"\"\"\n    if name not in self._tools:\n        raise ToolNotFoundError(name)\n    return self._tools[name]\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.get_adapter","title":"<code>get_adapter(name)</code>","text":"<p>Get AgentiCraft adapter for a tool.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <p>Returns:</p> Type Description <code>Optional[BaseTool]</code> <p>AgentiCraft tool adapter if available</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_adapter(self, name: str) -&gt; Optional[BaseTool]:\n    \"\"\"Get AgentiCraft adapter for a tool.\n\n    Args:\n        name: Tool name\n\n    Returns:\n        AgentiCraft tool adapter if available\n    \"\"\"\n    return self._adapters.get(name)\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.list_tools","title":"<code>list_tools(category=None)</code>","text":"<p>List tool names.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>Optional[str]</code> <p>Optional category filter</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of tool names</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def list_tools(self, category: Optional[str] = None) -&gt; List[str]:\n    \"\"\"List tool names.\n\n    Args:\n        category: Optional category filter\n\n    Returns:\n        List of tool names\n    \"\"\"\n    if category:\n        return list(self._categories.get(category, set()))\n    return list(self._tools.keys())\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.list_categories","title":"<code>list_categories()</code>","text":"<p>List available categories.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of category names</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def list_categories(self) -&gt; List[str]:\n    \"\"\"List available categories.\n\n    Returns:\n        List of category names\n    \"\"\"\n    return list(self._categories.keys())\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.get_tools_by_category","title":"<code>get_tools_by_category(category)</code>","text":"<p>Get all tools in a category.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Category name</p> required <p>Returns:</p> Type Description <code>List[MCPTool]</code> <p>List of MCP tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_tools_by_category(self, category: str) -&gt; List[MCPTool]:\n    \"\"\"Get all tools in a category.\n\n    Args:\n        category: Category name\n\n    Returns:\n        List of MCP tools\n    \"\"\"\n    tool_names = self._categories.get(category, set())\n    return [self._tools[name] for name in tool_names if name in self._tools]\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.search_tools","title":"<code>search_tools(query)</code>","text":"<p>Search for tools by name or description.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <p>Returns:</p> Type Description <code>List[MCPTool]</code> <p>List of matching tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def search_tools(self, query: str) -&gt; List[MCPTool]:\n    \"\"\"Search for tools by name or description.\n\n    Args:\n        query: Search query\n\n    Returns:\n        List of matching tools\n    \"\"\"\n    query_lower = query.lower()\n    matches = []\n\n    for tool in self._tools.values():\n        if (query_lower in tool.name.lower() or \n            query_lower in tool.description.lower()):\n            matches.append(tool)\n\n    return matches\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.validate_tool_call","title":"<code>validate_tool_call(tool_name, arguments)</code>","text":"<p>Validate tool call arguments.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Tool name</p> required <code>arguments</code> <code>Dict[str, Any]</code> <p>Tool arguments</p> required <p>Raises:</p> Type Description <code>ToolNotFoundError</code> <p>If tool not found</p> <code>ToolError</code> <p>If arguments are invalid</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def validate_tool_call(\n    self,\n    tool_name: str,\n    arguments: Dict[str, Any]\n) -&gt; None:\n    \"\"\"Validate tool call arguments.\n\n    Args:\n        tool_name: Tool name\n        arguments: Tool arguments\n\n    Raises:\n        ToolNotFoundError: If tool not found\n        ToolError: If arguments are invalid\n    \"\"\"\n    tool = self.get_tool(tool_name)\n\n    # Check required parameters\n    required_params = {\n        param.name for param in tool.parameters if param.required\n    }\n    provided_params = set(arguments.keys())\n\n    missing = required_params - provided_params\n    if missing:\n        raise ToolError(\n            f\"Missing required parameters for {tool_name}: {missing}\"\n        )\n\n    # Check parameter types (basic validation)\n    for param in tool.parameters:\n        if param.name in arguments:\n            value = arguments[param.name]\n\n            # Check enum values\n            if param.enum and value not in param.enum:\n                raise ToolError(\n                    f\"Invalid value for {param.name}: {value}. \"\n                    f\"Must be one of: {param.enum}\"\n                )\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.export_tools","title":"<code>export_tools()</code>","text":"<p>Export all tools as JSON-serializable dict.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of tools</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def export_tools(self) -&gt; Dict[str, Any]:\n    \"\"\"Export all tools as JSON-serializable dict.\n\n    Returns:\n        Dictionary of tools\n    \"\"\"\n    return {\n        \"tools\": [tool.to_json_schema() for tool in self._tools.values()],\n        \"categories\": {\n            cat: list(tools) for cat, tools in self._categories.items()\n        }\n    }\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.import_tools","title":"<code>import_tools(data)</code>","text":"<p>Import tools from exported data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Exported tools data</p> required Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def import_tools(self, data: Dict[str, Any]) -&gt; None:\n    \"\"\"Import tools from exported data.\n\n    Args:\n        data: Exported tools data\n    \"\"\"\n    # Clear existing\n    self._tools.clear()\n    self._categories.clear()\n\n    # Import tools\n    for tool_data in data.get(\"tools\", []):\n        tool = MCPTool(**tool_data)\n        self._tools[tool.name] = tool\n\n    # Import categories\n    for category, tool_names in data.get(\"categories\", {}).items():\n        self._categories[category] = set(tool_names)\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear all registered tools.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all registered tools.\"\"\"\n    self._tools.clear()\n    self._categories.clear()\n    self._adapters.clear()\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.__len__","title":"<code>__len__()</code>","text":"<p>Get number of registered tools.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get number of registered tools.\"\"\"\n    return len(self._tools)\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.MCPRegistry.__contains__","title":"<code>__contains__(tool_name)</code>","text":"<p>Check if tool is registered.</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def __contains__(self, tool_name: str) -&gt; bool:\n    \"\"\"Check if tool is registered.\"\"\"\n    return tool_name in self._tools\n</code></pre>"},{"location":"reference/protocols/mcp/registry/#agenticraft.protocols.mcp.registry.get_global_registry","title":"<code>get_global_registry()</code>","text":"<p>Get the global MCP registry instance.</p> <p>Returns:</p> Type Description <code>MCPRegistry</code> <p>Global MCP registry</p> Source code in <code>agenticraft/protocols/mcp/registry.py</code> <pre><code>def get_global_registry() -&gt; MCPRegistry:\n    \"\"\"Get the global MCP registry instance.\n\n    Returns:\n        Global MCP registry\n    \"\"\"\n    return _global_registry\n</code></pre>"},{"location":"reference/protocols/mcp/server/","title":"Server","text":""},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server","title":"<code>server</code>","text":"<p>MCP server implementation for AgentiCraft.</p> <p>This module provides a server that exposes AgentiCraft tools via the Model Context Protocol.</p>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer","title":"<code>MCPServer</code>","text":"<p>Server that exposes AgentiCraft tools via MCP.</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>class MCPServer:\n    \"\"\"Server that exposes AgentiCraft tools via MCP.\"\"\"\n\n    def __init__(\n        self,\n        name: str = \"AgentiCraft MCP Server\",\n        version: str = \"0.1.0\",\n        description: Optional[str] = None\n    ):\n        \"\"\"Initialize MCP server.\n\n        Args:\n            name: Server name\n            version: Server version\n            description: Optional server description\n        \"\"\"\n        self.server_info = MCPServerInfo(\n            name=name,\n            version=version,\n            description=description or \"AgentiCraft tools exposed via MCP\",\n            capabilities=[\n                MCPCapability.TOOLS,\n                MCPCapability.CANCELLATION,\n            ]\n        )\n\n        self._tool_registry = ToolRegistry()\n        self._handlers: Dict[str, Callable] = {\n            MCPMethod.INITIALIZE.value: self._handle_initialize,\n            MCPMethod.SHUTDOWN.value: self._handle_shutdown,\n            MCPMethod.GET_INFO.value: self._handle_get_info,\n            MCPMethod.GET_CAPABILITIES.value: self._handle_get_capabilities,\n            MCPMethod.LIST_TOOLS.value: self._handle_list_tools,\n            MCPMethod.DESCRIBE_TOOL.value: self._handle_describe_tool,\n            MCPMethod.CALL_TOOL.value: self._handle_call_tool,\n        }\n\n        # For HTTP mode\n        self._app: Optional[FastAPI] = None\n\n    def register_tool(self, tool: Union[BaseTool, Callable]) -&gt; None:\n        \"\"\"Register a tool to expose via MCP.\n\n        Args:\n            tool: Tool to register\n        \"\"\"\n        self._tool_registry.register(tool)\n        logger.info(f\"Registered tool for MCP: {tool.name if hasattr(tool, 'name') else tool.__name__}\")\n\n    def register_tools(self, tools: List[Union[BaseTool, Callable]]) -&gt; None:\n        \"\"\"Register multiple tools.\n\n        Args:\n            tools: List of tools to register\n        \"\"\"\n        for tool in tools:\n            self.register_tool(tool)\n\n    async def handle_request(self, request: MCPRequest) -&gt; MCPResponse:\n        \"\"\"Handle an MCP request.\n\n        Args:\n            request: The MCP request\n\n        Returns:\n            The MCP response\n        \"\"\"\n        try:\n            # Validate request\n            if not request.method:\n                return self._error_response(\n                    MCPErrorCode.INVALID_REQUEST,\n                    \"Missing method\",\n                    request.id\n                )\n\n            # Get handler\n            handler = self._handlers.get(request.method)\n            if not handler:\n                return self._error_response(\n                    MCPErrorCode.METHOD_NOT_FOUND,\n                    f\"Unknown method: {request.method}\",\n                    request.id\n                )\n\n            # Execute handler\n            result = await handler(request.params or {})\n\n            return MCPResponse(\n                id=request.id,\n                result=result\n            )\n\n        except Exception as e:\n            logger.error(f\"Request handling error: {e}\")\n            return self._error_response(\n                MCPErrorCode.INTERNAL_ERROR,\n                str(e),\n                request.id\n            )\n\n    def _error_response(\n        self,\n        code: MCPErrorCode,\n        message: str,\n        request_id: Union[str, int, None] = None\n    ) -&gt; MCPResponse:\n        \"\"\"Create an error response.\"\"\"\n        return MCPResponse(\n            id=request_id,\n            error=MCPError(code=code, message=message)\n        )\n\n    async def _handle_initialize(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle initialization request.\"\"\"\n        return {\n            \"protocolVersion\": \"1.0\",\n            \"serverInfo\": self.server_info.to_dict()\n        }\n\n    async def _handle_shutdown(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle shutdown request.\"\"\"\n        return {\"status\": \"ok\"}\n\n    async def _handle_get_info(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle server info request.\"\"\"\n        return self.server_info.to_dict()\n\n    async def _handle_get_capabilities(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle capabilities request.\"\"\"\n        return {\n            \"capabilities\": [cap.value for cap in self.server_info.capabilities]\n        }\n\n    async def _handle_list_tools(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle list tools request.\"\"\"\n        tools = []\n\n        for tool_name in self._tool_registry.list_tools():\n            tool = self._tool_registry.get(tool_name)\n            mcp_tool = self._convert_to_mcp_tool(tool)\n            tools.append(mcp_tool.to_json_schema())\n\n        return {\"tools\": tools}\n\n    async def _handle_describe_tool(self, params: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Handle describe tool request.\"\"\"\n        tool_name = params.get(\"name\")\n        if not tool_name:\n            raise ValueError(\"Missing tool name\")\n\n        try:\n            tool = self._tool_registry.get(tool_name)\n            mcp_tool = self._convert_to_mcp_tool(tool)\n            return mcp_tool.to_json_schema()\n        except ToolNotFoundError:\n            raise ValueError(f\"Tool not found: {tool_name}\")\n\n    async def _handle_call_tool(self, params: Dict[str, Any]) -&gt; Any:\n        \"\"\"Handle tool call request.\"\"\"\n        tool_name = params.get(\"tool\")\n        arguments = params.get(\"arguments\", {})\n\n        if not tool_name:\n            raise ValueError(\"Missing tool name\")\n\n        try:\n            result = await self._tool_registry.execute(tool_name, **arguments)\n            return result\n        except ToolNotFoundError:\n            raise ValueError(f\"Tool not found: {tool_name}\")\n        except Exception as e:\n            logger.error(f\"Tool execution error: {e}\")\n            raise\n\n    def _convert_to_mcp_tool(self, tool: BaseTool) -&gt; MCPTool:\n        \"\"\"Convert AgentiCraft tool to MCP tool.\"\"\"\n        definition = tool.get_definition()\n\n        parameters = []\n        for param in definition.parameters:\n            mcp_param = MCPToolParameter(\n                name=param.name,\n                type=param.type,\n                description=param.description,\n                required=param.required,\n                default=param.default,\n                enum=param.enum\n            )\n            parameters.append(mcp_param)\n\n        return MCPTool(\n            name=definition.name,\n            description=definition.description,\n            parameters=parameters\n        )\n\n    # WebSocket server methods\n    async def start_websocket_server(\n        self,\n        host: str = \"localhost\",\n        port: int = 3000\n    ) -&gt; None:\n        \"\"\"Start WebSocket server.\n\n        Args:\n            host: Host to bind to\n            port: Port to bind to\n        \"\"\"\n        if not HAS_WEBSOCKETS:\n            raise ImportError(\n                \"WebSocket support requires 'websockets' package. \"\n                \"Install with: pip install agenticraft[websocket]\"\n            )\n\n        logger.info(f\"Starting MCP WebSocket server on {host}:{port}\")\n\n        async with websockets.serve(\n            self._handle_websocket_connection,\n            host,\n            port\n        ):\n            await asyncio.Future()  # Run forever\n\n    async def _handle_websocket_connection(\n        self,\n        websocket: WebSocketServerProtocol,\n        path: str\n    ) -&gt; None:\n        \"\"\"Handle WebSocket connection.\"\"\"\n        logger.info(f\"New WebSocket connection from {websocket.remote_address}\")\n\n        try:\n            async for message in websocket:\n                try:\n                    # Parse request\n                    data = json.loads(message)\n                    request = MCPRequest(**data)\n\n                    # Handle request\n                    response = await self.handle_request(request)\n\n                    # Send response\n                    await websocket.send(json.dumps(response.to_dict()))\n\n                except json.JSONDecodeError:\n                    error_response = self._error_response(\n                        MCPErrorCode.PARSE_ERROR,\n                        \"Invalid JSON\"\n                    )\n                    await websocket.send(json.dumps(error_response.to_dict()))\n                except Exception as e:\n                    logger.error(f\"Message handling error: {e}\")\n                    error_response = self._error_response(\n                        MCPErrorCode.INTERNAL_ERROR,\n                        str(e)\n                    )\n                    await websocket.send(json.dumps(error_response.to_dict()))\n\n        except websockets.exceptions.ConnectionClosed:\n            logger.info(\"WebSocket connection closed\")\n        except Exception as e:\n            logger.error(f\"WebSocket error: {e}\")\n\n    # HTTP server methods\n    def create_fastapi_app(self) -&gt; FastAPI:\n        \"\"\"Create FastAPI app for HTTP mode.\n\n        Returns:\n            FastAPI application\n        \"\"\"\n        if self._app is None:\n            self._app = FastAPI(\n                title=self.server_info.name,\n                version=self.server_info.version,\n                description=self.server_info.description\n            )\n\n            # Add RPC endpoint\n            @self._app.post(\"/rpc\")\n            async def handle_rpc(request: Request) -&gt; JSONResponse:\n                try:\n                    data = await request.json()\n                    mcp_request = MCPRequest(**data)\n                    response = await self.handle_request(mcp_request)\n                    return JSONResponse(content=response.to_dict())\n                except Exception as e:\n                    logger.error(f\"HTTP request error: {e}\")\n                    error_response = self._error_response(\n                        MCPErrorCode.INTERNAL_ERROR,\n                        str(e)\n                    )\n                    return JSONResponse(\n                        content=error_response.to_dict(),\n                        status_code=500\n                    )\n\n            # Add health check\n            @self._app.get(\"/health\")\n            async def health_check():\n                return {\"status\": \"ok\", \"server\": self.server_info.name}\n\n        return self._app\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.__init__","title":"<code>__init__(name='AgentiCraft MCP Server', version='0.1.0', description=None)</code>","text":"<p>Initialize MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name</p> <code>'AgentiCraft MCP Server'</code> <code>version</code> <code>str</code> <p>Server version</p> <code>'0.1.0'</code> <code>description</code> <code>Optional[str]</code> <p>Optional server description</p> <code>None</code> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"AgentiCraft MCP Server\",\n    version: str = \"0.1.0\",\n    description: Optional[str] = None\n):\n    \"\"\"Initialize MCP server.\n\n    Args:\n        name: Server name\n        version: Server version\n        description: Optional server description\n    \"\"\"\n    self.server_info = MCPServerInfo(\n        name=name,\n        version=version,\n        description=description or \"AgentiCraft tools exposed via MCP\",\n        capabilities=[\n            MCPCapability.TOOLS,\n            MCPCapability.CANCELLATION,\n        ]\n    )\n\n    self._tool_registry = ToolRegistry()\n    self._handlers: Dict[str, Callable] = {\n        MCPMethod.INITIALIZE.value: self._handle_initialize,\n        MCPMethod.SHUTDOWN.value: self._handle_shutdown,\n        MCPMethod.GET_INFO.value: self._handle_get_info,\n        MCPMethod.GET_CAPABILITIES.value: self._handle_get_capabilities,\n        MCPMethod.LIST_TOOLS.value: self._handle_list_tools,\n        MCPMethod.DESCRIBE_TOOL.value: self._handle_describe_tool,\n        MCPMethod.CALL_TOOL.value: self._handle_call_tool,\n    }\n\n    # For HTTP mode\n    self._app: Optional[FastAPI] = None\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.register_tool","title":"<code>register_tool(tool)</code>","text":"<p>Register a tool to expose via MCP.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>Union[BaseTool, Callable]</code> <p>Tool to register</p> required Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def register_tool(self, tool: Union[BaseTool, Callable]) -&gt; None:\n    \"\"\"Register a tool to expose via MCP.\n\n    Args:\n        tool: Tool to register\n    \"\"\"\n    self._tool_registry.register(tool)\n    logger.info(f\"Registered tool for MCP: {tool.name if hasattr(tool, 'name') else tool.__name__}\")\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.register_tools","title":"<code>register_tools(tools)</code>","text":"<p>Register multiple tools.</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>List[Union[BaseTool, Callable]]</code> <p>List of tools to register</p> required Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def register_tools(self, tools: List[Union[BaseTool, Callable]]) -&gt; None:\n    \"\"\"Register multiple tools.\n\n    Args:\n        tools: List of tools to register\n    \"\"\"\n    for tool in tools:\n        self.register_tool(tool)\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.handle_request","title":"<code>handle_request(request)</code>  <code>async</code>","text":"<p>Handle an MCP request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>MCPRequest</code> <p>The MCP request</p> required <p>Returns:</p> Type Description <code>MCPResponse</code> <p>The MCP response</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>async def handle_request(self, request: MCPRequest) -&gt; MCPResponse:\n    \"\"\"Handle an MCP request.\n\n    Args:\n        request: The MCP request\n\n    Returns:\n        The MCP response\n    \"\"\"\n    try:\n        # Validate request\n        if not request.method:\n            return self._error_response(\n                MCPErrorCode.INVALID_REQUEST,\n                \"Missing method\",\n                request.id\n            )\n\n        # Get handler\n        handler = self._handlers.get(request.method)\n        if not handler:\n            return self._error_response(\n                MCPErrorCode.METHOD_NOT_FOUND,\n                f\"Unknown method: {request.method}\",\n                request.id\n            )\n\n        # Execute handler\n        result = await handler(request.params or {})\n\n        return MCPResponse(\n            id=request.id,\n            result=result\n        )\n\n    except Exception as e:\n        logger.error(f\"Request handling error: {e}\")\n        return self._error_response(\n            MCPErrorCode.INTERNAL_ERROR,\n            str(e),\n            request.id\n        )\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.start_websocket_server","title":"<code>start_websocket_server(host='localhost', port=3000)</code>  <code>async</code>","text":"<p>Start WebSocket server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host to bind to</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Port to bind to</p> <code>3000</code> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>async def start_websocket_server(\n    self,\n    host: str = \"localhost\",\n    port: int = 3000\n) -&gt; None:\n    \"\"\"Start WebSocket server.\n\n    Args:\n        host: Host to bind to\n        port: Port to bind to\n    \"\"\"\n    if not HAS_WEBSOCKETS:\n        raise ImportError(\n            \"WebSocket support requires 'websockets' package. \"\n            \"Install with: pip install agenticraft[websocket]\"\n        )\n\n    logger.info(f\"Starting MCP WebSocket server on {host}:{port}\")\n\n    async with websockets.serve(\n        self._handle_websocket_connection,\n        host,\n        port\n    ):\n        await asyncio.Future()  # Run forever\n</code></pre>"},{"location":"reference/protocols/mcp/server/#agenticraft.protocols.mcp.server.MCPServer.create_fastapi_app","title":"<code>create_fastapi_app()</code>","text":"<p>Create FastAPI app for HTTP mode.</p> <p>Returns:</p> Type Description <code>FastAPI</code> <p>FastAPI application</p> Source code in <code>agenticraft/protocols/mcp/server.py</code> <pre><code>def create_fastapi_app(self) -&gt; FastAPI:\n    \"\"\"Create FastAPI app for HTTP mode.\n\n    Returns:\n        FastAPI application\n    \"\"\"\n    if self._app is None:\n        self._app = FastAPI(\n            title=self.server_info.name,\n            version=self.server_info.version,\n            description=self.server_info.description\n        )\n\n        # Add RPC endpoint\n        @self._app.post(\"/rpc\")\n        async def handle_rpc(request: Request) -&gt; JSONResponse:\n            try:\n                data = await request.json()\n                mcp_request = MCPRequest(**data)\n                response = await self.handle_request(mcp_request)\n                return JSONResponse(content=response.to_dict())\n            except Exception as e:\n                logger.error(f\"HTTP request error: {e}\")\n                error_response = self._error_response(\n                    MCPErrorCode.INTERNAL_ERROR,\n                    str(e)\n                )\n                return JSONResponse(\n                    content=error_response.to_dict(),\n                    status_code=500\n                )\n\n        # Add health check\n        @self._app.get(\"/health\")\n        async def health_check():\n            return {\"status\": \"ok\", \"server\": self.server_info.name}\n\n    return self._app\n</code></pre>"},{"location":"reference/protocols/mcp/types/","title":"Types","text":""},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types","title":"<code>types</code>","text":"<p>Type definitions for Model Context Protocol.</p> <p>This module defines the data structures used in MCP communication, including requests, responses, tools, and errors.</p>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPMethod","title":"<code>MCPMethod</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>MCP protocol methods.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPMethod(str, Enum):\n    \"\"\"MCP protocol methods.\"\"\"\n\n    # Discovery\n    LIST_TOOLS = \"tools/list\"\n    DESCRIBE_TOOL = \"tools/describe\"\n\n    # Execution\n    CALL_TOOL = \"tools/call\"\n\n    # Lifecycle\n    INITIALIZE = \"initialize\"\n    SHUTDOWN = \"shutdown\"\n\n    # Server info\n    GET_INFO = \"server/info\"\n    GET_CAPABILITIES = \"server/capabilities\"\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPErrorCode","title":"<code>MCPErrorCode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>MCP error codes.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPErrorCode(str, Enum):\n    \"\"\"MCP error codes.\"\"\"\n\n    PARSE_ERROR = \"parse_error\"\n    INVALID_REQUEST = \"invalid_request\"\n    METHOD_NOT_FOUND = \"method_not_found\"\n    INVALID_PARAMS = \"invalid_params\"\n    INTERNAL_ERROR = \"internal_error\"\n    TOOL_NOT_FOUND = \"tool_not_found\"\n    TOOL_EXECUTION_ERROR = \"tool_execution_error\"\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPCapability","title":"<code>MCPCapability</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>MCP server capabilities.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPCapability(str, Enum):\n    \"\"\"MCP server capabilities.\"\"\"\n\n    TOOLS = \"tools\"\n    STREAMING = \"streaming\"\n    CANCELLATION = \"cancellation\"\n    PROGRESS = \"progress\"\n    MULTI_TOOL = \"multi_tool\"\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPRequest","title":"<code>MCPRequest</code>  <code>dataclass</code>","text":"<p>MCP request message.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPRequest:\n    \"\"\"MCP request message.\"\"\"\n\n    jsonrpc: str = \"2.0\"\n    method: MCPMethod = MCPMethod.LIST_TOOLS\n    params: Optional[Dict[str, Any]] = None\n    id: Union[str, int] = field(default_factory=lambda: str(uuid4()))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        data = {\n            \"jsonrpc\": self.jsonrpc,\n            \"method\": self.method.value,\n            \"id\": self.id\n        }\n        if self.params is not None:\n            data[\"params\"] = self.params\n        return data\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPRequest.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    data = {\n        \"jsonrpc\": self.jsonrpc,\n        \"method\": self.method.value,\n        \"id\": self.id\n    }\n    if self.params is not None:\n        data[\"params\"] = self.params\n    return data\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPResponse","title":"<code>MCPResponse</code>  <code>dataclass</code>","text":"<p>MCP response message.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPResponse:\n    \"\"\"MCP response message.\"\"\"\n\n    jsonrpc: str = \"2.0\"\n    id: Union[str, int, None] = None\n    result: Optional[Any] = None\n    error: Optional[\"MCPError\"] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        data = {\n            \"jsonrpc\": self.jsonrpc,\n            \"id\": self.id\n        }\n\n        if self.error is not None:\n            data[\"error\"] = self.error.to_dict()\n        else:\n            data[\"result\"] = self.result\n\n        return data\n\n    @property\n    def is_error(self) -&gt; bool:\n        \"\"\"Check if response is an error.\"\"\"\n        return self.error is not None\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPResponse.is_error","title":"<code>is_error</code>  <code>property</code>","text":"<p>Check if response is an error.</p>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPResponse.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for JSON serialization.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n    data = {\n        \"jsonrpc\": self.jsonrpc,\n        \"id\": self.id\n    }\n\n    if self.error is not None:\n        data[\"error\"] = self.error.to_dict()\n    else:\n        data[\"result\"] = self.result\n\n    return data\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPError","title":"<code>MCPError</code>  <code>dataclass</code>","text":"<p>MCP error structure.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPError:\n    \"\"\"MCP error structure.\"\"\"\n\n    code: MCPErrorCode\n    message: str\n    data: Optional[Any] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        error_dict = {\n            \"code\": self.code.value,\n            \"message\": self.message\n        }\n        if self.data is not None:\n            error_dict[\"data\"] = self.data\n        return error_dict\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPError.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    error_dict = {\n        \"code\": self.code.value,\n        \"message\": self.message\n    }\n    if self.data is not None:\n        error_dict[\"data\"] = self.data\n    return error_dict\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolParameter","title":"<code>MCPToolParameter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>MCP tool parameter definition.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPToolParameter(BaseModel):\n    \"\"\"MCP tool parameter definition.\"\"\"\n\n    name: str\n    type: str  # JSON Schema type\n    description: Optional[str] = None\n    required: bool = True\n    default: Optional[Any] = None\n    enum: Optional[List[Any]] = None\n\n    def to_json_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to JSON Schema format.\"\"\"\n        schema: Dict[str, Any] = {\n            \"type\": self.type\n        }\n\n        if self.description:\n            schema[\"description\"] = self.description\n        if self.enum:\n            schema[\"enum\"] = self.enum\n        if self.default is not None:\n            schema[\"default\"] = self.default\n\n        return schema\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolParameter.to_json_schema","title":"<code>to_json_schema()</code>","text":"<p>Convert to JSON Schema format.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_json_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to JSON Schema format.\"\"\"\n    schema: Dict[str, Any] = {\n        \"type\": self.type\n    }\n\n    if self.description:\n        schema[\"description\"] = self.description\n    if self.enum:\n        schema[\"enum\"] = self.enum\n    if self.default is not None:\n        schema[\"default\"] = self.default\n\n    return schema\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPTool","title":"<code>MCPTool</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>MCP tool definition.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>class MCPTool(BaseModel):\n    \"\"\"MCP tool definition.\"\"\"\n\n    name: str\n    description: str\n    parameters: List[MCPToolParameter] = Field(default_factory=list)\n    returns: Optional[Dict[str, Any]] = None  # JSON Schema for return type\n    examples: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def to_json_schema(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to JSON Schema format for tool definition.\"\"\"\n        properties = {}\n        required = []\n\n        for param in self.parameters:\n            properties[param.name] = param.to_json_schema()\n            if param.required:\n                required.append(param.name)\n\n        schema = {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": properties,\n                \"required\": required\n            }\n        }\n\n        if self.returns:\n            schema[\"returnSchema\"] = self.returns\n\n        if self.examples:\n            schema[\"examples\"] = self.examples\n\n        return schema\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPTool.to_json_schema","title":"<code>to_json_schema()</code>","text":"<p>Convert to JSON Schema format for tool definition.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_json_schema(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to JSON Schema format for tool definition.\"\"\"\n    properties = {}\n    required = []\n\n    for param in self.parameters:\n        properties[param.name] = param.to_json_schema()\n        if param.required:\n            required.append(param.name)\n\n    schema = {\n        \"name\": self.name,\n        \"description\": self.description,\n        \"inputSchema\": {\n            \"type\": \"object\",\n            \"properties\": properties,\n            \"required\": required\n        }\n    }\n\n    if self.returns:\n        schema[\"returnSchema\"] = self.returns\n\n    if self.examples:\n        schema[\"examples\"] = self.examples\n\n    return schema\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPServerInfo","title":"<code>MCPServerInfo</code>  <code>dataclass</code>","text":"<p>MCP server information.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPServerInfo:\n    \"\"\"MCP server information.\"\"\"\n\n    name: str\n    version: str\n    description: Optional[str] = None\n    capabilities: List[MCPCapability] = field(default_factory=list)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"version\": self.version,\n            \"description\": self.description,\n            \"capabilities\": [cap.value for cap in self.capabilities]\n        }\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPServerInfo.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\n        \"name\": self.name,\n        \"version\": self.version,\n        \"description\": self.description,\n        \"capabilities\": [cap.value for cap in self.capabilities]\n    }\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolCall","title":"<code>MCPToolCall</code>  <code>dataclass</code>","text":"<p>MCP tool invocation.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPToolCall:\n    \"\"\"MCP tool invocation.\"\"\"\n\n    tool: str\n    arguments: Dict[str, Any]\n    id: str = field(default_factory=lambda: str(uuid4()))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"tool\": self.tool,\n            \"arguments\": self.arguments,\n            \"id\": self.id\n        }\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolCall.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\n        \"tool\": self.tool,\n        \"arguments\": self.arguments,\n        \"id\": self.id\n    }\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolResult","title":"<code>MCPToolResult</code>  <code>dataclass</code>","text":"<p>MCP tool execution result.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPToolResult:\n    \"\"\"MCP tool execution result.\"\"\"\n\n    tool_call_id: str\n    result: Any\n    error: Optional[str] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        data = {\n            \"tool_call_id\": self.tool_call_id\n        }\n\n        if self.error:\n            data[\"error\"] = self.error\n        else:\n            data[\"result\"] = self.result\n\n        return data\n\n    @property\n    def is_error(self) -&gt; bool:\n        \"\"\"Check if result is an error.\"\"\"\n        return self.error is not None\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolResult.is_error","title":"<code>is_error</code>  <code>property</code>","text":"<p>Check if result is an error.</p>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPToolResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    data = {\n        \"tool_call_id\": self.tool_call_id\n    }\n\n    if self.error:\n        data[\"error\"] = self.error\n    else:\n        data[\"result\"] = self.result\n\n    return data\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPConnectionConfig","title":"<code>MCPConnectionConfig</code>  <code>dataclass</code>","text":"<p>Configuration for MCP connection.</p> Source code in <code>agenticraft/protocols/mcp/types.py</code> <pre><code>@dataclass\nclass MCPConnectionConfig:\n    \"\"\"Configuration for MCP connection.\"\"\"\n\n    url: str\n    timeout: int = 30\n    max_retries: int = 3\n    headers: Dict[str, str] = field(default_factory=dict)\n\n    @property\n    def is_websocket(self) -&gt; bool:\n        \"\"\"Check if URL is WebSocket.\"\"\"\n        return self.url.startswith(\"ws://\") or self.url.startswith(\"wss://\")\n\n    @property\n    def is_http(self) -&gt; bool:\n        \"\"\"Check if URL is HTTP.\"\"\"\n        return self.url.startswith(\"http://\") or self.url.startswith(\"https://\")\n</code></pre>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPConnectionConfig.is_websocket","title":"<code>is_websocket</code>  <code>property</code>","text":"<p>Check if URL is WebSocket.</p>"},{"location":"reference/protocols/mcp/types/#agenticraft.protocols.mcp.types.MCPConnectionConfig.is_http","title":"<code>is_http</code>  <code>property</code>","text":"<p>Check if URL is HTTP.</p>"},{"location":"reference/providers/__init__/","title":"init","text":""},{"location":"reference/providers/__init__/#agenticraft.providers","title":"<code>providers</code>","text":"<p>LLM provider implementations for AgentiCraft.</p> <p>This module contains implementations of various LLM providers. Each provider is in its own file for better organization and maintainability.</p>"},{"location":"reference/providers/__init__/#agenticraft.providers.OpenAIProvider","title":"<code>OpenAIProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for OpenAI models (GPT-4, GPT-3.5, etc.).</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>class OpenAIProvider(BaseProvider):\n    \"\"\"Provider for OpenAI models (GPT-4, GPT-3.5, etc.).\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize OpenAI provider.\"\"\"\n        # Get API key from kwargs, settings, or environment\n        api_key = (\n            kwargs.get(\"api_key\") or \n            settings.openai_api_key or \n            os.getenv(\"OPENAI_API_KEY\")\n        )\n        if not api_key:\n            raise ValueError(\"API key required for OpenAI provider\")\n\n        kwargs[\"api_key\"] = api_key\n        kwargs.setdefault(\"base_url\", settings.openai_base_url)\n\n        # Store model if provided\n        self.model = kwargs.pop('model', 'gpt-4')\n\n        super().__init__(**kwargs)\n\n        self._client = None\n\n    @property\n    def client(self):\n        \"\"\"Get or create OpenAI client.\"\"\"\n        if self._client is None:\n            try:\n                from openai import AsyncOpenAI\n                self._client = AsyncOpenAI(\n                    api_key=self.api_key,\n                    base_url=self.base_url,\n                    timeout=self.timeout,\n                    max_retries=self.max_retries\n                )\n            except ImportError:\n                raise ProviderError(\"OpenAI provider requires 'openai' package\")\n        return self._client\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from OpenAI.\"\"\"\n        try:\n            # Remove model from kwargs to avoid duplication\n            kwargs.pop('model', None)\n\n            # Use provided model or default\n            actual_model = model or self.model\n\n            # Format messages\n            formatted_messages = self._format_messages(messages)\n\n            # Prepare request parameters\n            request_params = {\n                \"model\": actual_model,\n                \"messages\": formatted_messages,\n                \"temperature\": temperature,\n                **kwargs\n            }\n\n            if max_tokens:\n                request_params[\"max_tokens\"] = max_tokens\n\n            # Add tools if provided\n            if tools:\n                # Handle both ToolDefinition objects and raw dicts\n                if tools and isinstance(tools[0], dict):\n                    request_params[\"tools\"] = tools\n                else:\n                    request_params[\"tools\"] = [tool.to_openai_schema() for tool in tools]\n                request_params[\"tool_choice\"] = tool_choice if tool_choice is not None else \"auto\"\n\n            # Make request\n            response = await self.client.chat.completions.create(**request_params)\n\n            # Parse response\n            choice = response.choices[0]\n\n            # Extract usage - modern OpenAI SDK format\n            usage_data = None\n            if response.usage:\n                usage_data = {\n                    \"prompt_tokens\": response.usage.prompt_tokens,\n                    \"completion_tokens\": response.usage.completion_tokens,\n                    \"total_tokens\": response.usage.total_tokens\n                }\n\n            # Extract tool calls if any\n            tool_calls = []\n            if hasattr(choice.message, \"tool_calls\") and choice.message.tool_calls:\n                for tc in choice.message.tool_calls:\n                    try:\n                        # Parse arguments - handle JSON strings\n                        args = tc.function.arguments\n                        if isinstance(args, str):\n                            args = json.loads(args)\n\n                        tool_calls.append(ToolCall(\n                            id=str(tc.id),\n                            name=tc.function.name,\n                            arguments=args\n                        ))\n                    except json.JSONDecodeError as e:\n                        # Skip malformed tool calls\n                        logger.warning(f\"Failed to parse tool arguments: {e}\")\n                        continue\n\n            return CompletionResponse(\n                content=choice.message.content or \"\",\n                tool_calls=tool_calls,\n                finish_reason=choice.finish_reason,\n                usage=usage_data,\n                metadata={\"model\": actual_model},\n                model=actual_model\n            )\n\n        except Exception as e:\n            raise ProviderError(f\"OpenAI completion failed: {e}\") from e\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate OpenAI API key.\"\"\"\n        if not self.api_key or not self.api_key.startswith(\"sk-\"):\n            raise ProviderAuthError(\"openai\")\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for OpenAI API.\n\n        Args:\n            messages: List of Message objects or message dicts\n\n        Returns:\n            List of message dictionaries for OpenAI API\n        \"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append(msg.to_dict())\n            elif isinstance(msg, dict):\n                formatted.append(msg)\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OpenAIProvider.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get or create OpenAI client.</p>"},{"location":"reference/providers/__init__/#agenticraft.providers.OpenAIProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize OpenAI provider.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize OpenAI provider.\"\"\"\n    # Get API key from kwargs, settings, or environment\n    api_key = (\n        kwargs.get(\"api_key\") or \n        settings.openai_api_key or \n        os.getenv(\"OPENAI_API_KEY\")\n    )\n    if not api_key:\n        raise ValueError(\"API key required for OpenAI provider\")\n\n    kwargs[\"api_key\"] = api_key\n    kwargs.setdefault(\"base_url\", settings.openai_base_url)\n\n    # Store model if provided\n    self.model = kwargs.pop('model', 'gpt-4')\n\n    super().__init__(**kwargs)\n\n    self._client = None\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OpenAIProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from OpenAI.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from OpenAI.\"\"\"\n    try:\n        # Remove model from kwargs to avoid duplication\n        kwargs.pop('model', None)\n\n        # Use provided model or default\n        actual_model = model or self.model\n\n        # Format messages\n        formatted_messages = self._format_messages(messages)\n\n        # Prepare request parameters\n        request_params = {\n            \"model\": actual_model,\n            \"messages\": formatted_messages,\n            \"temperature\": temperature,\n            **kwargs\n        }\n\n        if max_tokens:\n            request_params[\"max_tokens\"] = max_tokens\n\n        # Add tools if provided\n        if tools:\n            # Handle both ToolDefinition objects and raw dicts\n            if tools and isinstance(tools[0], dict):\n                request_params[\"tools\"] = tools\n            else:\n                request_params[\"tools\"] = [tool.to_openai_schema() for tool in tools]\n            request_params[\"tool_choice\"] = tool_choice if tool_choice is not None else \"auto\"\n\n        # Make request\n        response = await self.client.chat.completions.create(**request_params)\n\n        # Parse response\n        choice = response.choices[0]\n\n        # Extract usage - modern OpenAI SDK format\n        usage_data = None\n        if response.usage:\n            usage_data = {\n                \"prompt_tokens\": response.usage.prompt_tokens,\n                \"completion_tokens\": response.usage.completion_tokens,\n                \"total_tokens\": response.usage.total_tokens\n            }\n\n        # Extract tool calls if any\n        tool_calls = []\n        if hasattr(choice.message, \"tool_calls\") and choice.message.tool_calls:\n            for tc in choice.message.tool_calls:\n                try:\n                    # Parse arguments - handle JSON strings\n                    args = tc.function.arguments\n                    if isinstance(args, str):\n                        args = json.loads(args)\n\n                    tool_calls.append(ToolCall(\n                        id=str(tc.id),\n                        name=tc.function.name,\n                        arguments=args\n                    ))\n                except json.JSONDecodeError as e:\n                    # Skip malformed tool calls\n                    logger.warning(f\"Failed to parse tool arguments: {e}\")\n                    continue\n\n        return CompletionResponse(\n            content=choice.message.content or \"\",\n            tool_calls=tool_calls,\n            finish_reason=choice.finish_reason,\n            usage=usage_data,\n            metadata={\"model\": actual_model},\n            model=actual_model\n        )\n\n    except Exception as e:\n        raise ProviderError(f\"OpenAI completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OpenAIProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate OpenAI API key.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate OpenAI API key.\"\"\"\n    if not self.api_key or not self.api_key.startswith(\"sk-\"):\n        raise ProviderAuthError(\"openai\")\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.AnthropicProvider","title":"<code>AnthropicProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for Anthropic models (Claude).</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>class AnthropicProvider(BaseProvider):\n    \"\"\"Provider for Anthropic models (Claude).\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize Anthropic provider.\"\"\"\n        # Get API key from kwargs, settings, or environment\n        api_key = (\n            kwargs.get(\"api_key\") or \n            settings.anthropic_api_key or \n            os.getenv(\"ANTHROPIC_API_KEY\")\n        )\n        if not api_key:\n            raise ProviderAuthError(\"anthropic\")\n\n        kwargs[\"api_key\"] = api_key\n        kwargs.setdefault(\"base_url\", settings.anthropic_base_url)\n\n        # Store model if provided\n        self.model = kwargs.pop('model', 'claude-3-opus-20240229')\n\n        super().__init__(**kwargs)\n\n        self._client = None\n\n    @property\n    def client(self):\n        \"\"\"Get or create Anthropic client.\"\"\"\n        if self._client is None:\n            try:\n                from anthropic import AsyncAnthropic\n                self._client = AsyncAnthropic(\n                    api_key=self.api_key,\n                    base_url=self.base_url,\n                    timeout=self.timeout,\n                    max_retries=self.max_retries\n                )\n            except ImportError:\n                raise ProviderError(\"Anthropic provider requires 'anthropic' package\")\n        return self._client\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from Anthropic.\n\n        Reference: Simplified from agentic-framework patterns.\n        \"\"\"\n        try:\n            # Use provided model or default\n            actual_model = model or self.model\n\n            # Format messages - extract system message (Anthropic pattern)\n            system_prompt, chat_messages = self._extract_system_message(messages)\n\n            # Prepare request parameters\n            request_params = {\n                \"model\": actual_model,\n                \"messages\": self._format_messages(chat_messages),\n                \"max_tokens\": max_tokens or 4096,\n                \"temperature\": temperature,\n                **kwargs\n            }\n\n            # Add system prompt if present\n            if system_prompt:\n                request_params[\"system\"] = system_prompt\n\n            # Add tools if provided\n            if tools:\n                request_params[\"tools\"] = self._convert_tools(tools)\n                if tool_choice is not None:\n                    request_params[\"tool_choice\"] = self._format_tool_choice(tool_choice)\n\n            # Make API call\n            response = await self.client.messages.create(**request_params)\n\n            # Parse response content\n            content = \"\"\n            tool_calls = []\n\n            for block in response.content:\n                if hasattr(block, 'text'):\n                    content += block.text\n                elif hasattr(block, 'type') and block.type == 'tool_use':\n                    # Extract tool call information\n                    tool_calls.append(ToolCall(\n                        id=block.id,\n                        name=block.name,\n                        arguments=block.input\n                    ))\n\n            # Extract usage information\n            usage_data = None\n            if hasattr(response, 'usage'):\n                usage_data = {\n                    \"prompt_tokens\": response.usage.input_tokens,\n                    \"completion_tokens\": response.usage.output_tokens,\n                    \"total_tokens\": response.usage.input_tokens + response.usage.output_tokens\n                }\n\n            return CompletionResponse(\n                content=content,\n                tool_calls=tool_calls,\n                finish_reason=response.stop_reason,\n                usage=usage_data,\n                metadata={\n                    \"model\": actual_model,\n                    \"stop_sequence\": getattr(response, 'stop_sequence', None)\n                },\n                model=actual_model\n            )\n\n        except Exception as e:\n            raise ProviderError(f\"Anthropic completion failed: {e}\") from e\n\n    def _extract_system_message(self, messages: Union[List[Message], List[Dict[str, Any]]]) -&gt; tuple:\n        \"\"\"Extract system message from messages list.\n\n        Pattern from agentic-framework: Anthropic requires system message\n        to be passed separately.\n        \"\"\"\n        system_prompt = None\n        chat_messages = []\n\n        for msg in messages:\n            # Handle both Message objects and dicts\n            if isinstance(msg, Message):\n                role = str(msg.role)\n                content = msg.content\n            else:\n                role = msg.get(\"role\")\n                content = msg.get(\"content\")\n\n            if role == \"system\":\n                system_prompt = content\n            else:\n                chat_messages.append(msg)\n\n        return system_prompt, chat_messages\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for Anthropic API.\"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append(msg.to_dict())\n            elif isinstance(msg, dict):\n                formatted.append(msg)\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n\n    def _convert_tools(self, tools: Union[List[ToolDefinition], List[Dict[str, Any]]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Convert tools to Anthropic format.\n\n        Pattern from agentic-framework: Different tool schema format.\n        \"\"\"\n        anthropic_tools = []\n\n        for tool in tools:\n            if isinstance(tool, ToolDefinition):\n                # Convert from ToolDefinition\n                schema = tool.to_openai_schema()\n                func_def = schema[\"function\"]\n                anthropic_tools.append({\n                    \"name\": func_def[\"name\"],\n                    \"description\": func_def[\"description\"],\n                    \"input_schema\": func_def[\"parameters\"]\n                })\n            elif isinstance(tool, dict):\n                # Already in dict format - convert to Anthropic format\n                if \"function\" in tool:\n                    # OpenAI format\n                    func = tool[\"function\"]\n                    anthropic_tools.append({\n                        \"name\": func[\"name\"],\n                        \"description\": func.get(\"description\", \"\"),\n                        \"input_schema\": func.get(\"parameters\", {})\n                    })\n                else:\n                    # Assume it's already in Anthropic format\n                    anthropic_tools.append(tool)\n\n        return anthropic_tools\n\n    def _format_tool_choice(self, tool_choice: Any) -&gt; Dict[str, Any]:\n        \"\"\"Format tool choice for Anthropic API.\"\"\"\n        if isinstance(tool_choice, str):\n            if tool_choice == \"auto\":\n                return {\"type\": \"auto\"}\n            elif tool_choice == \"none\":\n                return {\"type\": \"any\"}\n            else:\n                # Specific tool name\n                return {\"type\": \"tool\", \"name\": tool_choice}\n        elif isinstance(tool_choice, dict):\n            return tool_choice\n        else:\n            return {\"type\": \"auto\"}\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate Anthropic API key.\"\"\"\n        if not self.api_key:\n            raise ProviderAuthError(\"anthropic\")\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.AnthropicProvider.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get or create Anthropic client.</p>"},{"location":"reference/providers/__init__/#agenticraft.providers.AnthropicProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize Anthropic provider.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize Anthropic provider.\"\"\"\n    # Get API key from kwargs, settings, or environment\n    api_key = (\n        kwargs.get(\"api_key\") or \n        settings.anthropic_api_key or \n        os.getenv(\"ANTHROPIC_API_KEY\")\n    )\n    if not api_key:\n        raise ProviderAuthError(\"anthropic\")\n\n    kwargs[\"api_key\"] = api_key\n    kwargs.setdefault(\"base_url\", settings.anthropic_base_url)\n\n    # Store model if provided\n    self.model = kwargs.pop('model', 'claude-3-opus-20240229')\n\n    super().__init__(**kwargs)\n\n    self._client = None\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.AnthropicProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from Anthropic.</p> <p>Reference: Simplified from agentic-framework patterns.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from Anthropic.\n\n    Reference: Simplified from agentic-framework patterns.\n    \"\"\"\n    try:\n        # Use provided model or default\n        actual_model = model or self.model\n\n        # Format messages - extract system message (Anthropic pattern)\n        system_prompt, chat_messages = self._extract_system_message(messages)\n\n        # Prepare request parameters\n        request_params = {\n            \"model\": actual_model,\n            \"messages\": self._format_messages(chat_messages),\n            \"max_tokens\": max_tokens or 4096,\n            \"temperature\": temperature,\n            **kwargs\n        }\n\n        # Add system prompt if present\n        if system_prompt:\n            request_params[\"system\"] = system_prompt\n\n        # Add tools if provided\n        if tools:\n            request_params[\"tools\"] = self._convert_tools(tools)\n            if tool_choice is not None:\n                request_params[\"tool_choice\"] = self._format_tool_choice(tool_choice)\n\n        # Make API call\n        response = await self.client.messages.create(**request_params)\n\n        # Parse response content\n        content = \"\"\n        tool_calls = []\n\n        for block in response.content:\n            if hasattr(block, 'text'):\n                content += block.text\n            elif hasattr(block, 'type') and block.type == 'tool_use':\n                # Extract tool call information\n                tool_calls.append(ToolCall(\n                    id=block.id,\n                    name=block.name,\n                    arguments=block.input\n                ))\n\n        # Extract usage information\n        usage_data = None\n        if hasattr(response, 'usage'):\n            usage_data = {\n                \"prompt_tokens\": response.usage.input_tokens,\n                \"completion_tokens\": response.usage.output_tokens,\n                \"total_tokens\": response.usage.input_tokens + response.usage.output_tokens\n            }\n\n        return CompletionResponse(\n            content=content,\n            tool_calls=tool_calls,\n            finish_reason=response.stop_reason,\n            usage=usage_data,\n            metadata={\n                \"model\": actual_model,\n                \"stop_sequence\": getattr(response, 'stop_sequence', None)\n            },\n            model=actual_model\n        )\n\n    except Exception as e:\n        raise ProviderError(f\"Anthropic completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.AnthropicProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate Anthropic API key.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate Anthropic API key.\"\"\"\n    if not self.api_key:\n        raise ProviderAuthError(\"anthropic\")\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider","title":"<code>OllamaProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for local Ollama models.</p> <p>Ollama allows running open-source LLMs locally. This provider supports all Ollama features including streaming, custom models, and model management.</p> <p>Note: Requires Ollama to be installed and running locally. See: https://ollama.ai for installation instructions.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>class OllamaProvider(BaseProvider):\n    \"\"\"Provider for local Ollama models.\n\n    Ollama allows running open-source LLMs locally. This provider\n    supports all Ollama features including streaming, custom models,\n    and model management.\n\n    Note: Requires Ollama to be installed and running locally.\n    See: https://ollama.ai for installation instructions.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize Ollama provider.\n\n        Args:\n            base_url: Ollama server URL (default: http://localhost:11434)\n            model: Model name (default: llama2)\n            timeout: Request timeout in seconds (default: 300 for long generations)\n            **kwargs: Additional provider arguments\n        \"\"\"\n        # Set defaults for Ollama\n        # Handle None or missing base_url\n        if kwargs.get(\"base_url\") is None or \"base_url\" not in kwargs:\n            default_url = \"http://localhost:11434\"\n            if hasattr(settings, 'ollama_base_url') and settings.ollama_base_url:\n                default_url = settings.ollama_base_url\n            kwargs[\"base_url\"] = default_url\n\n        kwargs.setdefault(\"timeout\", 300)  # Ollama can be slow for first run\n        kwargs[\"api_key\"] = \"ollama\"  # Ollama doesn't need API key\n\n        # Extract and store model\n        self.model = kwargs.pop('model', 'llama2')\n        # Handle ollama/ prefix\n        if self.model.startswith('ollama/'):\n            self.model = self.model[7:]  # Remove 'ollama/' prefix\n\n        super().__init__(**kwargs)\n\n        # Create HTTP client\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            timeout=self.timeout\n        )\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from Ollama.\n\n        Args:\n            messages: Conversation messages\n            model: Optional model override\n            tools: Tool definitions (Note: Tool support depends on model)\n            tool_choice: Tool choice strategy (if tools supported)\n            temperature: Sampling temperature (0-2)\n            max_tokens: Maximum tokens to generate\n            **kwargs: Additional Ollama parameters\n\n        Returns:\n            CompletionResponse with generated content\n\n        Raises:\n            ProviderError: If Ollama request fails\n        \"\"\"\n        try:\n            # Use provided model or default\n            actual_model = model or self.model\n            if actual_model.startswith('ollama/'):\n                actual_model = actual_model[7:]\n\n            # Format messages for Ollama\n            formatted_messages = self._format_messages(messages)\n\n            # Prepare request body\n            request_body = {\n                \"model\": actual_model,\n                \"messages\": formatted_messages,\n                \"stream\": False,\n                \"options\": {\n                    \"temperature\": temperature,\n                }\n            }\n\n            # Add max_tokens as num_predict in Ollama\n            if max_tokens:\n                request_body[\"options\"][\"num_predict\"] = max_tokens\n\n            # Add any additional options\n            for key, value in kwargs.items():\n                if key not in [\"model\", \"messages\", \"stream\"]:\n                    request_body[\"options\"][key] = value\n\n            # Note: Ollama's tool support is model-dependent\n            # For now, we'll include tools in the system prompt if provided\n            if tools:\n                tool_description = self._format_tools_as_text(tools)\n                # Prepend tool description to first user message or add system message\n                if formatted_messages and formatted_messages[0][\"role\"] == \"system\":\n                    formatted_messages[0][\"content\"] += f\"\\n\\n{tool_description}\"\n                else:\n                    formatted_messages.insert(0, {\n                        \"role\": \"system\",\n                        \"content\": tool_description\n                    })\n\n            # Make request to Ollama\n            response = await self._client.post(\n                \"/api/chat\",\n                json=request_body\n            )\n            response.raise_for_status()\n\n            # Parse response\n            data = response.json()\n\n            # Extract message content\n            message = data.get(\"message\", {})\n            content = message.get(\"content\", \"\")\n\n            # Calculate token usage (approximate if not provided)\n            prompt_tokens = data.get(\"prompt_eval_count\", 0)\n            completion_tokens = data.get(\"eval_count\", 0)\n\n            usage_data = {\n                \"prompt_tokens\": prompt_tokens,\n                \"completion_tokens\": completion_tokens,\n                \"total_tokens\": prompt_tokens + completion_tokens\n            } if (prompt_tokens or completion_tokens) else None\n\n            # Extract metadata\n            metadata = {\n                \"model\": actual_model,\n                \"eval_duration\": data.get(\"eval_duration\"),\n                \"load_duration\": data.get(\"load_duration\"),\n                \"total_duration\": data.get(\"total_duration\"),\n            }\n\n            return CompletionResponse(\n                content=content,\n                tool_calls=[],  # Ollama doesn't have native tool calling yet\n                finish_reason=\"stop\",\n                usage=usage_data,\n                metadata=metadata,\n                model=actual_model\n            )\n\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise ProviderError(\n                    f\"Model '{actual_model}' not found. \"\n                    f\"Try: ollama pull {actual_model}\"\n                )\n            elif e.response.status_code == 500:\n                raise ProviderError(\n                    \"Ollama server error. Is Ollama running? \"\n                    \"Start with: ollama serve\"\n                )\n            else:\n                raise ProviderError(f\"Ollama HTTP error: {e}\")\n        except httpx.ConnectError:\n            raise ProviderError(\n                f\"Cannot connect to Ollama at {self.base_url}. \"\n                \"Is Ollama running? Start with: ollama serve\"\n            )\n        except Exception as e:\n            raise ProviderError(f\"Ollama completion failed: {e}\") from e\n\n    async def list_models(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List available Ollama models.\n\n        Returns:\n            List of model information dictionaries\n\n        Raises:\n            ProviderError: If request fails\n        \"\"\"\n        try:\n            response = await self._client.get(\"/api/tags\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"models\", [])\n        except Exception as e:\n            raise ProviderError(f\"Failed to list Ollama models: {e}\") from e\n\n    async def pull_model(self, model_name: str) -&gt; None:\n        \"\"\"Pull (download) a model from Ollama registry.\n\n        Args:\n            model_name: Name of model to pull (e.g., \"llama2\", \"codellama\")\n\n        Raises:\n            ProviderError: If pull fails\n        \"\"\"\n        try:\n            response = await self._client.post(\n                \"/api/pull\",\n                json={\"name\": model_name},\n                timeout=None  # Pulling can take a long time\n            )\n            response.raise_for_status()\n        except Exception as e:\n            raise ProviderError(f\"Failed to pull model '{model_name}': {e}\") from e\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate connection to Ollama.\n\n        Ollama doesn't require authentication, but we check\n        if the server is accessible.\n        \"\"\"\n        # Check connection in a synchronous context\n        try:\n            import httpx\n            response = httpx.get(f\"{self.base_url}/api/tags\", timeout=5)\n            response.raise_for_status()\n        except httpx.ConnectError:\n            raise ProviderError(\n                f\"Cannot connect to Ollama at {self.base_url}. \"\n                \"Is Ollama running? Start with: ollama serve\"\n            )\n        except Exception as e:\n            raise ProviderError(f\"Ollama validation failed: {e}\")\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for Ollama API.\n\n        Args:\n            messages: List of Message objects or message dicts\n\n        Returns:\n            List of message dictionaries for Ollama\n        \"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append({\n                    \"role\": str(msg.role),\n                    \"content\": msg.content\n                })\n            elif isinstance(msg, dict):\n                # Ensure role is lowercase for Ollama\n                formatted.append({\n                    \"role\": msg[\"role\"].lower(),\n                    \"content\": msg[\"content\"]\n                })\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n\n    def _format_tools_as_text(self, tools: Union[List[ToolDefinition], List[Dict[str, Any]]]) -&gt; str:\n        \"\"\"Format tools as text description for models without native tool support.\n\n        Args:\n            tools: List of tool definitions\n\n        Returns:\n            Text description of available tools\n        \"\"\"\n        tool_descriptions = [\"Available tools:\"]\n\n        for tool in tools:\n            if isinstance(tool, ToolDefinition):\n                name = tool.name\n                description = tool.description\n                params = tool.parameters\n            elif isinstance(tool, dict) and \"function\" in tool:\n                # OpenAI format\n                func = tool[\"function\"]\n                name = func[\"name\"]\n                description = func.get(\"description\", \"\")\n                params = func.get(\"parameters\", {}).get(\"properties\", {})\n            else:\n                continue\n\n            tool_descriptions.append(f\"\\n- {name}: {description}\")\n            if params:\n                tool_descriptions.append(f\"  Parameters: {params}\")\n\n        tool_descriptions.append(\n            \"\\nTo use a tool, respond with: \"\n            \"TOOL_CALL: {\\\"name\\\": \\\"tool_name\\\", \\\"arguments\\\": {...}}\"\n        )\n\n        return \"\\n\".join(tool_descriptions)\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit - close HTTP client.\"\"\"\n        await self._client.aclose()\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize Ollama provider.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <p>Ollama server URL (default: http://localhost:11434)</p> required <code>model</code> <p>Model name (default: llama2)</p> required <code>timeout</code> <p>Request timeout in seconds (default: 300 for long generations)</p> required <code>**kwargs</code> <p>Additional provider arguments</p> <code>{}</code> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize Ollama provider.\n\n    Args:\n        base_url: Ollama server URL (default: http://localhost:11434)\n        model: Model name (default: llama2)\n        timeout: Request timeout in seconds (default: 300 for long generations)\n        **kwargs: Additional provider arguments\n    \"\"\"\n    # Set defaults for Ollama\n    # Handle None or missing base_url\n    if kwargs.get(\"base_url\") is None or \"base_url\" not in kwargs:\n        default_url = \"http://localhost:11434\"\n        if hasattr(settings, 'ollama_base_url') and settings.ollama_base_url:\n            default_url = settings.ollama_base_url\n        kwargs[\"base_url\"] = default_url\n\n    kwargs.setdefault(\"timeout\", 300)  # Ollama can be slow for first run\n    kwargs[\"api_key\"] = \"ollama\"  # Ollama doesn't need API key\n\n    # Extract and store model\n    self.model = kwargs.pop('model', 'llama2')\n    # Handle ollama/ prefix\n    if self.model.startswith('ollama/'):\n        self.model = self.model[7:]  # Remove 'ollama/' prefix\n\n    super().__init__(**kwargs)\n\n    # Create HTTP client\n    self._client = httpx.AsyncClient(\n        base_url=self.base_url,\n        timeout=self.timeout\n    )\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from Ollama.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[List[Message], List[Dict[str, Any]]]</code> <p>Conversation messages</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override</p> <code>None</code> <code>tools</code> <code>Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]]</code> <p>Tool definitions (Note: Tool support depends on model)</p> <code>None</code> <code>tool_choice</code> <code>Optional[Any]</code> <p>Tool choice strategy (if tools supported)</p> <code>None</code> <code>temperature</code> <code>float</code> <p>Sampling temperature (0-2)</p> <code>0.7</code> <code>max_tokens</code> <code>Optional[int]</code> <p>Maximum tokens to generate</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional Ollama parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletionResponse</code> <p>CompletionResponse with generated content</p> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If Ollama request fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from Ollama.\n\n    Args:\n        messages: Conversation messages\n        model: Optional model override\n        tools: Tool definitions (Note: Tool support depends on model)\n        tool_choice: Tool choice strategy (if tools supported)\n        temperature: Sampling temperature (0-2)\n        max_tokens: Maximum tokens to generate\n        **kwargs: Additional Ollama parameters\n\n    Returns:\n        CompletionResponse with generated content\n\n    Raises:\n        ProviderError: If Ollama request fails\n    \"\"\"\n    try:\n        # Use provided model or default\n        actual_model = model or self.model\n        if actual_model.startswith('ollama/'):\n            actual_model = actual_model[7:]\n\n        # Format messages for Ollama\n        formatted_messages = self._format_messages(messages)\n\n        # Prepare request body\n        request_body = {\n            \"model\": actual_model,\n            \"messages\": formatted_messages,\n            \"stream\": False,\n            \"options\": {\n                \"temperature\": temperature,\n            }\n        }\n\n        # Add max_tokens as num_predict in Ollama\n        if max_tokens:\n            request_body[\"options\"][\"num_predict\"] = max_tokens\n\n        # Add any additional options\n        for key, value in kwargs.items():\n            if key not in [\"model\", \"messages\", \"stream\"]:\n                request_body[\"options\"][key] = value\n\n        # Note: Ollama's tool support is model-dependent\n        # For now, we'll include tools in the system prompt if provided\n        if tools:\n            tool_description = self._format_tools_as_text(tools)\n            # Prepend tool description to first user message or add system message\n            if formatted_messages and formatted_messages[0][\"role\"] == \"system\":\n                formatted_messages[0][\"content\"] += f\"\\n\\n{tool_description}\"\n            else:\n                formatted_messages.insert(0, {\n                    \"role\": \"system\",\n                    \"content\": tool_description\n                })\n\n        # Make request to Ollama\n        response = await self._client.post(\n            \"/api/chat\",\n            json=request_body\n        )\n        response.raise_for_status()\n\n        # Parse response\n        data = response.json()\n\n        # Extract message content\n        message = data.get(\"message\", {})\n        content = message.get(\"content\", \"\")\n\n        # Calculate token usage (approximate if not provided)\n        prompt_tokens = data.get(\"prompt_eval_count\", 0)\n        completion_tokens = data.get(\"eval_count\", 0)\n\n        usage_data = {\n            \"prompt_tokens\": prompt_tokens,\n            \"completion_tokens\": completion_tokens,\n            \"total_tokens\": prompt_tokens + completion_tokens\n        } if (prompt_tokens or completion_tokens) else None\n\n        # Extract metadata\n        metadata = {\n            \"model\": actual_model,\n            \"eval_duration\": data.get(\"eval_duration\"),\n            \"load_duration\": data.get(\"load_duration\"),\n            \"total_duration\": data.get(\"total_duration\"),\n        }\n\n        return CompletionResponse(\n            content=content,\n            tool_calls=[],  # Ollama doesn't have native tool calling yet\n            finish_reason=\"stop\",\n            usage=usage_data,\n            metadata=metadata,\n            model=actual_model\n        )\n\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ProviderError(\n                f\"Model '{actual_model}' not found. \"\n                f\"Try: ollama pull {actual_model}\"\n            )\n        elif e.response.status_code == 500:\n            raise ProviderError(\n                \"Ollama server error. Is Ollama running? \"\n                \"Start with: ollama serve\"\n            )\n        else:\n            raise ProviderError(f\"Ollama HTTP error: {e}\")\n    except httpx.ConnectError:\n        raise ProviderError(\n            f\"Cannot connect to Ollama at {self.base_url}. \"\n            \"Is Ollama running? Start with: ollama serve\"\n        )\n    except Exception as e:\n        raise ProviderError(f\"Ollama completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.list_models","title":"<code>list_models()</code>  <code>async</code>","text":"<p>List available Ollama models.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of model information dictionaries</p> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If request fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def list_models(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"List available Ollama models.\n\n    Returns:\n        List of model information dictionaries\n\n    Raises:\n        ProviderError: If request fails\n    \"\"\"\n    try:\n        response = await self._client.get(\"/api/tags\")\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"models\", [])\n    except Exception as e:\n        raise ProviderError(f\"Failed to list Ollama models: {e}\") from e\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.pull_model","title":"<code>pull_model(model_name)</code>  <code>async</code>","text":"<p>Pull (download) a model from Ollama registry.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Name of model to pull (e.g., \"llama2\", \"codellama\")</p> required <p>Raises:</p> Type Description <code>ProviderError</code> <p>If pull fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def pull_model(self, model_name: str) -&gt; None:\n    \"\"\"Pull (download) a model from Ollama registry.\n\n    Args:\n        model_name: Name of model to pull (e.g., \"llama2\", \"codellama\")\n\n    Raises:\n        ProviderError: If pull fails\n    \"\"\"\n    try:\n        response = await self._client.post(\n            \"/api/pull\",\n            json={\"name\": model_name},\n            timeout=None  # Pulling can take a long time\n        )\n        response.raise_for_status()\n    except Exception as e:\n        raise ProviderError(f\"Failed to pull model '{model_name}': {e}\") from e\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate connection to Ollama.</p> <p>Ollama doesn't require authentication, but we check if the server is accessible.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate connection to Ollama.\n\n    Ollama doesn't require authentication, but we check\n    if the server is accessible.\n    \"\"\"\n    # Check connection in a synchronous context\n    try:\n        import httpx\n        response = httpx.get(f\"{self.base_url}/api/tags\", timeout=5)\n        response.raise_for_status()\n    except httpx.ConnectError:\n        raise ProviderError(\n            f\"Cannot connect to Ollama at {self.base_url}. \"\n            \"Is Ollama running? Start with: ollama serve\"\n        )\n    except Exception as e:\n        raise ProviderError(f\"Ollama validation failed: {e}\")\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.OllamaProvider.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit - close HTTP client.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit - close HTTP client.\"\"\"\n    await self._client.aclose()\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.list_providers","title":"<code>list_providers()</code>","text":"<p>List all available provider names.</p> Source code in <code>agenticraft/providers/__init__.py</code> <pre><code>def list_providers():\n    \"\"\"List all available provider names.\"\"\"\n    return [\"openai\", \"anthropic\", \"ollama\"]\n</code></pre>"},{"location":"reference/providers/__init__/#agenticraft.providers.get_provider","title":"<code>get_provider(provider_name, **kwargs)</code>","text":"<p>Get a provider instance by name.</p> <p>This is a convenience function that creates a provider instance based on the provider name.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Name of the provider (\"openai\", \"anthropic\", \"ollama\")</p> required <code>**kwargs</code> <p>Additional arguments passed to the provider constructor</p> <code>{}</code> <p>Returns:</p> Type Description <p>Provider instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provider name is invalid</p> Source code in <code>agenticraft/providers/__init__.py</code> <pre><code>def get_provider(provider_name: str, **kwargs):\n    \"\"\"Get a provider instance by name.\n\n    This is a convenience function that creates a provider instance\n    based on the provider name.\n\n    Args:\n        provider_name: Name of the provider (\"openai\", \"anthropic\", \"ollama\")\n        **kwargs: Additional arguments passed to the provider constructor\n\n    Returns:\n        Provider instance\n\n    Raises:\n        ValueError: If provider name is invalid\n    \"\"\"\n    providers = {\n        \"openai\": OpenAIProvider,\n        \"anthropic\": AnthropicProvider,\n        \"ollama\": OllamaProvider,\n    }\n\n    if provider_name not in providers:\n        raise ValueError(\n            f\"Unknown provider: {provider_name}. \"\n            f\"Valid providers are: {', '.join(providers.keys())}\"\n        )\n\n    return providers[provider_name](**kwargs)\n</code></pre>"},{"location":"reference/providers/anthropic/","title":"Anthropic","text":""},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic","title":"<code>anthropic</code>","text":"<p>Anthropic provider implementation for AgentiCraft.</p>"},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic.AnthropicProvider","title":"<code>AnthropicProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for Anthropic models (Claude).</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>class AnthropicProvider(BaseProvider):\n    \"\"\"Provider for Anthropic models (Claude).\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize Anthropic provider.\"\"\"\n        # Get API key from kwargs, settings, or environment\n        api_key = (\n            kwargs.get(\"api_key\") or \n            settings.anthropic_api_key or \n            os.getenv(\"ANTHROPIC_API_KEY\")\n        )\n        if not api_key:\n            raise ProviderAuthError(\"anthropic\")\n\n        kwargs[\"api_key\"] = api_key\n        kwargs.setdefault(\"base_url\", settings.anthropic_base_url)\n\n        # Store model if provided\n        self.model = kwargs.pop('model', 'claude-3-opus-20240229')\n\n        super().__init__(**kwargs)\n\n        self._client = None\n\n    @property\n    def client(self):\n        \"\"\"Get or create Anthropic client.\"\"\"\n        if self._client is None:\n            try:\n                from anthropic import AsyncAnthropic\n                self._client = AsyncAnthropic(\n                    api_key=self.api_key,\n                    base_url=self.base_url,\n                    timeout=self.timeout,\n                    max_retries=self.max_retries\n                )\n            except ImportError:\n                raise ProviderError(\"Anthropic provider requires 'anthropic' package\")\n        return self._client\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from Anthropic.\n\n        Reference: Simplified from agentic-framework patterns.\n        \"\"\"\n        try:\n            # Use provided model or default\n            actual_model = model or self.model\n\n            # Format messages - extract system message (Anthropic pattern)\n            system_prompt, chat_messages = self._extract_system_message(messages)\n\n            # Prepare request parameters\n            request_params = {\n                \"model\": actual_model,\n                \"messages\": self._format_messages(chat_messages),\n                \"max_tokens\": max_tokens or 4096,\n                \"temperature\": temperature,\n                **kwargs\n            }\n\n            # Add system prompt if present\n            if system_prompt:\n                request_params[\"system\"] = system_prompt\n\n            # Add tools if provided\n            if tools:\n                request_params[\"tools\"] = self._convert_tools(tools)\n                if tool_choice is not None:\n                    request_params[\"tool_choice\"] = self._format_tool_choice(tool_choice)\n\n            # Make API call\n            response = await self.client.messages.create(**request_params)\n\n            # Parse response content\n            content = \"\"\n            tool_calls = []\n\n            for block in response.content:\n                if hasattr(block, 'text'):\n                    content += block.text\n                elif hasattr(block, 'type') and block.type == 'tool_use':\n                    # Extract tool call information\n                    tool_calls.append(ToolCall(\n                        id=block.id,\n                        name=block.name,\n                        arguments=block.input\n                    ))\n\n            # Extract usage information\n            usage_data = None\n            if hasattr(response, 'usage'):\n                usage_data = {\n                    \"prompt_tokens\": response.usage.input_tokens,\n                    \"completion_tokens\": response.usage.output_tokens,\n                    \"total_tokens\": response.usage.input_tokens + response.usage.output_tokens\n                }\n\n            return CompletionResponse(\n                content=content,\n                tool_calls=tool_calls,\n                finish_reason=response.stop_reason,\n                usage=usage_data,\n                metadata={\n                    \"model\": actual_model,\n                    \"stop_sequence\": getattr(response, 'stop_sequence', None)\n                },\n                model=actual_model\n            )\n\n        except Exception as e:\n            raise ProviderError(f\"Anthropic completion failed: {e}\") from e\n\n    def _extract_system_message(self, messages: Union[List[Message], List[Dict[str, Any]]]) -&gt; tuple:\n        \"\"\"Extract system message from messages list.\n\n        Pattern from agentic-framework: Anthropic requires system message\n        to be passed separately.\n        \"\"\"\n        system_prompt = None\n        chat_messages = []\n\n        for msg in messages:\n            # Handle both Message objects and dicts\n            if isinstance(msg, Message):\n                role = str(msg.role)\n                content = msg.content\n            else:\n                role = msg.get(\"role\")\n                content = msg.get(\"content\")\n\n            if role == \"system\":\n                system_prompt = content\n            else:\n                chat_messages.append(msg)\n\n        return system_prompt, chat_messages\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for Anthropic API.\"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append(msg.to_dict())\n            elif isinstance(msg, dict):\n                formatted.append(msg)\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n\n    def _convert_tools(self, tools: Union[List[ToolDefinition], List[Dict[str, Any]]]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Convert tools to Anthropic format.\n\n        Pattern from agentic-framework: Different tool schema format.\n        \"\"\"\n        anthropic_tools = []\n\n        for tool in tools:\n            if isinstance(tool, ToolDefinition):\n                # Convert from ToolDefinition\n                schema = tool.to_openai_schema()\n                func_def = schema[\"function\"]\n                anthropic_tools.append({\n                    \"name\": func_def[\"name\"],\n                    \"description\": func_def[\"description\"],\n                    \"input_schema\": func_def[\"parameters\"]\n                })\n            elif isinstance(tool, dict):\n                # Already in dict format - convert to Anthropic format\n                if \"function\" in tool:\n                    # OpenAI format\n                    func = tool[\"function\"]\n                    anthropic_tools.append({\n                        \"name\": func[\"name\"],\n                        \"description\": func.get(\"description\", \"\"),\n                        \"input_schema\": func.get(\"parameters\", {})\n                    })\n                else:\n                    # Assume it's already in Anthropic format\n                    anthropic_tools.append(tool)\n\n        return anthropic_tools\n\n    def _format_tool_choice(self, tool_choice: Any) -&gt; Dict[str, Any]:\n        \"\"\"Format tool choice for Anthropic API.\"\"\"\n        if isinstance(tool_choice, str):\n            if tool_choice == \"auto\":\n                return {\"type\": \"auto\"}\n            elif tool_choice == \"none\":\n                return {\"type\": \"any\"}\n            else:\n                # Specific tool name\n                return {\"type\": \"tool\", \"name\": tool_choice}\n        elif isinstance(tool_choice, dict):\n            return tool_choice\n        else:\n            return {\"type\": \"auto\"}\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate Anthropic API key.\"\"\"\n        if not self.api_key:\n            raise ProviderAuthError(\"anthropic\")\n</code></pre>"},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic.AnthropicProvider.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get or create Anthropic client.</p>"},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic.AnthropicProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize Anthropic provider.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize Anthropic provider.\"\"\"\n    # Get API key from kwargs, settings, or environment\n    api_key = (\n        kwargs.get(\"api_key\") or \n        settings.anthropic_api_key or \n        os.getenv(\"ANTHROPIC_API_KEY\")\n    )\n    if not api_key:\n        raise ProviderAuthError(\"anthropic\")\n\n    kwargs[\"api_key\"] = api_key\n    kwargs.setdefault(\"base_url\", settings.anthropic_base_url)\n\n    # Store model if provided\n    self.model = kwargs.pop('model', 'claude-3-opus-20240229')\n\n    super().__init__(**kwargs)\n\n    self._client = None\n</code></pre>"},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic.AnthropicProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from Anthropic.</p> <p>Reference: Simplified from agentic-framework patterns.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from Anthropic.\n\n    Reference: Simplified from agentic-framework patterns.\n    \"\"\"\n    try:\n        # Use provided model or default\n        actual_model = model or self.model\n\n        # Format messages - extract system message (Anthropic pattern)\n        system_prompt, chat_messages = self._extract_system_message(messages)\n\n        # Prepare request parameters\n        request_params = {\n            \"model\": actual_model,\n            \"messages\": self._format_messages(chat_messages),\n            \"max_tokens\": max_tokens or 4096,\n            \"temperature\": temperature,\n            **kwargs\n        }\n\n        # Add system prompt if present\n        if system_prompt:\n            request_params[\"system\"] = system_prompt\n\n        # Add tools if provided\n        if tools:\n            request_params[\"tools\"] = self._convert_tools(tools)\n            if tool_choice is not None:\n                request_params[\"tool_choice\"] = self._format_tool_choice(tool_choice)\n\n        # Make API call\n        response = await self.client.messages.create(**request_params)\n\n        # Parse response content\n        content = \"\"\n        tool_calls = []\n\n        for block in response.content:\n            if hasattr(block, 'text'):\n                content += block.text\n            elif hasattr(block, 'type') and block.type == 'tool_use':\n                # Extract tool call information\n                tool_calls.append(ToolCall(\n                    id=block.id,\n                    name=block.name,\n                    arguments=block.input\n                ))\n\n        # Extract usage information\n        usage_data = None\n        if hasattr(response, 'usage'):\n            usage_data = {\n                \"prompt_tokens\": response.usage.input_tokens,\n                \"completion_tokens\": response.usage.output_tokens,\n                \"total_tokens\": response.usage.input_tokens + response.usage.output_tokens\n            }\n\n        return CompletionResponse(\n            content=content,\n            tool_calls=tool_calls,\n            finish_reason=response.stop_reason,\n            usage=usage_data,\n            metadata={\n                \"model\": actual_model,\n                \"stop_sequence\": getattr(response, 'stop_sequence', None)\n            },\n            model=actual_model\n        )\n\n    except Exception as e:\n        raise ProviderError(f\"Anthropic completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/anthropic/#agenticraft.providers.anthropic.AnthropicProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate Anthropic API key.</p> Source code in <code>agenticraft/providers/anthropic.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate Anthropic API key.\"\"\"\n    if not self.api_key:\n        raise ProviderAuthError(\"anthropic\")\n</code></pre>"},{"location":"reference/providers/ollama/","title":"Ollama","text":""},{"location":"reference/providers/ollama/#agenticraft.providers.ollama","title":"<code>ollama</code>","text":"<p>Ollama provider implementation for AgentiCraft.</p> <p>This provider enables the use of local models through Ollama, supporting various open-source models like Llama, Mistral, and others.</p> Example <p>Using Ollama models locally::</p> <pre><code>from agenticraft import Agent\n\n# Use default Ollama model\nagent = Agent(model=\"ollama/llama2\")\n\n# Use specific model with custom base URL\nagent = Agent(\n    model=\"ollama/codellama\",\n    base_url=\"http://localhost:11434\"\n)\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider","title":"<code>OllamaProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for local Ollama models.</p> <p>Ollama allows running open-source LLMs locally. This provider supports all Ollama features including streaming, custom models, and model management.</p> <p>Note: Requires Ollama to be installed and running locally. See: https://ollama.ai for installation instructions.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>class OllamaProvider(BaseProvider):\n    \"\"\"Provider for local Ollama models.\n\n    Ollama allows running open-source LLMs locally. This provider\n    supports all Ollama features including streaming, custom models,\n    and model management.\n\n    Note: Requires Ollama to be installed and running locally.\n    See: https://ollama.ai for installation instructions.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize Ollama provider.\n\n        Args:\n            base_url: Ollama server URL (default: http://localhost:11434)\n            model: Model name (default: llama2)\n            timeout: Request timeout in seconds (default: 300 for long generations)\n            **kwargs: Additional provider arguments\n        \"\"\"\n        # Set defaults for Ollama\n        # Handle None or missing base_url\n        if kwargs.get(\"base_url\") is None or \"base_url\" not in kwargs:\n            default_url = \"http://localhost:11434\"\n            if hasattr(settings, 'ollama_base_url') and settings.ollama_base_url:\n                default_url = settings.ollama_base_url\n            kwargs[\"base_url\"] = default_url\n\n        kwargs.setdefault(\"timeout\", 300)  # Ollama can be slow for first run\n        kwargs[\"api_key\"] = \"ollama\"  # Ollama doesn't need API key\n\n        # Extract and store model\n        self.model = kwargs.pop('model', 'llama2')\n        # Handle ollama/ prefix\n        if self.model.startswith('ollama/'):\n            self.model = self.model[7:]  # Remove 'ollama/' prefix\n\n        super().__init__(**kwargs)\n\n        # Create HTTP client\n        self._client = httpx.AsyncClient(\n            base_url=self.base_url,\n            timeout=self.timeout\n        )\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from Ollama.\n\n        Args:\n            messages: Conversation messages\n            model: Optional model override\n            tools: Tool definitions (Note: Tool support depends on model)\n            tool_choice: Tool choice strategy (if tools supported)\n            temperature: Sampling temperature (0-2)\n            max_tokens: Maximum tokens to generate\n            **kwargs: Additional Ollama parameters\n\n        Returns:\n            CompletionResponse with generated content\n\n        Raises:\n            ProviderError: If Ollama request fails\n        \"\"\"\n        try:\n            # Use provided model or default\n            actual_model = model or self.model\n            if actual_model.startswith('ollama/'):\n                actual_model = actual_model[7:]\n\n            # Format messages for Ollama\n            formatted_messages = self._format_messages(messages)\n\n            # Prepare request body\n            request_body = {\n                \"model\": actual_model,\n                \"messages\": formatted_messages,\n                \"stream\": False,\n                \"options\": {\n                    \"temperature\": temperature,\n                }\n            }\n\n            # Add max_tokens as num_predict in Ollama\n            if max_tokens:\n                request_body[\"options\"][\"num_predict\"] = max_tokens\n\n            # Add any additional options\n            for key, value in kwargs.items():\n                if key not in [\"model\", \"messages\", \"stream\"]:\n                    request_body[\"options\"][key] = value\n\n            # Note: Ollama's tool support is model-dependent\n            # For now, we'll include tools in the system prompt if provided\n            if tools:\n                tool_description = self._format_tools_as_text(tools)\n                # Prepend tool description to first user message or add system message\n                if formatted_messages and formatted_messages[0][\"role\"] == \"system\":\n                    formatted_messages[0][\"content\"] += f\"\\n\\n{tool_description}\"\n                else:\n                    formatted_messages.insert(0, {\n                        \"role\": \"system\",\n                        \"content\": tool_description\n                    })\n\n            # Make request to Ollama\n            response = await self._client.post(\n                \"/api/chat\",\n                json=request_body\n            )\n            response.raise_for_status()\n\n            # Parse response\n            data = response.json()\n\n            # Extract message content\n            message = data.get(\"message\", {})\n            content = message.get(\"content\", \"\")\n\n            # Calculate token usage (approximate if not provided)\n            prompt_tokens = data.get(\"prompt_eval_count\", 0)\n            completion_tokens = data.get(\"eval_count\", 0)\n\n            usage_data = {\n                \"prompt_tokens\": prompt_tokens,\n                \"completion_tokens\": completion_tokens,\n                \"total_tokens\": prompt_tokens + completion_tokens\n            } if (prompt_tokens or completion_tokens) else None\n\n            # Extract metadata\n            metadata = {\n                \"model\": actual_model,\n                \"eval_duration\": data.get(\"eval_duration\"),\n                \"load_duration\": data.get(\"load_duration\"),\n                \"total_duration\": data.get(\"total_duration\"),\n            }\n\n            return CompletionResponse(\n                content=content,\n                tool_calls=[],  # Ollama doesn't have native tool calling yet\n                finish_reason=\"stop\",\n                usage=usage_data,\n                metadata=metadata,\n                model=actual_model\n            )\n\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 404:\n                raise ProviderError(\n                    f\"Model '{actual_model}' not found. \"\n                    f\"Try: ollama pull {actual_model}\"\n                )\n            elif e.response.status_code == 500:\n                raise ProviderError(\n                    \"Ollama server error. Is Ollama running? \"\n                    \"Start with: ollama serve\"\n                )\n            else:\n                raise ProviderError(f\"Ollama HTTP error: {e}\")\n        except httpx.ConnectError:\n            raise ProviderError(\n                f\"Cannot connect to Ollama at {self.base_url}. \"\n                \"Is Ollama running? Start with: ollama serve\"\n            )\n        except Exception as e:\n            raise ProviderError(f\"Ollama completion failed: {e}\") from e\n\n    async def list_models(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List available Ollama models.\n\n        Returns:\n            List of model information dictionaries\n\n        Raises:\n            ProviderError: If request fails\n        \"\"\"\n        try:\n            response = await self._client.get(\"/api/tags\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"models\", [])\n        except Exception as e:\n            raise ProviderError(f\"Failed to list Ollama models: {e}\") from e\n\n    async def pull_model(self, model_name: str) -&gt; None:\n        \"\"\"Pull (download) a model from Ollama registry.\n\n        Args:\n            model_name: Name of model to pull (e.g., \"llama2\", \"codellama\")\n\n        Raises:\n            ProviderError: If pull fails\n        \"\"\"\n        try:\n            response = await self._client.post(\n                \"/api/pull\",\n                json={\"name\": model_name},\n                timeout=None  # Pulling can take a long time\n            )\n            response.raise_for_status()\n        except Exception as e:\n            raise ProviderError(f\"Failed to pull model '{model_name}': {e}\") from e\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate connection to Ollama.\n\n        Ollama doesn't require authentication, but we check\n        if the server is accessible.\n        \"\"\"\n        # Check connection in a synchronous context\n        try:\n            import httpx\n            response = httpx.get(f\"{self.base_url}/api/tags\", timeout=5)\n            response.raise_for_status()\n        except httpx.ConnectError:\n            raise ProviderError(\n                f\"Cannot connect to Ollama at {self.base_url}. \"\n                \"Is Ollama running? Start with: ollama serve\"\n            )\n        except Exception as e:\n            raise ProviderError(f\"Ollama validation failed: {e}\")\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for Ollama API.\n\n        Args:\n            messages: List of Message objects or message dicts\n\n        Returns:\n            List of message dictionaries for Ollama\n        \"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append({\n                    \"role\": str(msg.role),\n                    \"content\": msg.content\n                })\n            elif isinstance(msg, dict):\n                # Ensure role is lowercase for Ollama\n                formatted.append({\n                    \"role\": msg[\"role\"].lower(),\n                    \"content\": msg[\"content\"]\n                })\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n\n    def _format_tools_as_text(self, tools: Union[List[ToolDefinition], List[Dict[str, Any]]]) -&gt; str:\n        \"\"\"Format tools as text description for models without native tool support.\n\n        Args:\n            tools: List of tool definitions\n\n        Returns:\n            Text description of available tools\n        \"\"\"\n        tool_descriptions = [\"Available tools:\"]\n\n        for tool in tools:\n            if isinstance(tool, ToolDefinition):\n                name = tool.name\n                description = tool.description\n                params = tool.parameters\n            elif isinstance(tool, dict) and \"function\" in tool:\n                # OpenAI format\n                func = tool[\"function\"]\n                name = func[\"name\"]\n                description = func.get(\"description\", \"\")\n                params = func.get(\"parameters\", {}).get(\"properties\", {})\n            else:\n                continue\n\n            tool_descriptions.append(f\"\\n- {name}: {description}\")\n            if params:\n                tool_descriptions.append(f\"  Parameters: {params}\")\n\n        tool_descriptions.append(\n            \"\\nTo use a tool, respond with: \"\n            \"TOOL_CALL: {\\\"name\\\": \\\"tool_name\\\", \\\"arguments\\\": {...}}\"\n        )\n\n        return \"\\n\".join(tool_descriptions)\n\n    async def __aenter__(self):\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit - close HTTP client.\"\"\"\n        await self._client.aclose()\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize Ollama provider.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <p>Ollama server URL (default: http://localhost:11434)</p> required <code>model</code> <p>Model name (default: llama2)</p> required <code>timeout</code> <p>Request timeout in seconds (default: 300 for long generations)</p> required <code>**kwargs</code> <p>Additional provider arguments</p> <code>{}</code> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize Ollama provider.\n\n    Args:\n        base_url: Ollama server URL (default: http://localhost:11434)\n        model: Model name (default: llama2)\n        timeout: Request timeout in seconds (default: 300 for long generations)\n        **kwargs: Additional provider arguments\n    \"\"\"\n    # Set defaults for Ollama\n    # Handle None or missing base_url\n    if kwargs.get(\"base_url\") is None or \"base_url\" not in kwargs:\n        default_url = \"http://localhost:11434\"\n        if hasattr(settings, 'ollama_base_url') and settings.ollama_base_url:\n            default_url = settings.ollama_base_url\n        kwargs[\"base_url\"] = default_url\n\n    kwargs.setdefault(\"timeout\", 300)  # Ollama can be slow for first run\n    kwargs[\"api_key\"] = \"ollama\"  # Ollama doesn't need API key\n\n    # Extract and store model\n    self.model = kwargs.pop('model', 'llama2')\n    # Handle ollama/ prefix\n    if self.model.startswith('ollama/'):\n        self.model = self.model[7:]  # Remove 'ollama/' prefix\n\n    super().__init__(**kwargs)\n\n    # Create HTTP client\n    self._client = httpx.AsyncClient(\n        base_url=self.base_url,\n        timeout=self.timeout\n    )\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from Ollama.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Union[List[Message], List[Dict[str, Any]]]</code> <p>Conversation messages</p> required <code>model</code> <code>Optional[str]</code> <p>Optional model override</p> <code>None</code> <code>tools</code> <code>Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]]</code> <p>Tool definitions (Note: Tool support depends on model)</p> <code>None</code> <code>tool_choice</code> <code>Optional[Any]</code> <p>Tool choice strategy (if tools supported)</p> <code>None</code> <code>temperature</code> <code>float</code> <p>Sampling temperature (0-2)</p> <code>0.7</code> <code>max_tokens</code> <code>Optional[int]</code> <p>Maximum tokens to generate</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional Ollama parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>CompletionResponse</code> <p>CompletionResponse with generated content</p> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If Ollama request fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from Ollama.\n\n    Args:\n        messages: Conversation messages\n        model: Optional model override\n        tools: Tool definitions (Note: Tool support depends on model)\n        tool_choice: Tool choice strategy (if tools supported)\n        temperature: Sampling temperature (0-2)\n        max_tokens: Maximum tokens to generate\n        **kwargs: Additional Ollama parameters\n\n    Returns:\n        CompletionResponse with generated content\n\n    Raises:\n        ProviderError: If Ollama request fails\n    \"\"\"\n    try:\n        # Use provided model or default\n        actual_model = model or self.model\n        if actual_model.startswith('ollama/'):\n            actual_model = actual_model[7:]\n\n        # Format messages for Ollama\n        formatted_messages = self._format_messages(messages)\n\n        # Prepare request body\n        request_body = {\n            \"model\": actual_model,\n            \"messages\": formatted_messages,\n            \"stream\": False,\n            \"options\": {\n                \"temperature\": temperature,\n            }\n        }\n\n        # Add max_tokens as num_predict in Ollama\n        if max_tokens:\n            request_body[\"options\"][\"num_predict\"] = max_tokens\n\n        # Add any additional options\n        for key, value in kwargs.items():\n            if key not in [\"model\", \"messages\", \"stream\"]:\n                request_body[\"options\"][key] = value\n\n        # Note: Ollama's tool support is model-dependent\n        # For now, we'll include tools in the system prompt if provided\n        if tools:\n            tool_description = self._format_tools_as_text(tools)\n            # Prepend tool description to first user message or add system message\n            if formatted_messages and formatted_messages[0][\"role\"] == \"system\":\n                formatted_messages[0][\"content\"] += f\"\\n\\n{tool_description}\"\n            else:\n                formatted_messages.insert(0, {\n                    \"role\": \"system\",\n                    \"content\": tool_description\n                })\n\n        # Make request to Ollama\n        response = await self._client.post(\n            \"/api/chat\",\n            json=request_body\n        )\n        response.raise_for_status()\n\n        # Parse response\n        data = response.json()\n\n        # Extract message content\n        message = data.get(\"message\", {})\n        content = message.get(\"content\", \"\")\n\n        # Calculate token usage (approximate if not provided)\n        prompt_tokens = data.get(\"prompt_eval_count\", 0)\n        completion_tokens = data.get(\"eval_count\", 0)\n\n        usage_data = {\n            \"prompt_tokens\": prompt_tokens,\n            \"completion_tokens\": completion_tokens,\n            \"total_tokens\": prompt_tokens + completion_tokens\n        } if (prompt_tokens or completion_tokens) else None\n\n        # Extract metadata\n        metadata = {\n            \"model\": actual_model,\n            \"eval_duration\": data.get(\"eval_duration\"),\n            \"load_duration\": data.get(\"load_duration\"),\n            \"total_duration\": data.get(\"total_duration\"),\n        }\n\n        return CompletionResponse(\n            content=content,\n            tool_calls=[],  # Ollama doesn't have native tool calling yet\n            finish_reason=\"stop\",\n            usage=usage_data,\n            metadata=metadata,\n            model=actual_model\n        )\n\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise ProviderError(\n                f\"Model '{actual_model}' not found. \"\n                f\"Try: ollama pull {actual_model}\"\n            )\n        elif e.response.status_code == 500:\n            raise ProviderError(\n                \"Ollama server error. Is Ollama running? \"\n                \"Start with: ollama serve\"\n            )\n        else:\n            raise ProviderError(f\"Ollama HTTP error: {e}\")\n    except httpx.ConnectError:\n        raise ProviderError(\n            f\"Cannot connect to Ollama at {self.base_url}. \"\n            \"Is Ollama running? Start with: ollama serve\"\n        )\n    except Exception as e:\n        raise ProviderError(f\"Ollama completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.list_models","title":"<code>list_models()</code>  <code>async</code>","text":"<p>List available Ollama models.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of model information dictionaries</p> <p>Raises:</p> Type Description <code>ProviderError</code> <p>If request fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def list_models(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"List available Ollama models.\n\n    Returns:\n        List of model information dictionaries\n\n    Raises:\n        ProviderError: If request fails\n    \"\"\"\n    try:\n        response = await self._client.get(\"/api/tags\")\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"models\", [])\n    except Exception as e:\n        raise ProviderError(f\"Failed to list Ollama models: {e}\") from e\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.pull_model","title":"<code>pull_model(model_name)</code>  <code>async</code>","text":"<p>Pull (download) a model from Ollama registry.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Name of model to pull (e.g., \"llama2\", \"codellama\")</p> required <p>Raises:</p> Type Description <code>ProviderError</code> <p>If pull fails</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def pull_model(self, model_name: str) -&gt; None:\n    \"\"\"Pull (download) a model from Ollama registry.\n\n    Args:\n        model_name: Name of model to pull (e.g., \"llama2\", \"codellama\")\n\n    Raises:\n        ProviderError: If pull fails\n    \"\"\"\n    try:\n        response = await self._client.post(\n            \"/api/pull\",\n            json={\"name\": model_name},\n            timeout=None  # Pulling can take a long time\n        )\n        response.raise_for_status()\n    except Exception as e:\n        raise ProviderError(f\"Failed to pull model '{model_name}': {e}\") from e\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate connection to Ollama.</p> <p>Ollama doesn't require authentication, but we check if the server is accessible.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate connection to Ollama.\n\n    Ollama doesn't require authentication, but we check\n    if the server is accessible.\n    \"\"\"\n    # Check connection in a synchronous context\n    try:\n        import httpx\n        response = httpx.get(f\"{self.base_url}/api/tags\", timeout=5)\n        response.raise_for_status()\n    except httpx.ConnectError:\n        raise ProviderError(\n            f\"Cannot connect to Ollama at {self.base_url}. \"\n            \"Is Ollama running? Start with: ollama serve\"\n        )\n    except Exception as e:\n        raise ProviderError(f\"Ollama validation failed: {e}\")\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/providers/ollama/#agenticraft.providers.ollama.OllamaProvider.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit - close HTTP client.</p> Source code in <code>agenticraft/providers/ollama.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit - close HTTP client.\"\"\"\n    await self._client.aclose()\n</code></pre>"},{"location":"reference/providers/openai/","title":"Openai","text":""},{"location":"reference/providers/openai/#agenticraft.providers.openai","title":"<code>openai</code>","text":"<p>OpenAI provider implementation for AgentiCraft.</p>"},{"location":"reference/providers/openai/#agenticraft.providers.openai.OpenAIProvider","title":"<code>OpenAIProvider</code>","text":"<p>               Bases: <code>BaseProvider</code></p> <p>Provider for OpenAI models (GPT-4, GPT-3.5, etc.).</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>class OpenAIProvider(BaseProvider):\n    \"\"\"Provider for OpenAI models (GPT-4, GPT-3.5, etc.).\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize OpenAI provider.\"\"\"\n        # Get API key from kwargs, settings, or environment\n        api_key = (\n            kwargs.get(\"api_key\") or \n            settings.openai_api_key or \n            os.getenv(\"OPENAI_API_KEY\")\n        )\n        if not api_key:\n            raise ValueError(\"API key required for OpenAI provider\")\n\n        kwargs[\"api_key\"] = api_key\n        kwargs.setdefault(\"base_url\", settings.openai_base_url)\n\n        # Store model if provided\n        self.model = kwargs.pop('model', 'gpt-4')\n\n        super().__init__(**kwargs)\n\n        self._client = None\n\n    @property\n    def client(self):\n        \"\"\"Get or create OpenAI client.\"\"\"\n        if self._client is None:\n            try:\n                from openai import AsyncOpenAI\n                self._client = AsyncOpenAI(\n                    api_key=self.api_key,\n                    base_url=self.base_url,\n                    timeout=self.timeout,\n                    max_retries=self.max_retries\n                )\n            except ImportError:\n                raise ProviderError(\"OpenAI provider requires 'openai' package\")\n        return self._client\n\n    async def complete(\n        self,\n        messages: Union[List[Message], List[Dict[str, Any]]],\n        model: Optional[str] = None,\n        tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n        tool_choice: Optional[Any] = None,\n        temperature: float = 0.7,\n        max_tokens: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; CompletionResponse:\n        \"\"\"Get completion from OpenAI.\"\"\"\n        try:\n            # Remove model from kwargs to avoid duplication\n            kwargs.pop('model', None)\n\n            # Use provided model or default\n            actual_model = model or self.model\n\n            # Format messages\n            formatted_messages = self._format_messages(messages)\n\n            # Prepare request parameters\n            request_params = {\n                \"model\": actual_model,\n                \"messages\": formatted_messages,\n                \"temperature\": temperature,\n                **kwargs\n            }\n\n            if max_tokens:\n                request_params[\"max_tokens\"] = max_tokens\n\n            # Add tools if provided\n            if tools:\n                # Handle both ToolDefinition objects and raw dicts\n                if tools and isinstance(tools[0], dict):\n                    request_params[\"tools\"] = tools\n                else:\n                    request_params[\"tools\"] = [tool.to_openai_schema() for tool in tools]\n                request_params[\"tool_choice\"] = tool_choice if tool_choice is not None else \"auto\"\n\n            # Make request\n            response = await self.client.chat.completions.create(**request_params)\n\n            # Parse response\n            choice = response.choices[0]\n\n            # Extract usage - modern OpenAI SDK format\n            usage_data = None\n            if response.usage:\n                usage_data = {\n                    \"prompt_tokens\": response.usage.prompt_tokens,\n                    \"completion_tokens\": response.usage.completion_tokens,\n                    \"total_tokens\": response.usage.total_tokens\n                }\n\n            # Extract tool calls if any\n            tool_calls = []\n            if hasattr(choice.message, \"tool_calls\") and choice.message.tool_calls:\n                for tc in choice.message.tool_calls:\n                    try:\n                        # Parse arguments - handle JSON strings\n                        args = tc.function.arguments\n                        if isinstance(args, str):\n                            args = json.loads(args)\n\n                        tool_calls.append(ToolCall(\n                            id=str(tc.id),\n                            name=tc.function.name,\n                            arguments=args\n                        ))\n                    except json.JSONDecodeError as e:\n                        # Skip malformed tool calls\n                        logger.warning(f\"Failed to parse tool arguments: {e}\")\n                        continue\n\n            return CompletionResponse(\n                content=choice.message.content or \"\",\n                tool_calls=tool_calls,\n                finish_reason=choice.finish_reason,\n                usage=usage_data,\n                metadata={\"model\": actual_model},\n                model=actual_model\n            )\n\n        except Exception as e:\n            raise ProviderError(f\"OpenAI completion failed: {e}\") from e\n\n    def validate_auth(self) -&gt; None:\n        \"\"\"Validate OpenAI API key.\"\"\"\n        if not self.api_key or not self.api_key.startswith(\"sk-\"):\n            raise ProviderAuthError(\"openai\")\n\n    def _format_messages(self, messages: List[Any]) -&gt; List[Dict[str, Any]]:\n        \"\"\"Format messages for OpenAI API.\n\n        Args:\n            messages: List of Message objects or message dicts\n\n        Returns:\n            List of message dictionaries for OpenAI API\n        \"\"\"\n        formatted = []\n        for msg in messages:\n            if isinstance(msg, Message):\n                formatted.append(msg.to_dict())\n            elif isinstance(msg, dict):\n                formatted.append(msg)\n            else:\n                raise ValueError(f\"Invalid message type: {type(msg)}\")\n        return formatted\n</code></pre>"},{"location":"reference/providers/openai/#agenticraft.providers.openai.OpenAIProvider.client","title":"<code>client</code>  <code>property</code>","text":"<p>Get or create OpenAI client.</p>"},{"location":"reference/providers/openai/#agenticraft.providers.openai.OpenAIProvider.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize OpenAI provider.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize OpenAI provider.\"\"\"\n    # Get API key from kwargs, settings, or environment\n    api_key = (\n        kwargs.get(\"api_key\") or \n        settings.openai_api_key or \n        os.getenv(\"OPENAI_API_KEY\")\n    )\n    if not api_key:\n        raise ValueError(\"API key required for OpenAI provider\")\n\n    kwargs[\"api_key\"] = api_key\n    kwargs.setdefault(\"base_url\", settings.openai_base_url)\n\n    # Store model if provided\n    self.model = kwargs.pop('model', 'gpt-4')\n\n    super().__init__(**kwargs)\n\n    self._client = None\n</code></pre>"},{"location":"reference/providers/openai/#agenticraft.providers.openai.OpenAIProvider.complete","title":"<code>complete(messages, model=None, tools=None, tool_choice=None, temperature=0.7, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Get completion from OpenAI.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>async def complete(\n    self,\n    messages: Union[List[Message], List[Dict[str, Any]]],\n    model: Optional[str] = None,\n    tools: Optional[Union[List[ToolDefinition], List[Dict[str, Any]]]] = None,\n    tool_choice: Optional[Any] = None,\n    temperature: float = 0.7,\n    max_tokens: Optional[int] = None,\n    **kwargs: Any\n) -&gt; CompletionResponse:\n    \"\"\"Get completion from OpenAI.\"\"\"\n    try:\n        # Remove model from kwargs to avoid duplication\n        kwargs.pop('model', None)\n\n        # Use provided model or default\n        actual_model = model or self.model\n\n        # Format messages\n        formatted_messages = self._format_messages(messages)\n\n        # Prepare request parameters\n        request_params = {\n            \"model\": actual_model,\n            \"messages\": formatted_messages,\n            \"temperature\": temperature,\n            **kwargs\n        }\n\n        if max_tokens:\n            request_params[\"max_tokens\"] = max_tokens\n\n        # Add tools if provided\n        if tools:\n            # Handle both ToolDefinition objects and raw dicts\n            if tools and isinstance(tools[0], dict):\n                request_params[\"tools\"] = tools\n            else:\n                request_params[\"tools\"] = [tool.to_openai_schema() for tool in tools]\n            request_params[\"tool_choice\"] = tool_choice if tool_choice is not None else \"auto\"\n\n        # Make request\n        response = await self.client.chat.completions.create(**request_params)\n\n        # Parse response\n        choice = response.choices[0]\n\n        # Extract usage - modern OpenAI SDK format\n        usage_data = None\n        if response.usage:\n            usage_data = {\n                \"prompt_tokens\": response.usage.prompt_tokens,\n                \"completion_tokens\": response.usage.completion_tokens,\n                \"total_tokens\": response.usage.total_tokens\n            }\n\n        # Extract tool calls if any\n        tool_calls = []\n        if hasattr(choice.message, \"tool_calls\") and choice.message.tool_calls:\n            for tc in choice.message.tool_calls:\n                try:\n                    # Parse arguments - handle JSON strings\n                    args = tc.function.arguments\n                    if isinstance(args, str):\n                        args = json.loads(args)\n\n                    tool_calls.append(ToolCall(\n                        id=str(tc.id),\n                        name=tc.function.name,\n                        arguments=args\n                    ))\n                except json.JSONDecodeError as e:\n                    # Skip malformed tool calls\n                    logger.warning(f\"Failed to parse tool arguments: {e}\")\n                    continue\n\n        return CompletionResponse(\n            content=choice.message.content or \"\",\n            tool_calls=tool_calls,\n            finish_reason=choice.finish_reason,\n            usage=usage_data,\n            metadata={\"model\": actual_model},\n            model=actual_model\n        )\n\n    except Exception as e:\n        raise ProviderError(f\"OpenAI completion failed: {e}\") from e\n</code></pre>"},{"location":"reference/providers/openai/#agenticraft.providers.openai.OpenAIProvider.validate_auth","title":"<code>validate_auth()</code>","text":"<p>Validate OpenAI API key.</p> Source code in <code>agenticraft/providers/openai.py</code> <pre><code>def validate_auth(self) -&gt; None:\n    \"\"\"Validate OpenAI API key.\"\"\"\n    if not self.api_key or not self.api_key.startswith(\"sk-\"):\n        raise ProviderAuthError(\"openai\")\n</code></pre>"},{"location":"reference/telemetry/__init__/","title":"init","text":""},{"location":"reference/telemetry/__init__/#agenticraft.telemetry","title":"<code>telemetry</code>","text":"<p>Telemetry and observability for AgentiCraft.</p> <p>This package provides comprehensive telemetry support including: - OpenTelemetry integration for distributed tracing - Metrics collection and export - Automatic instrumentation - Decorators for easy telemetry addition</p> Example <p>Basic telemetry setup::</p> <pre><code>from agenticraft.telemetry import setup_telemetry, track_metrics\n\n# Initialize telemetry\nsetup_telemetry(\n    service_name=\"my-agent-app\",\n    export_endpoint=\"http://localhost:4317\"\n)\n\n# Use decorators for automatic tracking\n@track_metrics(labels=[\"agent_name\"])\nasync def run_agent(agent_name: str):\n    # Your code here\n    pass\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TelemetryConfig","title":"<code>TelemetryConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete telemetry configuration.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class TelemetryConfig(BaseModel):\n    \"\"\"Complete telemetry configuration.\"\"\"\n\n    enabled: bool = Field(\n        default=True,\n        description=\"Whether telemetry is enabled\"\n    )\n\n    # Resource configuration\n    resource: ResourceConfig = Field(\n        default_factory=ResourceConfig,\n        description=\"Resource configuration\"\n    )\n\n    # Tracing configuration\n    export_traces: bool = Field(\n        default=True,\n        description=\"Whether to export traces\"\n    )\n    trace_exporter: ExporterConfig = Field(\n        default_factory=ExporterConfig,\n        description=\"Trace exporter configuration\"\n    )\n    sampling: SamplingConfig = Field(\n        default_factory=SamplingConfig,\n        description=\"Trace sampling configuration\"\n    )\n\n    # Metrics configuration\n    export_metrics: bool = Field(\n        default=True,\n        description=\"Whether to export metrics\"\n    )\n    metric_exporter: ExporterConfig = Field(\n        default_factory=ExporterConfig,\n        description=\"Metric exporter configuration\"\n    )\n    metric_interval_ms: int = Field(\n        default=60000,\n        description=\"Metric export interval in milliseconds\"\n    )\n\n    # Instrumentation\n    instrumentation: InstrumentationConfig = Field(\n        default_factory=InstrumentationConfig,\n        description=\"Automatic instrumentation settings\"\n    )\n\n    # Logging integration\n    log_correlation: bool = Field(\n        default=True,\n        description=\"Add trace IDs to logs\"\n    )\n\n    @classmethod\n    def from_env(cls) -&gt; \"TelemetryConfig\":\n        \"\"\"Create configuration from environment variables.\n\n        Supports standard OpenTelemetry environment variables:\n        - OTEL_SERVICE_NAME\n        - OTEL_EXPORTER_OTLP_ENDPOINT\n        - OTEL_TRACES_EXPORTER\n        - OTEL_METRICS_EXPORTER\n        - OTEL_TRACES_SAMPLER_ARG\n\n        Returns:\n            Configured TelemetryConfig instance\n        \"\"\"\n        config = cls()\n\n        # Service configuration\n        if service_name := os.getenv(\"OTEL_SERVICE_NAME\"):\n            config.resource.service_name = service_name\n\n        if service_version := os.getenv(\"OTEL_SERVICE_VERSION\"):\n            config.resource.service_version = service_version\n\n        # Endpoint configuration\n        if endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_ENDPOINT\"):\n            config.trace_exporter.endpoint = endpoint\n            config.metric_exporter.endpoint = endpoint\n\n        # Trace-specific endpoint\n        if trace_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_TRACES_ENDPOINT\"):\n            config.trace_exporter.endpoint = trace_endpoint\n\n        # Metric-specific endpoint\n        if metric_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\"):\n            config.metric_exporter.endpoint = metric_endpoint\n\n        # Headers\n        if headers := os.getenv(\"OTEL_EXPORTER_OTLP_HEADERS\"):\n            parsed_headers = {}\n            for header in headers.split(\",\"):\n                if \"=\" in header:\n                    key, value = header.split(\"=\", 1)\n                    parsed_headers[key.strip()] = value.strip()\n            config.trace_exporter.headers = parsed_headers\n            config.metric_exporter.headers = parsed_headers\n\n        # Sampling\n        if sample_rate := os.getenv(\"OTEL_TRACES_SAMPLER_ARG\"):\n            try:\n                config.sampling.sample_rate = float(sample_rate)\n            except ValueError:\n                pass\n\n        # Exporters\n        if traces_exporter := os.getenv(\"OTEL_TRACES_EXPORTER\"):\n            if traces_exporter == \"none\":\n                config.export_traces = False\n            elif traces_exporter in ExportFormat.__members__.values():\n                config.trace_exporter.format = ExportFormat(traces_exporter)\n\n        if metrics_exporter := os.getenv(\"OTEL_METRICS_EXPORTER\"):\n            if metrics_exporter == \"none\":\n                config.export_metrics = False\n            elif metrics_exporter in ExportFormat.__members__.values():\n                config.metric_exporter.format = ExportFormat(metrics_exporter)\n\n        return config\n\n    def to_env_dict(self) -&gt; Dict[str, str]:\n        \"\"\"Convert configuration to environment variables.\n\n        Returns:\n            Dictionary of environment variables\n        \"\"\"\n        env_vars = {\n            \"OTEL_SERVICE_NAME\": self.resource.service_name,\n            \"OTEL_SERVICE_VERSION\": self.resource.service_version,\n            \"OTEL_TRACES_SAMPLER_ARG\": str(self.sampling.sample_rate),\n        }\n\n        if self.trace_exporter.endpoint:\n            env_vars[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = self.trace_exporter.endpoint\n\n        if self.trace_exporter.headers:\n            headers_str = \",\".join(\n                f\"{k}={v}\" for k, v in self.trace_exporter.headers.items()\n            )\n            env_vars[\"OTEL_EXPORTER_OTLP_HEADERS\"] = headers_str\n\n        if not self.export_traces:\n            env_vars[\"OTEL_TRACES_EXPORTER\"] = \"none\"\n        else:\n            env_vars[\"OTEL_TRACES_EXPORTER\"] = self.trace_exporter.format.value\n\n        if not self.export_metrics:\n            env_vars[\"OTEL_METRICS_EXPORTER\"] = \"none\"\n        else:\n            env_vars[\"OTEL_METRICS_EXPORTER\"] = self.metric_exporter.format.value\n\n        return env_vars\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TelemetryConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create configuration from environment variables.</p> <p>Supports standard OpenTelemetry environment variables: - OTEL_SERVICE_NAME - OTEL_EXPORTER_OTLP_ENDPOINT - OTEL_TRACES_EXPORTER - OTEL_METRICS_EXPORTER - OTEL_TRACES_SAMPLER_ARG</p> <p>Returns:</p> Type Description <code>TelemetryConfig</code> <p>Configured TelemetryConfig instance</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; \"TelemetryConfig\":\n    \"\"\"Create configuration from environment variables.\n\n    Supports standard OpenTelemetry environment variables:\n    - OTEL_SERVICE_NAME\n    - OTEL_EXPORTER_OTLP_ENDPOINT\n    - OTEL_TRACES_EXPORTER\n    - OTEL_METRICS_EXPORTER\n    - OTEL_TRACES_SAMPLER_ARG\n\n    Returns:\n        Configured TelemetryConfig instance\n    \"\"\"\n    config = cls()\n\n    # Service configuration\n    if service_name := os.getenv(\"OTEL_SERVICE_NAME\"):\n        config.resource.service_name = service_name\n\n    if service_version := os.getenv(\"OTEL_SERVICE_VERSION\"):\n        config.resource.service_version = service_version\n\n    # Endpoint configuration\n    if endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_ENDPOINT\"):\n        config.trace_exporter.endpoint = endpoint\n        config.metric_exporter.endpoint = endpoint\n\n    # Trace-specific endpoint\n    if trace_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_TRACES_ENDPOINT\"):\n        config.trace_exporter.endpoint = trace_endpoint\n\n    # Metric-specific endpoint\n    if metric_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\"):\n        config.metric_exporter.endpoint = metric_endpoint\n\n    # Headers\n    if headers := os.getenv(\"OTEL_EXPORTER_OTLP_HEADERS\"):\n        parsed_headers = {}\n        for header in headers.split(\",\"):\n            if \"=\" in header:\n                key, value = header.split(\"=\", 1)\n                parsed_headers[key.strip()] = value.strip()\n        config.trace_exporter.headers = parsed_headers\n        config.metric_exporter.headers = parsed_headers\n\n    # Sampling\n    if sample_rate := os.getenv(\"OTEL_TRACES_SAMPLER_ARG\"):\n        try:\n            config.sampling.sample_rate = float(sample_rate)\n        except ValueError:\n            pass\n\n    # Exporters\n    if traces_exporter := os.getenv(\"OTEL_TRACES_EXPORTER\"):\n        if traces_exporter == \"none\":\n            config.export_traces = False\n        elif traces_exporter in ExportFormat.__members__.values():\n            config.trace_exporter.format = ExportFormat(traces_exporter)\n\n    if metrics_exporter := os.getenv(\"OTEL_METRICS_EXPORTER\"):\n        if metrics_exporter == \"none\":\n            config.export_metrics = False\n        elif metrics_exporter in ExportFormat.__members__.values():\n            config.metric_exporter.format = ExportFormat(metrics_exporter)\n\n    return config\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TelemetryConfig.to_env_dict","title":"<code>to_env_dict()</code>","text":"<p>Convert configuration to environment variables.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary of environment variables</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def to_env_dict(self) -&gt; Dict[str, str]:\n    \"\"\"Convert configuration to environment variables.\n\n    Returns:\n        Dictionary of environment variables\n    \"\"\"\n    env_vars = {\n        \"OTEL_SERVICE_NAME\": self.resource.service_name,\n        \"OTEL_SERVICE_VERSION\": self.resource.service_version,\n        \"OTEL_TRACES_SAMPLER_ARG\": str(self.sampling.sample_rate),\n    }\n\n    if self.trace_exporter.endpoint:\n        env_vars[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = self.trace_exporter.endpoint\n\n    if self.trace_exporter.headers:\n        headers_str = \",\".join(\n            f\"{k}={v}\" for k, v in self.trace_exporter.headers.items()\n        )\n        env_vars[\"OTEL_EXPORTER_OTLP_HEADERS\"] = headers_str\n\n    if not self.export_traces:\n        env_vars[\"OTEL_TRACES_EXPORTER\"] = \"none\"\n    else:\n        env_vars[\"OTEL_TRACES_EXPORTER\"] = self.trace_exporter.format.value\n\n    if not self.export_metrics:\n        env_vars[\"OTEL_METRICS_EXPORTER\"] = \"none\"\n    else:\n        env_vars[\"OTEL_METRICS_EXPORTER\"] = self.metric_exporter.format.value\n\n    return env_vars\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.ExportFormat","title":"<code>ExportFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported telemetry export formats.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ExportFormat(str, Enum):\n    \"\"\"Supported telemetry export formats.\"\"\"\n    OTLP = \"otlp\"\n    JAEGER = \"jaeger\"\n    ZIPKIN = \"zipkin\"\n    CONSOLE = \"console\"\n    NONE = \"none\"\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TelemetryEnvironment","title":"<code>TelemetryEnvironment</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Deployment environment for telemetry.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class TelemetryEnvironment(str, Enum):\n    \"\"\"Deployment environment for telemetry.\"\"\"\n    DEVELOPMENT = \"development\"\n    STAGING = \"staging\"\n    PRODUCTION = \"production\"\n    TEST = \"test\"\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.ExporterConfig","title":"<code>ExporterConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for telemetry exporters.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ExporterConfig(BaseModel):\n    \"\"\"Configuration for telemetry exporters.\"\"\"\n\n    format: ExportFormat = Field(\n        default=ExportFormat.OTLP,\n        description=\"Export format to use\"\n    )\n    endpoint: Optional[str] = Field(\n        default=None,\n        description=\"Endpoint for exporter\"\n    )\n    headers: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Headers to include with exports\"\n    )\n    timeout_ms: int = Field(\n        default=30000,\n        description=\"Export timeout in milliseconds\"\n    )\n    insecure: bool = Field(\n        default=True,\n        description=\"Whether to use insecure connection\"\n    )\n\n    @model_validator(mode='after')\n    def set_endpoint_defaults(self):\n        \"\"\"Set endpoint defaults based on format.\"\"\"\n        if self.endpoint is None and self.format != ExportFormat.CONSOLE:\n            format_map = {\n                ExportFormat.OTLP: \"http://localhost:4317\",\n                ExportFormat.JAEGER: \"http://localhost:14250\",\n                ExportFormat.ZIPKIN: \"http://localhost:9411/api/v2/spans\"\n            }\n            self.endpoint = format_map.get(self.format)\n        return self\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.ExporterConfig.set_endpoint_defaults","title":"<code>set_endpoint_defaults()</code>","text":"<p>Set endpoint defaults based on format.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>@model_validator(mode='after')\ndef set_endpoint_defaults(self):\n    \"\"\"Set endpoint defaults based on format.\"\"\"\n    if self.endpoint is None and self.format != ExportFormat.CONSOLE:\n        format_map = {\n            ExportFormat.OTLP: \"http://localhost:4317\",\n            ExportFormat.JAEGER: \"http://localhost:14250\",\n            ExportFormat.ZIPKIN: \"http://localhost:9411/api/v2/spans\"\n        }\n        self.endpoint = format_map.get(self.format)\n    return self\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Resource attributes for telemetry.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ResourceConfig(BaseModel):\n    \"\"\"Resource attributes for telemetry.\"\"\"\n\n    service_name: str = Field(\n        default=\"agenticraft\",\n        description=\"Name of the service\"\n    )\n    service_version: str = Field(\n        default=\"unknown\",\n        description=\"Version of the service\"\n    )\n    service_instance_id: Optional[str] = Field(\n        default=None,\n        description=\"Unique instance identifier\"\n    )\n    environment: TelemetryEnvironment = Field(\n        default=TelemetryEnvironment.DEVELOPMENT,\n        description=\"Deployment environment\"\n    )\n    attributes: Dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Additional resource attributes\"\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.SamplingConfig","title":"<code>SamplingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Sampling configuration for traces.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class SamplingConfig(BaseModel):\n    \"\"\"Sampling configuration for traces.\"\"\"\n\n    sample_rate: float = Field(\n        default=1.0,\n        ge=0.0,\n        le=1.0,\n        description=\"Base sampling rate (0.0-1.0)\"\n    )\n    parent_based: bool = Field(\n        default=True,\n        description=\"Honor parent span sampling decision\"\n    )\n    rules: List[Dict[str, Any]] = Field(\n        default_factory=list,\n        description=\"Custom sampling rules\"\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.InstrumentationConfig","title":"<code>InstrumentationConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for automatic instrumentation.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class InstrumentationConfig(BaseModel):\n    \"\"\"Configuration for automatic instrumentation.\"\"\"\n\n    instrument_http: bool = Field(\n        default=True,\n        description=\"Instrument HTTP requests\"\n    )\n    instrument_grpc: bool = Field(\n        default=True,\n        description=\"Instrument gRPC calls\"\n    )\n    instrument_redis: bool = Field(\n        default=False,\n        description=\"Instrument Redis operations\"\n    )\n    instrument_sqlalchemy: bool = Field(\n        default=False,\n        description=\"Instrument database queries\"\n    )\n    excluded_urls: List[str] = Field(\n        default_factory=lambda: [\"/health\", \"/metrics\"],\n        description=\"URLs to exclude from tracing\"\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TracerManager","title":"<code>TracerManager</code>","text":"<p>Manages OpenTelemetry tracer setup and configuration.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>class TracerManager:\n    \"\"\"Manages OpenTelemetry tracer setup and configuration.\"\"\"\n\n    def __init__(self, config: TelemetryConfig):\n        \"\"\"Initialize tracer manager.\n\n        Args:\n            config: Telemetry configuration\n        \"\"\"\n        self.config = config\n        self._tracer_provider: Optional[TracerProvider] = None\n        self._instrumentors: List[Any] = []\n\n    def setup(self) -&gt; None:\n        \"\"\"Set up the tracer with configured exporters and processors.\"\"\"\n        if not self.config.enabled or not self.config.export_traces:\n            logger.info(\"Tracing is disabled\")\n            return\n\n        # Create resource\n        resource = self._create_resource()\n\n        # Create sampler\n        sampler = self._create_sampler()\n\n        # Create tracer provider\n        self._tracer_provider = TracerProvider(\n            resource=resource,\n            sampler=sampler\n        )\n\n        # Add span processors\n        processors = self._create_span_processors()\n        for processor in processors:\n            self._tracer_provider.add_span_processor(processor)\n\n        # Set as global tracer provider\n        trace.set_tracer_provider(self._tracer_provider)\n\n        # Set up instrumentation\n        self._setup_instrumentation()\n\n        logger.info(\n            f\"Tracing initialized with {self.config.trace_exporter.format} exporter\"\n        )\n\n    def _create_resource(self) -&gt; Resource:\n        \"\"\"Create OpenTelemetry resource from config.\"\"\"\n        attributes = {\n            \"service.name\": self.config.resource.service_name,\n            \"service.version\": self.config.resource.service_version,\n            \"deployment.environment\": self.config.resource.environment.value,\n        }\n\n        if self.config.resource.service_instance_id:\n            attributes[\"service.instance.id\"] = self.config.resource.service_instance_id\n\n        # Add custom attributes\n        attributes.update(self.config.resource.attributes)\n\n        return Resource.create(attributes)\n\n    def _create_sampler(self) -&gt; Sampler:\n        \"\"\"Create sampler from configuration.\"\"\"\n        base_sampler = TraceIdRatioBased(self.config.sampling.sample_rate)\n\n        if self.config.sampling.parent_based:\n            return ParentBased(root=base_sampler)\n\n        return base_sampler\n\n    def _create_span_processors(self) -&gt; List[SpanProcessor]:\n        \"\"\"Create span processors based on configuration.\"\"\"\n        processors = []\n\n        exporter = self._create_span_exporter()\n        if exporter:\n            if self.config.trace_exporter.format == ExportFormat.CONSOLE:\n                # Use simple processor for console output\n                processors.append(SimpleSpanProcessor(exporter))\n            else:\n                # Use batch processor for network exporters\n                processors.append(BatchSpanProcessor(\n                    exporter,\n                    max_queue_size=2048,\n                    max_export_batch_size=512,\n                    export_timeout_millis=self.config.trace_exporter.timeout_ms\n                ))\n\n        return processors\n\n    def _create_span_exporter(self):\n        \"\"\"Create appropriate span exporter based on format.\"\"\"\n        format_type = self.config.trace_exporter.format\n\n        if format_type == ExportFormat.NONE:\n            return None\n\n        if format_type == ExportFormat.CONSOLE:\n            return ConsoleSpanExporter()\n\n        if format_type == ExportFormat.OTLP:\n            if OTLPSpanExporter is None:\n                logger.warning(\"OTLP exporter not available. Install opentelemetry-exporter-otlp\")\n                return ConsoleSpanExporter()\n            return OTLPSpanExporter(\n                endpoint=self.config.trace_exporter.endpoint,\n                headers=self.config.trace_exporter.headers,\n                insecure=self.config.trace_exporter.insecure\n            )\n\n        if format_type == ExportFormat.JAEGER:\n            if JaegerExporter is None:\n                logger.warning(\"Jaeger exporter not available. Install opentelemetry-exporter-jaeger\")\n                return ConsoleSpanExporter()\n            # Parse Jaeger endpoint\n            if self.config.trace_exporter.endpoint:\n                parts = self.config.trace_exporter.endpoint.split(\":\")\n                agent_host = parts[0] if parts else \"localhost\"\n                agent_port = int(parts[1]) if len(parts) &gt; 1 else 6831\n            else:\n                agent_host = \"localhost\"\n                agent_port = 6831\n\n            return JaegerExporter(\n                agent_host_name=agent_host,\n                agent_port=agent_port,\n                udp_split_oversized_batches=True\n            )\n\n        if format_type == ExportFormat.ZIPKIN:\n            if ZipkinExporter is None:\n                logger.warning(\"Zipkin exporter not available. Install opentelemetry-exporter-zipkin\")\n                return ConsoleSpanExporter()\n            return ZipkinExporter(\n                endpoint=self.config.trace_exporter.endpoint\n            )\n\n        raise ValueError(f\"Unsupported trace exporter format: {format_type}\")\n\n    def _setup_instrumentation(self) -&gt; None:\n        \"\"\"Set up automatic instrumentation based on config.\"\"\"\n        instrumentation = self.config.instrumentation\n\n        if instrumentation.instrument_http:\n            if HTTPXClientInstrumentor is None:\n                logger.warning(\"HTTPX instrumentation not available\")\n            else:\n                instrumentor = HTTPXClientInstrumentor()\n                instrumentor.instrument(\n                    tracer_provider=self._tracer_provider,\n                    excluded_urls=instrumentation.excluded_urls\n                )\n                self._instrumentors.append(instrumentor)\n\n        if instrumentation.instrument_grpc:\n            if GrpcInstrumentorClient is None or GrpcInstrumentorServer is None:\n                logger.warning(\"gRPC instrumentation not available\")\n            else:\n                # Client instrumentation\n                client_instrumentor = GrpcInstrumentorClient()\n                client_instrumentor.instrument(tracer_provider=self._tracer_provider)\n                self._instrumentors.append(client_instrumentor)\n\n                # Server instrumentation\n                server_instrumentor = GrpcInstrumentorServer()\n                server_instrumentor.instrument(tracer_provider=self._tracer_provider)\n                self._instrumentors.append(server_instrumentor)\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown tracer and exporters.\"\"\"\n        # Uninstrument all instrumentors\n        for instrumentor in self._instrumentors:\n            try:\n                instrumentor.uninstrument()\n            except Exception as e:\n                logger.warning(f\"Failed to uninstrument: {e}\")\n\n        # Shutdown tracer provider\n        if self._tracer_provider:\n            self._tracer_provider.shutdown()\n\n        logger.info(\"Tracing shutdown complete\")\n\n    def get_tracer(self, name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n        \"\"\"Get a tracer instance.\n\n        Args:\n            name: Name of the tracer (usually __name__)\n            version: Optional version string\n\n        Returns:\n            Tracer instance\n        \"\"\"\n        if self._tracer_provider:\n            return self._tracer_provider.get_tracer(name, version)\n        return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TracerManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize tracer manager.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>TelemetryConfig</code> <p>Telemetry configuration</p> required Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def __init__(self, config: TelemetryConfig):\n    \"\"\"Initialize tracer manager.\n\n    Args:\n        config: Telemetry configuration\n    \"\"\"\n    self.config = config\n    self._tracer_provider: Optional[TracerProvider] = None\n    self._instrumentors: List[Any] = []\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TracerManager.setup","title":"<code>setup()</code>","text":"<p>Set up the tracer with configured exporters and processors.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Set up the tracer with configured exporters and processors.\"\"\"\n    if not self.config.enabled or not self.config.export_traces:\n        logger.info(\"Tracing is disabled\")\n        return\n\n    # Create resource\n    resource = self._create_resource()\n\n    # Create sampler\n    sampler = self._create_sampler()\n\n    # Create tracer provider\n    self._tracer_provider = TracerProvider(\n        resource=resource,\n        sampler=sampler\n    )\n\n    # Add span processors\n    processors = self._create_span_processors()\n    for processor in processors:\n        self._tracer_provider.add_span_processor(processor)\n\n    # Set as global tracer provider\n    trace.set_tracer_provider(self._tracer_provider)\n\n    # Set up instrumentation\n    self._setup_instrumentation()\n\n    logger.info(\n        f\"Tracing initialized with {self.config.trace_exporter.format} exporter\"\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TracerManager.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown tracer and exporters.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown tracer and exporters.\"\"\"\n    # Uninstrument all instrumentors\n    for instrumentor in self._instrumentors:\n        try:\n            instrumentor.uninstrument()\n        except Exception as e:\n            logger.warning(f\"Failed to uninstrument: {e}\")\n\n    # Shutdown tracer provider\n    if self._tracer_provider:\n        self._tracer_provider.shutdown()\n\n    logger.info(\"Tracing shutdown complete\")\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.TracerManager.get_tracer","title":"<code>get_tracer(name, version=None)</code>","text":"<p>Get a tracer instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tracer (usually name)</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version string</p> <code>None</code> <p>Returns:</p> Type Description <code>Tracer</code> <p>Tracer instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_tracer(self, name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n    \"\"\"Get a tracer instance.\n\n    Args:\n        name: Name of the tracer (usually __name__)\n        version: Optional version string\n\n    Returns:\n        Tracer instance\n    \"\"\"\n    if self._tracer_provider:\n        return self._tracer_provider.get_tracer(name, version)\n    return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry","title":"<code>Telemetry</code>","text":"<p>Telemetry manager for AgentiCraft.</p> <p>Provides OpenTelemetry integration for distributed tracing and metrics collection.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> <code>'agenticraft'</code> <code>service_version</code> <code>str</code> <p>Version of your service</p> <code>'0.1.0'</code> <code>export_to</code> <code>Optional[str]</code> <p>OTLP endpoint to export telemetry</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether telemetry is enabled</p> <code>True</code> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>class Telemetry:\n    \"\"\"Telemetry manager for AgentiCraft.\n\n    Provides OpenTelemetry integration for distributed tracing\n    and metrics collection.\n\n    Args:\n        service_name: Name of your service\n        service_version: Version of your service\n        export_to: OTLP endpoint to export telemetry\n        enabled: Whether telemetry is enabled\n    \"\"\"\n\n    def __init__(\n        self,\n        service_name: str = \"agenticraft\",\n        service_version: str = \"0.1.0\", \n        export_to: Optional[str] = None,\n        enabled: bool = True\n    ):\n        \"\"\"Initialize telemetry.\"\"\"\n        self.config = TelemetryConfig(\n            service_name=service_name,\n            service_version=service_version,\n            export_endpoint=export_to,\n            enabled=enabled\n        )\n\n        self._tracer: Optional[trace.Tracer] = None\n        self._meter: Optional[metrics.Meter] = None\n\n        if self.config.enabled:\n            self._setup_telemetry()\n\n    def _setup_telemetry(self) -&gt; None:\n        \"\"\"Set up OpenTelemetry providers.\"\"\"\n        # Create resource\n        resource = Resource.create({\n            \"service.name\": self.config.service_name,\n            \"service.version\": self.config.service_version,\n        })\n\n        # Set up tracing\n        trace_provider = TracerProvider(resource=resource)\n\n        if self.config.export_endpoint:\n            span_exporter = OTLPSpanExporter(\n                endpoint=self.config.endpoint,\n                headers=self.config.export_headers\n            )\n            span_processor = BatchSpanProcessor(span_exporter)\n            trace_provider.add_span_processor(span_processor)\n\n        trace.set_tracer_provider(trace_provider)\n        self._tracer = trace.get_tracer(\n            self.config.service_name,\n            self.config.service_version\n        )\n\n        # Set up metrics\n        if self.config.export_endpoint:\n            metric_exporter = OTLPMetricExporter(\n                endpoint=self.config.endpoint,\n                headers=self.config.export_headers\n            )\n            metric_reader = PeriodicExportingMetricReader(\n                exporter=metric_exporter,\n                export_interval_millis=60000  # 1 minute\n            )\n            meter_provider = MeterProvider(\n                resource=resource,\n                metric_readers=[metric_reader]\n            )\n        else:\n            meter_provider = MeterProvider(resource=resource)\n\n        metrics.set_meter_provider(meter_provider)\n        self._meter = metrics.get_meter(\n            self.config.service_name,\n            self.config.service_version\n        )\n\n        # Create common metrics\n        self._setup_metrics()\n\n    def _setup_metrics(self) -&gt; None:\n        \"\"\"Set up common metrics.\"\"\"\n        if not self._meter:\n            return\n\n        # Agent metrics\n        self.agent_runs = self._meter.create_counter(\n            \"agenticraft.agent.runs\",\n            description=\"Number of agent runs\"\n        )\n\n        self.agent_errors = self._meter.create_counter(\n            \"agenticraft.agent.errors\",\n            description=\"Number of agent errors\"\n        )\n\n        self.agent_duration = self._meter.create_histogram(\n            \"agenticraft.agent.duration\",\n            description=\"Agent execution duration in seconds\",\n            unit=\"s\"\n        )\n\n        # Tool metrics\n        self.tool_executions = self._meter.create_counter(\n            \"agenticraft.tool.executions\",\n            description=\"Number of tool executions\"\n        )\n\n        self.tool_errors = self._meter.create_counter(\n            \"agenticraft.tool.errors\",\n            description=\"Number of tool errors\"\n        )\n\n        self.tool_duration = self._meter.create_histogram(\n            \"agenticraft.tool.duration\",\n            description=\"Tool execution duration in seconds\",\n            unit=\"s\"\n        )\n\n        # Token metrics\n        self.tokens_used = self._meter.create_counter(\n            \"agenticraft.tokens.used\",\n            description=\"Number of tokens used\"\n        )\n\n    @property\n    def tracer(self) -&gt; Optional[trace.Tracer]:\n        \"\"\"Get the tracer instance.\"\"\"\n        return self._tracer\n\n    @property\n    def meter(self) -&gt; Optional[metrics.Meter]:\n        \"\"\"Get the meter instance.\"\"\"\n        return self._meter\n\n    @contextmanager\n    def span(self, name: str, attributes: Optional[Dict[str, Any]] = None):\n        \"\"\"Create a traced span.\n\n        Args:\n            name: Span name\n            attributes: Span attributes\n\n        Example:\n            with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):\n                # Do work\n                pass\n        \"\"\"\n        if not self._tracer or not self.config.enabled:\n            yield None\n            return\n\n        with self._tracer.start_as_current_span(name) as span:\n            if attributes:\n                for key, value in attributes.items():\n                    span.set_attribute(key, value)\n            yield span\n\n    def record_agent_run(\n        self,\n        agent_name: str,\n        duration: float,\n        success: bool,\n        tokens: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Record metrics for an agent run.\n\n        Args:\n            agent_name: Name of the agent\n            duration: Execution duration in seconds\n            success: Whether the run was successful\n            tokens: Number of tokens used\n        \"\"\"\n        if not self._meter or not self.config.enabled:\n            return\n\n        attributes = {\"agent.name\": agent_name}\n\n        self.agent_runs.add(1, attributes)\n\n        if not success:\n            self.agent_errors.add(1, attributes)\n\n        self.agent_duration.record(duration, attributes)\n\n        if tokens is not None:\n            self.tokens_used.add(tokens, attributes)\n\n    def record_tool_execution(\n        self,\n        tool_name: str,\n        duration: float,\n        success: bool\n    ) -&gt; None:\n        \"\"\"Record metrics for a tool execution.\n\n        Args:\n            tool_name: Name of the tool\n            duration: Execution duration in seconds\n            success: Whether execution was successful\n        \"\"\"\n        if not self._meter or not self.config.enabled:\n            return\n\n        attributes = {\"tool.name\": tool_name}\n\n        self.tool_executions.add(1, attributes)\n\n        if not success:\n            self.tool_errors.add(1, attributes)\n\n        self.tool_duration.record(duration, attributes)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.tracer","title":"<code>tracer</code>  <code>property</code>","text":"<p>Get the tracer instance.</p>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.meter","title":"<code>meter</code>  <code>property</code>","text":"<p>Get the meter instance.</p>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.__init__","title":"<code>__init__(service_name='agenticraft', service_version='0.1.0', export_to=None, enabled=True)</code>","text":"<p>Initialize telemetry.</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def __init__(\n    self,\n    service_name: str = \"agenticraft\",\n    service_version: str = \"0.1.0\", \n    export_to: Optional[str] = None,\n    enabled: bool = True\n):\n    \"\"\"Initialize telemetry.\"\"\"\n    self.config = TelemetryConfig(\n        service_name=service_name,\n        service_version=service_version,\n        export_endpoint=export_to,\n        enabled=enabled\n    )\n\n    self._tracer: Optional[trace.Tracer] = None\n    self._meter: Optional[metrics.Meter] = None\n\n    if self.config.enabled:\n        self._setup_telemetry()\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.span","title":"<code>span(name, attributes=None)</code>","text":"<p>Create a traced span.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Span name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Span attributes</p> <code>None</code> Example <p>with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):     # Do work     pass</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>@contextmanager\ndef span(self, name: str, attributes: Optional[Dict[str, Any]] = None):\n    \"\"\"Create a traced span.\n\n    Args:\n        name: Span name\n        attributes: Span attributes\n\n    Example:\n        with telemetry.span(\"agent.run\", {\"agent.name\": \"Assistant\"}):\n            # Do work\n            pass\n    \"\"\"\n    if not self._tracer or not self.config.enabled:\n        yield None\n        return\n\n    with self._tracer.start_as_current_span(name) as span:\n        if attributes:\n            for key, value in attributes.items():\n                span.set_attribute(key, value)\n        yield span\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.record_agent_run","title":"<code>record_agent_run(agent_name, duration, success, tokens=None)</code>","text":"<p>Record metrics for an agent run.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Name of the agent</p> required <code>duration</code> <code>float</code> <p>Execution duration in seconds</p> required <code>success</code> <code>bool</code> <p>Whether the run was successful</p> required <code>tokens</code> <code>Optional[int]</code> <p>Number of tokens used</p> <code>None</code> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def record_agent_run(\n    self,\n    agent_name: str,\n    duration: float,\n    success: bool,\n    tokens: Optional[int] = None\n) -&gt; None:\n    \"\"\"Record metrics for an agent run.\n\n    Args:\n        agent_name: Name of the agent\n        duration: Execution duration in seconds\n        success: Whether the run was successful\n        tokens: Number of tokens used\n    \"\"\"\n    if not self._meter or not self.config.enabled:\n        return\n\n    attributes = {\"agent.name\": agent_name}\n\n    self.agent_runs.add(1, attributes)\n\n    if not success:\n        self.agent_errors.add(1, attributes)\n\n    self.agent_duration.record(duration, attributes)\n\n    if tokens is not None:\n        self.tokens_used.add(tokens, attributes)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.Telemetry.record_tool_execution","title":"<code>record_tool_execution(tool_name, duration, success)</code>","text":"<p>Record metrics for a tool execution.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool</p> required <code>duration</code> <code>float</code> <p>Execution duration in seconds</p> required <code>success</code> <code>bool</code> <p>Whether execution was successful</p> required Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def record_tool_execution(\n    self,\n    tool_name: str,\n    duration: float,\n    success: bool\n) -&gt; None:\n    \"\"\"Record metrics for a tool execution.\n\n    Args:\n        tool_name: Name of the tool\n        duration: Execution duration in seconds\n        success: Whether execution was successful\n    \"\"\"\n    if not self._meter or not self.config.enabled:\n        return\n\n    attributes = {\"tool.name\": tool_name}\n\n    self.tool_executions.add(1, attributes)\n\n    if not success:\n        self.tool_errors.add(1, attributes)\n\n    self.tool_duration.record(duration, attributes)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.development_config","title":"<code>development_config()</code>","text":"<p>Get development environment configuration.</p> <ul> <li>Console exporter for easy debugging</li> <li>Full sampling</li> <li>All instrumentation enabled</li> </ul> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def development_config() -&gt; TelemetryConfig:\n    \"\"\"Get development environment configuration.\n\n    - Console exporter for easy debugging\n    - Full sampling\n    - All instrumentation enabled\n    \"\"\"\n    return TelemetryConfig(\n        resource=ResourceConfig(\n            environment=TelemetryEnvironment.DEVELOPMENT\n        ),\n        trace_exporter=ExporterConfig(\n            format=ExportFormat.CONSOLE\n        ),\n        metric_exporter=ExporterConfig(\n            format=ExportFormat.CONSOLE\n        ),\n        sampling=SamplingConfig(\n            sample_rate=1.0\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.production_config","title":"<code>production_config(service_name, otlp_endpoint, sample_rate=0.1)</code>","text":"<p>Get production environment configuration.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> required <code>otlp_endpoint</code> <code>str</code> <p>OTLP collector endpoint</p> required <code>sample_rate</code> <code>float</code> <p>Sampling rate (default 10%)</p> <code>0.1</code> <p>Returns:</p> Type Description <code>TelemetryConfig</code> <p>Production-ready configuration</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def production_config(\n    service_name: str,\n    otlp_endpoint: str,\n    sample_rate: float = 0.1\n) -&gt; TelemetryConfig:\n    \"\"\"Get production environment configuration.\n\n    Args:\n        service_name: Name of your service\n        otlp_endpoint: OTLP collector endpoint\n        sample_rate: Sampling rate (default 10%)\n\n    Returns:\n        Production-ready configuration\n    \"\"\"\n    return TelemetryConfig(\n        resource=ResourceConfig(\n            service_name=service_name,\n            environment=TelemetryEnvironment.PRODUCTION\n        ),\n        trace_exporter=ExporterConfig(\n            format=ExportFormat.OTLP,\n            endpoint=otlp_endpoint,\n            insecure=False\n        ),\n        metric_exporter=ExporterConfig(\n            format=ExportFormat.OTLP,\n            endpoint=otlp_endpoint,\n            insecure=False\n        ),\n        sampling=SamplingConfig(\n            sample_rate=sample_rate\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.test_config","title":"<code>test_config()</code>","text":"<p>Get test environment configuration.</p> <ul> <li>Telemetry disabled by default</li> <li>No external dependencies</li> </ul> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def test_config() -&gt; TelemetryConfig:\n    \"\"\"Get test environment configuration.\n\n    - Telemetry disabled by default\n    - No external dependencies\n    \"\"\"\n    return TelemetryConfig(\n        enabled=False,\n        resource=ResourceConfig(\n            environment=TelemetryEnvironment.TEST\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.setup_tracing","title":"<code>setup_tracing(config=None, service_name=None, endpoint=None)</code>","text":"<p>Set up global tracing.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[TelemetryConfig]</code> <p>Full telemetry configuration</p> <code>None</code> <code>service_name</code> <code>Optional[str]</code> <p>Service name (if not using config)</p> <code>None</code> <code>endpoint</code> <code>Optional[str]</code> <p>Exporter endpoint (if not using config)</p> <code>None</code> <p>Returns:</p> Type Description <code>TracerManager</code> <p>TracerManager instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def setup_tracing(\n    config: Optional[TelemetryConfig] = None,\n    service_name: Optional[str] = None,\n    endpoint: Optional[str] = None\n) -&gt; TracerManager:\n    \"\"\"Set up global tracing.\n\n    Args:\n        config: Full telemetry configuration\n        service_name: Service name (if not using config)\n        endpoint: Exporter endpoint (if not using config)\n\n    Returns:\n        TracerManager instance\n    \"\"\"\n    global _tracer_manager\n\n    if config is None:\n        # Create config from environment or parameters\n        config = TelemetryConfig.from_env()\n\n        if service_name:\n            config.resource.service_name = service_name\n\n        if endpoint:\n            config.trace_exporter.endpoint = endpoint\n\n    _tracer_manager = TracerManager(config)\n    _tracer_manager.setup()\n\n    return _tracer_manager\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.get_tracer","title":"<code>get_tracer(name, version=None)</code>","text":"<p>Get a tracer instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tracer (usually name)</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version string</p> <code>None</code> <p>Returns:</p> Type Description <code>Tracer</code> <p>Tracer instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_tracer(name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n    \"\"\"Get a tracer instance.\n\n    Args:\n        name: Name of the tracer (usually __name__)\n        version: Optional version string\n\n    Returns:\n        Tracer instance\n    \"\"\"\n    if _tracer_manager:\n        return _tracer_manager.get_tracer(name, version)\n    return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.shutdown_tracing","title":"<code>shutdown_tracing()</code>","text":"<p>Shutdown global tracing.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def shutdown_tracing() -&gt; None:\n    \"\"\"Shutdown global tracing.\"\"\"\n    global _tracer_manager\n\n    if _tracer_manager:\n        _tracer_manager.shutdown()\n        _tracer_manager = None\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.traced_operation","title":"<code>traced_operation(name, attributes=None, record_exception=True)</code>","text":"<p>Context manager for traced operations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Operation name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Span attributes</p> <code>None</code> <code>record_exception</code> <code>bool</code> <p>Whether to record exceptions</p> <code>True</code> Example <p>with traced_operation(\"database_query\", {\"query.type\": \"select\"}):     result = db.query(\"SELECT * FROM users\")</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>@contextmanager\ndef traced_operation(\n    name: str,\n    attributes: Optional[Dict[str, Any]] = None,\n    record_exception: bool = True\n):\n    \"\"\"Context manager for traced operations.\n\n    Args:\n        name: Operation name\n        attributes: Span attributes\n        record_exception: Whether to record exceptions\n\n    Example:\n        with traced_operation(\"database_query\", {\"query.type\": \"select\"}):\n            result = db.query(\"SELECT * FROM users\")\n    \"\"\"\n    tracer = get_tracer(__name__)\n\n    with tracer.start_as_current_span(name) as span:\n        if attributes:\n            for key, value in attributes.items():\n                span.set_attribute(key, value)\n\n        try:\n            yield span\n        except Exception as e:\n            if record_exception:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n            raise\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.trace_function","title":"<code>trace_function(name=None, attributes=None)</code>","text":"<p>Decorator to trace function execution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Span name (defaults to function name)</p> <code>None</code> <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Additional span attributes</p> <code>None</code> Example <p>@trace_function(attributes={\"handler.type\": \"api\"}) async def handle_request(request):     return {\"status\": \"ok\"}</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def trace_function(\n    name: Optional[str] = None,\n    attributes: Optional[Dict[str, Any]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to trace function execution.\n\n    Args:\n        name: Span name (defaults to function name)\n        attributes: Additional span attributes\n\n    Example:\n        @trace_function(attributes={\"handler.type\": \"api\"})\n        async def handle_request(request):\n            return {\"status\": \"ok\"}\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        span_name = name or f\"{func.__module__}.{func.__name__}\"\n\n        async def async_wrapper(*args, **kwargs):\n            with traced_operation(span_name, attributes):\n                return await func(*args, **kwargs)\n\n        def sync_wrapper(*args, **kwargs):\n            with traced_operation(span_name, attributes):\n                return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.add_event","title":"<code>add_event(name, attributes=None)</code>","text":"<p>Add an event to the current span.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Event attributes</p> <code>None</code> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def add_event(name: str, attributes: Optional[Dict[str, Any]] = None) -&gt; None:\n    \"\"\"Add an event to the current span.\n\n    Args:\n        name: Event name\n        attributes: Event attributes\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        span.add_event(name, attributes or {})\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.set_attribute","title":"<code>set_attribute(key, value)</code>","text":"<p>Set an attribute on the current span.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute key</p> required <code>value</code> <code>Any</code> <p>Attribute value</p> required Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def set_attribute(key: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute on the current span.\n\n    Args:\n        key: Attribute key\n        value: Attribute value\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        span.set_attribute(key, value)\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.get_current_trace_id","title":"<code>get_current_trace_id()</code>","text":"<p>Get the current trace ID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Trace ID as hex string or None</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_current_trace_id() -&gt; Optional[str]:\n    \"\"\"Get the current trace ID if available.\n\n    Returns:\n        Trace ID as hex string or None\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        context = span.get_span_context()\n        if context.trace_id:\n            return format(context.trace_id, \"032x\")\n    return None\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.track_metrics","title":"<code>track_metrics(name=None, labels=None, track_duration=True, track_errors=True, track_calls=True, custom_metrics=None)</code>","text":"<p>Decorator to track metrics for a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Metric name prefix (defaults to function name)</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>List of parameter names to use as metric labels</p> <code>None</code> <code>track_duration</code> <code>bool</code> <p>Whether to track execution duration</p> <code>True</code> <code>track_errors</code> <code>bool</code> <p>Whether to track error count</p> <code>True</code> <code>track_calls</code> <code>bool</code> <p>Whether to track call count</p> <code>True</code> <code>custom_metrics</code> <code>Optional[Dict[str, str]]</code> <p>Additional metrics to track</p> <code>None</code> Example <p>@track_metrics(     labels=[\"agent_name\", \"tool_name\"],     track_duration=True ) async def execute_tool(agent_name: str, tool_name: str, args: dict):     # Metrics will be tracked with agent_name and tool_name labels     return await tool.run(args)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def track_metrics(\n    name: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    track_duration: bool = True,\n    track_errors: bool = True,\n    track_calls: bool = True,\n    custom_metrics: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to track metrics for a function.\n\n    Args:\n        name: Metric name prefix (defaults to function name)\n        labels: List of parameter names to use as metric labels\n        track_duration: Whether to track execution duration\n        track_errors: Whether to track error count\n        track_calls: Whether to track call count\n        custom_metrics: Additional metrics to track\n\n    Example:\n        @track_metrics(\n            labels=[\"agent_name\", \"tool_name\"],\n            track_duration=True\n        )\n        async def execute_tool(agent_name: str, tool_name: str, args: dict):\n            # Metrics will be tracked with agent_name and tool_name labels\n            return await tool.run(args)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        # Determine metric name\n        metric_name = name or f\"{func.__module__}.{func.__name__}\"\n        metric_labels = labels or []\n\n        # Get telemetry instance\n        telemetry = get_global_telemetry()\n\n        # Create metrics if telemetry is available\n        call_counter = None\n        error_counter = None\n        duration_histogram = None\n\n        if telemetry and telemetry.meter:\n            meter = telemetry.meter\n\n            if track_calls:\n                call_counter = meter.create_counter(\n                    f\"{metric_name}.calls\",\n                    description=f\"Number of calls to {func.__name__}\"\n                )\n\n            if track_errors:\n                error_counter = meter.create_counter(\n                    f\"{metric_name}.errors\",\n                    description=f\"Number of errors in {func.__name__}\"\n                )\n\n            if track_duration:\n                duration_histogram = meter.create_histogram(\n                    f\"{metric_name}.duration\",\n                    description=f\"Execution duration of {func.__name__}\",\n                    unit=\"s\"\n                )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            start_time = time.time()\n\n            # Extract label values\n            label_values = _extract_label_values(\n                func, args, kwargs, metric_labels\n            )\n\n            # Track call\n            if call_counter:\n                call_counter.add(1, label_values)\n\n            try:\n                result = await func(*args, **kwargs)\n                return result\n            except Exception as e:\n                # Track error\n                if error_counter:\n                    error_label_values = {**label_values, \"error_type\": type(e).__name__}\n                    error_counter.add(1, error_label_values)\n                raise\n            finally:\n                # Track duration\n                if duration_histogram:\n                    duration = time.time() - start_time\n                    duration_histogram.record(duration, label_values)\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            start_time = time.time()\n\n            # Extract label values\n            label_values = _extract_label_values(\n                func, args, kwargs, metric_labels\n            )\n\n            # Track call\n            if call_counter:\n                call_counter.add(1, label_values)\n\n            try:\n                result = func(*args, **kwargs)\n                return result\n            except Exception as e:\n                # Track error\n                if error_counter:\n                    error_label_values = {**label_values, \"error_type\": type(e).__name__}\n                    error_counter.add(1, error_label_values)\n                raise\n            finally:\n                # Track duration\n                if duration_histogram:\n                    duration = time.time() - start_time\n                    duration_histogram.record(duration, label_values)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.trace","title":"<code>trace(name=None, attributes=None, kind=SpanKind.INTERNAL, record_exception=True, set_status_on_exception=True)</code>","text":"<p>Decorator to add tracing to a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Span name (defaults to function name)</p> <code>None</code> <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Static span attributes</p> <code>None</code> <code>kind</code> <code>SpanKind</code> <p>Span kind (INTERNAL, SERVER, CLIENT, etc.)</p> <code>INTERNAL</code> <code>record_exception</code> <code>bool</code> <p>Whether to record exceptions</p> <code>True</code> <code>set_status_on_exception</code> <code>bool</code> <p>Whether to set error status on exception</p> <code>True</code> Example <p>@trace(     attributes={\"component\": \"agent\"},     kind=trace.SpanKind.SERVER ) async def handle_agent_request(request):     return await process(request)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace(\n    name: Optional[str] = None,\n    attributes: Optional[Dict[str, Any]] = None,\n    kind: SpanKind = SpanKind.INTERNAL,\n    record_exception: bool = True,\n    set_status_on_exception: bool = True\n) -&gt; Callable:\n    \"\"\"Decorator to add tracing to a function.\n\n    Args:\n        name: Span name (defaults to function name)\n        attributes: Static span attributes\n        kind: Span kind (INTERNAL, SERVER, CLIENT, etc.)\n        record_exception: Whether to record exceptions\n        set_status_on_exception: Whether to set error status on exception\n\n    Example:\n        @trace(\n            attributes={\"component\": \"agent\"},\n            kind=trace.SpanKind.SERVER\n        )\n        async def handle_agent_request(request):\n            return await process(request)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        span_name = name or f\"{func.__module__}.{func.__name__}\"\n        tracer = get_tracer(func.__module__)\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            with tracer.start_as_current_span(\n                span_name,\n                kind=kind,\n                attributes=attributes\n            ) as span:\n                try:\n                    # Add dynamic attributes from function parameters\n                    _add_span_attributes_from_params(span, func, args, kwargs)\n\n                    result = await func(*args, **kwargs)\n                    return result\n                except Exception as e:\n                    if record_exception:\n                        span.record_exception(e)\n                    if set_status_on_exception:\n                        span.set_status(Status(StatusCode.ERROR, str(e)))\n                    raise\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            with tracer.start_as_current_span(\n                span_name,\n                kind=kind,\n                attributes=attributes\n            ) as span:\n                try:\n                    # Add dynamic attributes from function parameters\n                    _add_span_attributes_from_params(span, func, args, kwargs)\n\n                    result = func(*args, **kwargs)\n                    return result\n                except Exception as e:\n                    if record_exception:\n                        span.record_exception(e)\n                    if set_status_on_exception:\n                        span.set_status(Status(StatusCode.ERROR, str(e)))\n                    raise\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.measure_time","title":"<code>measure_time(metric_name, labels=None)</code>","text":"<p>Simple decorator to measure execution time.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the duration metric</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@measure_time(\"database.query.duration\", {\"db\": \"postgres\"}) def query_database(sql: str):     return db.execute(sql)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def measure_time(\n    metric_name: str,\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Simple decorator to measure execution time.\n\n    Args:\n        metric_name: Name for the duration metric\n        labels: Static labels for the metric\n\n    Example:\n        @measure_time(\"database.query.duration\", {\"db\": \"postgres\"})\n        def query_database(sql: str):\n            return db.execute(sql)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create histogram metric\n        histogram = None\n        if telemetry and telemetry.meter:\n            histogram = telemetry.meter.create_histogram(\n                metric_name,\n                description=f\"Duration of {func.__name__}\",\n                unit=\"s\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            start = time.time()\n            try:\n                return await func(*args, **kwargs)\n            finally:\n                if histogram:\n                    duration = time.time() - start\n                    histogram.record(duration, labels or {})\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            start = time.time()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                if histogram:\n                    duration = time.time() - start\n                    histogram.record(duration, labels or {})\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.count_calls","title":"<code>count_calls(metric_name, labels=None)</code>","text":"<p>Decorator to count function calls.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the counter metric</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@count_calls(\"api.requests\", {\"version\": \"v1\"}) async def handle_api_request(request):     return process(request)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def count_calls(\n    metric_name: str,\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to count function calls.\n\n    Args:\n        metric_name: Name for the counter metric\n        labels: Static labels for the metric\n\n    Example:\n        @count_calls(\"api.requests\", {\"version\": \"v1\"})\n        async def handle_api_request(request):\n            return process(request)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create counter metric\n        counter = None\n        if telemetry and telemetry.meter:\n            counter = telemetry.meter.create_counter(\n                metric_name,\n                description=f\"Count of {func.__name__} calls\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            if counter:\n                counter.add(1, labels or {})\n            return await func(*args, **kwargs)\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            if counter:\n                counter.add(1, labels or {})\n            return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.observe_value","title":"<code>observe_value(metric_name, value_func, labels=None)</code>","text":"<p>Decorator to observe a value from function result.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the gauge metric</p> required <code>value_func</code> <code>Callable[..., Union[int, float]]</code> <p>Function to extract value from result</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@observe_value(     \"cache.size\",     value_func=lambda result: len(result),     labels={\"cache\": \"memory\"} ) def get_cache_contents():     return cache.get_all()</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def observe_value(\n    metric_name: str,\n    value_func: Callable[..., Union[int, float]],\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to observe a value from function result.\n\n    Args:\n        metric_name: Name for the gauge metric\n        value_func: Function to extract value from result\n        labels: Static labels for the metric\n\n    Example:\n        @observe_value(\n            \"cache.size\",\n            value_func=lambda result: len(result),\n            labels={\"cache\": \"memory\"}\n        )\n        def get_cache_contents():\n            return cache.get_all()\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create gauge metric\n        gauge = None\n        if telemetry and telemetry.meter:\n            gauge = telemetry.meter.create_gauge(\n                metric_name,\n                description=f\"Value observed from {func.__name__}\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            result = await func(*args, **kwargs)\n            if gauge:\n                try:\n                    value = value_func(result)\n                    gauge.set(value, labels or {})\n                except Exception:\n                    pass  # Don't fail if metric extraction fails\n            return result\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if gauge:\n                try:\n                    value = value_func(result)\n                    gauge.set(value, labels or {})\n                except Exception:\n                    pass  # Don't fail if metric extraction fails\n            return result\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.trace_agent_method","title":"<code>trace_agent_method(method_name=None)</code>","text":"<p>Specialized decorator for agent methods.</p> <p>Automatically adds agent-specific attributes and metrics.</p> Example <p>class MyAgent(Agent):     @trace_agent_method()     async def process(self, input: str) -&gt; str:         return await self._generate_response(input)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace_agent_method(method_name: Optional[str] = None) -&gt; Callable:\n    \"\"\"Specialized decorator for agent methods.\n\n    Automatically adds agent-specific attributes and metrics.\n\n    Example:\n        class MyAgent(Agent):\n            @trace_agent_method()\n            async def process(self, input: str) -&gt; str:\n                return await self._generate_response(input)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        name = method_name or func.__name__\n\n        @trace(\n            name=f\"agent.{name}\",\n            kind=SpanKind.INTERNAL\n        )\n        @track_metrics(\n            name=f\"agenticraft.agent.{name}\",\n            labels=[\"agent_name\"],\n            track_duration=True,\n            track_errors=True\n        )\n        @functools.wraps(func)\n        async def wrapper(self, *args, **kwargs):\n            # Add agent context to current span\n            span = otel_trace.get_current_span()\n            if span and hasattr(self, 'name'):\n                span.set_attribute(\"agent.name\", self.name)\n                span.set_attribute(\"agent.id\", getattr(self, 'id', 'unknown'))\n\n                # Add trace ID to span attributes instead of kwargs\n                trace_id = get_current_trace_id()\n                if trace_id:\n                    span.set_attribute(\"trace.id\", trace_id)\n\n            return await func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.trace_tool_execution","title":"<code>trace_tool_execution(tool_name=None)</code>","text":"<p>Specialized decorator for tool execution.</p> Example <p>@trace_tool_execution(\"web_search\") async def search_web(query: str) -&gt; List[Dict]:     return await search_api.search(query)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace_tool_execution(tool_name: Optional[str] = None) -&gt; Callable:\n    \"\"\"Specialized decorator for tool execution.\n\n    Example:\n        @trace_tool_execution(\"web_search\")\n        async def search_web(query: str) -&gt; List[Dict]:\n            return await search_api.search(query)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        name = tool_name or func.__name__\n\n        @trace(\n            name=f\"tool.{name}\",\n            kind=SpanKind.CLIENT,\n            attributes={\"tool.name\": name}\n        )\n        @track_metrics(\n            name=f\"agenticraft.tool.{name}\",\n            track_duration=True,\n            track_errors=True\n        )\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.set_global_telemetry","title":"<code>set_global_telemetry(telemetry)</code>","text":"<p>Set the global telemetry instance.</p> <p>Parameters:</p> Name Type Description Default <code>telemetry</code> <code>Telemetry</code> <p>Telemetry instance to use globally</p> required Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def set_global_telemetry(telemetry: Telemetry) -&gt; None:\n    \"\"\"Set the global telemetry instance.\n\n    Args:\n        telemetry: Telemetry instance to use globally\n    \"\"\"\n    global _global_telemetry\n    _global_telemetry = telemetry\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.get_global_telemetry","title":"<code>get_global_telemetry()</code>","text":"<p>Get the global telemetry instance.</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def get_global_telemetry() -&gt; Optional[Telemetry]:\n    \"\"\"Get the global telemetry instance.\"\"\"\n    return _global_telemetry\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.init_telemetry","title":"<code>init_telemetry(service_name='agenticraft', export_to=None, enabled=True)</code>","text":"<p>Initialize and set global telemetry.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> <code>'agenticraft'</code> <code>export_to</code> <code>Optional[str]</code> <p>OTLP endpoint</p> <code>None</code> <code>enabled</code> <code>bool</code> <p>Whether telemetry is enabled</p> <code>True</code> <p>Returns:</p> Type Description <code>Telemetry</code> <p>Telemetry instance</p> Source code in <code>agenticraft/core/telemetry.py</code> <pre><code>def init_telemetry(\n    service_name: str = \"agenticraft\",\n    export_to: Optional[str] = None,\n    enabled: bool = True\n) -&gt; Telemetry:\n    \"\"\"Initialize and set global telemetry.\n\n    Args:\n        service_name: Name of your service\n        export_to: OTLP endpoint\n        enabled: Whether telemetry is enabled\n\n    Returns:\n        Telemetry instance\n    \"\"\"\n    telemetry = Telemetry(\n        service_name=service_name,\n        export_to=export_to,\n        enabled=enabled\n    )\n    set_global_telemetry(telemetry)\n    return telemetry\n</code></pre>"},{"location":"reference/telemetry/__init__/#agenticraft.telemetry.setup_telemetry","title":"<code>setup_telemetry(service_name='agenticraft', export_endpoint='http://localhost:4317', environment='development', **kwargs)</code>","text":"<p>Convenience function to set up both telemetry and tracing.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> <code>'agenticraft'</code> <code>export_endpoint</code> <code>str</code> <p>OTLP endpoint for telemetry export</p> <code>'http://localhost:4317'</code> <code>environment</code> <code>str</code> <p>Deployment environment</p> <code>'development'</code> <code>**kwargs</code> <p>Additional configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>Telemetry</code> <p>Configured Telemetry instance</p> Example <p>telemetry = setup_telemetry(     service_name=\"my-agent-service\",     export_endpoint=\"http://jaeger:4317\",     environment=\"production\",     sample_rate=0.1 )</p> Source code in <code>agenticraft/telemetry/__init__.py</code> <pre><code>def setup_telemetry(\n    service_name: str = \"agenticraft\",\n    export_endpoint: str = \"http://localhost:4317\",\n    environment: str = \"development\",\n    **kwargs\n) -&gt; Telemetry:\n    \"\"\"Convenience function to set up both telemetry and tracing.\n\n    Args:\n        service_name: Name of your service\n        export_endpoint: OTLP endpoint for telemetry export\n        environment: Deployment environment\n        **kwargs: Additional configuration options\n\n    Returns:\n        Configured Telemetry instance\n\n    Example:\n        telemetry = setup_telemetry(\n            service_name=\"my-agent-service\",\n            export_endpoint=\"http://jaeger:4317\",\n            environment=\"production\",\n            sample_rate=0.1\n        )\n    \"\"\"\n    # Create config based on environment\n    if environment == \"development\":\n        config = development_config()\n    elif environment == \"production\":\n        config = production_config(\n            service_name=service_name,\n            otlp_endpoint=export_endpoint,\n            sample_rate=kwargs.get(\"sample_rate\", 0.1)\n        )\n    elif environment == \"test\":\n        config = test_config()\n    else:\n        config = TelemetryConfig()\n\n    # Update with provided values\n    config.resource.service_name = service_name\n    if export_endpoint:\n        config.trace_exporter.endpoint = export_endpoint\n        config.metric_exporter.endpoint = export_endpoint\n\n    # Apply any additional kwargs\n    for key, value in kwargs.items():\n        if hasattr(config, key):\n            setattr(config, key, value)\n\n    # Set up tracing\n    setup_tracing(config)\n\n    # Initialize and return telemetry\n    return init_telemetry(\n        service_name=service_name,\n        export_to=export_endpoint,\n        enabled=config.enabled\n    )\n</code></pre>"},{"location":"reference/telemetry/config/","title":"Config","text":""},{"location":"reference/telemetry/config/#agenticraft.telemetry.config","title":"<code>config</code>","text":"<p>Telemetry configuration for AgentiCraft.</p> <p>This module provides configuration management for OpenTelemetry settings, including exporters, sampling, and instrumentation options.</p> Example <p>Basic configuration::</p> <pre><code>from agenticraft.telemetry import TelemetryConfig\n\nconfig = TelemetryConfig(\n    service_name=\"my-agent-service\",\n    export_endpoint=\"http://jaeger:4317\",\n    sample_rate=0.1,  # Sample 10% of traces\n    export_metrics=True,\n    export_traces=True\n)\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.ExportFormat","title":"<code>ExportFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported telemetry export formats.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ExportFormat(str, Enum):\n    \"\"\"Supported telemetry export formats.\"\"\"\n    OTLP = \"otlp\"\n    JAEGER = \"jaeger\"\n    ZIPKIN = \"zipkin\"\n    CONSOLE = \"console\"\n    NONE = \"none\"\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.TelemetryEnvironment","title":"<code>TelemetryEnvironment</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Deployment environment for telemetry.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class TelemetryEnvironment(str, Enum):\n    \"\"\"Deployment environment for telemetry.\"\"\"\n    DEVELOPMENT = \"development\"\n    STAGING = \"staging\"\n    PRODUCTION = \"production\"\n    TEST = \"test\"\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.ExporterConfig","title":"<code>ExporterConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for telemetry exporters.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ExporterConfig(BaseModel):\n    \"\"\"Configuration for telemetry exporters.\"\"\"\n\n    format: ExportFormat = Field(\n        default=ExportFormat.OTLP,\n        description=\"Export format to use\"\n    )\n    endpoint: Optional[str] = Field(\n        default=None,\n        description=\"Endpoint for exporter\"\n    )\n    headers: Dict[str, str] = Field(\n        default_factory=dict,\n        description=\"Headers to include with exports\"\n    )\n    timeout_ms: int = Field(\n        default=30000,\n        description=\"Export timeout in milliseconds\"\n    )\n    insecure: bool = Field(\n        default=True,\n        description=\"Whether to use insecure connection\"\n    )\n\n    @model_validator(mode='after')\n    def set_endpoint_defaults(self):\n        \"\"\"Set endpoint defaults based on format.\"\"\"\n        if self.endpoint is None and self.format != ExportFormat.CONSOLE:\n            format_map = {\n                ExportFormat.OTLP: \"http://localhost:4317\",\n                ExportFormat.JAEGER: \"http://localhost:14250\",\n                ExportFormat.ZIPKIN: \"http://localhost:9411/api/v2/spans\"\n            }\n            self.endpoint = format_map.get(self.format)\n        return self\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.ExporterConfig.set_endpoint_defaults","title":"<code>set_endpoint_defaults()</code>","text":"<p>Set endpoint defaults based on format.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>@model_validator(mode='after')\ndef set_endpoint_defaults(self):\n    \"\"\"Set endpoint defaults based on format.\"\"\"\n    if self.endpoint is None and self.format != ExportFormat.CONSOLE:\n        format_map = {\n            ExportFormat.OTLP: \"http://localhost:4317\",\n            ExportFormat.JAEGER: \"http://localhost:14250\",\n            ExportFormat.ZIPKIN: \"http://localhost:9411/api/v2/spans\"\n        }\n        self.endpoint = format_map.get(self.format)\n    return self\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.ResourceConfig","title":"<code>ResourceConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Resource attributes for telemetry.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class ResourceConfig(BaseModel):\n    \"\"\"Resource attributes for telemetry.\"\"\"\n\n    service_name: str = Field(\n        default=\"agenticraft\",\n        description=\"Name of the service\"\n    )\n    service_version: str = Field(\n        default=\"unknown\",\n        description=\"Version of the service\"\n    )\n    service_instance_id: Optional[str] = Field(\n        default=None,\n        description=\"Unique instance identifier\"\n    )\n    environment: TelemetryEnvironment = Field(\n        default=TelemetryEnvironment.DEVELOPMENT,\n        description=\"Deployment environment\"\n    )\n    attributes: Dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Additional resource attributes\"\n    )\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.SamplingConfig","title":"<code>SamplingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Sampling configuration for traces.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class SamplingConfig(BaseModel):\n    \"\"\"Sampling configuration for traces.\"\"\"\n\n    sample_rate: float = Field(\n        default=1.0,\n        ge=0.0,\n        le=1.0,\n        description=\"Base sampling rate (0.0-1.0)\"\n    )\n    parent_based: bool = Field(\n        default=True,\n        description=\"Honor parent span sampling decision\"\n    )\n    rules: List[Dict[str, Any]] = Field(\n        default_factory=list,\n        description=\"Custom sampling rules\"\n    )\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.InstrumentationConfig","title":"<code>InstrumentationConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for automatic instrumentation.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class InstrumentationConfig(BaseModel):\n    \"\"\"Configuration for automatic instrumentation.\"\"\"\n\n    instrument_http: bool = Field(\n        default=True,\n        description=\"Instrument HTTP requests\"\n    )\n    instrument_grpc: bool = Field(\n        default=True,\n        description=\"Instrument gRPC calls\"\n    )\n    instrument_redis: bool = Field(\n        default=False,\n        description=\"Instrument Redis operations\"\n    )\n    instrument_sqlalchemy: bool = Field(\n        default=False,\n        description=\"Instrument database queries\"\n    )\n    excluded_urls: List[str] = Field(\n        default_factory=lambda: [\"/health\", \"/metrics\"],\n        description=\"URLs to exclude from tracing\"\n    )\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.TelemetryConfig","title":"<code>TelemetryConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete telemetry configuration.</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>class TelemetryConfig(BaseModel):\n    \"\"\"Complete telemetry configuration.\"\"\"\n\n    enabled: bool = Field(\n        default=True,\n        description=\"Whether telemetry is enabled\"\n    )\n\n    # Resource configuration\n    resource: ResourceConfig = Field(\n        default_factory=ResourceConfig,\n        description=\"Resource configuration\"\n    )\n\n    # Tracing configuration\n    export_traces: bool = Field(\n        default=True,\n        description=\"Whether to export traces\"\n    )\n    trace_exporter: ExporterConfig = Field(\n        default_factory=ExporterConfig,\n        description=\"Trace exporter configuration\"\n    )\n    sampling: SamplingConfig = Field(\n        default_factory=SamplingConfig,\n        description=\"Trace sampling configuration\"\n    )\n\n    # Metrics configuration\n    export_metrics: bool = Field(\n        default=True,\n        description=\"Whether to export metrics\"\n    )\n    metric_exporter: ExporterConfig = Field(\n        default_factory=ExporterConfig,\n        description=\"Metric exporter configuration\"\n    )\n    metric_interval_ms: int = Field(\n        default=60000,\n        description=\"Metric export interval in milliseconds\"\n    )\n\n    # Instrumentation\n    instrumentation: InstrumentationConfig = Field(\n        default_factory=InstrumentationConfig,\n        description=\"Automatic instrumentation settings\"\n    )\n\n    # Logging integration\n    log_correlation: bool = Field(\n        default=True,\n        description=\"Add trace IDs to logs\"\n    )\n\n    @classmethod\n    def from_env(cls) -&gt; \"TelemetryConfig\":\n        \"\"\"Create configuration from environment variables.\n\n        Supports standard OpenTelemetry environment variables:\n        - OTEL_SERVICE_NAME\n        - OTEL_EXPORTER_OTLP_ENDPOINT\n        - OTEL_TRACES_EXPORTER\n        - OTEL_METRICS_EXPORTER\n        - OTEL_TRACES_SAMPLER_ARG\n\n        Returns:\n            Configured TelemetryConfig instance\n        \"\"\"\n        config = cls()\n\n        # Service configuration\n        if service_name := os.getenv(\"OTEL_SERVICE_NAME\"):\n            config.resource.service_name = service_name\n\n        if service_version := os.getenv(\"OTEL_SERVICE_VERSION\"):\n            config.resource.service_version = service_version\n\n        # Endpoint configuration\n        if endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_ENDPOINT\"):\n            config.trace_exporter.endpoint = endpoint\n            config.metric_exporter.endpoint = endpoint\n\n        # Trace-specific endpoint\n        if trace_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_TRACES_ENDPOINT\"):\n            config.trace_exporter.endpoint = trace_endpoint\n\n        # Metric-specific endpoint\n        if metric_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\"):\n            config.metric_exporter.endpoint = metric_endpoint\n\n        # Headers\n        if headers := os.getenv(\"OTEL_EXPORTER_OTLP_HEADERS\"):\n            parsed_headers = {}\n            for header in headers.split(\",\"):\n                if \"=\" in header:\n                    key, value = header.split(\"=\", 1)\n                    parsed_headers[key.strip()] = value.strip()\n            config.trace_exporter.headers = parsed_headers\n            config.metric_exporter.headers = parsed_headers\n\n        # Sampling\n        if sample_rate := os.getenv(\"OTEL_TRACES_SAMPLER_ARG\"):\n            try:\n                config.sampling.sample_rate = float(sample_rate)\n            except ValueError:\n                pass\n\n        # Exporters\n        if traces_exporter := os.getenv(\"OTEL_TRACES_EXPORTER\"):\n            if traces_exporter == \"none\":\n                config.export_traces = False\n            elif traces_exporter in ExportFormat.__members__.values():\n                config.trace_exporter.format = ExportFormat(traces_exporter)\n\n        if metrics_exporter := os.getenv(\"OTEL_METRICS_EXPORTER\"):\n            if metrics_exporter == \"none\":\n                config.export_metrics = False\n            elif metrics_exporter in ExportFormat.__members__.values():\n                config.metric_exporter.format = ExportFormat(metrics_exporter)\n\n        return config\n\n    def to_env_dict(self) -&gt; Dict[str, str]:\n        \"\"\"Convert configuration to environment variables.\n\n        Returns:\n            Dictionary of environment variables\n        \"\"\"\n        env_vars = {\n            \"OTEL_SERVICE_NAME\": self.resource.service_name,\n            \"OTEL_SERVICE_VERSION\": self.resource.service_version,\n            \"OTEL_TRACES_SAMPLER_ARG\": str(self.sampling.sample_rate),\n        }\n\n        if self.trace_exporter.endpoint:\n            env_vars[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = self.trace_exporter.endpoint\n\n        if self.trace_exporter.headers:\n            headers_str = \",\".join(\n                f\"{k}={v}\" for k, v in self.trace_exporter.headers.items()\n            )\n            env_vars[\"OTEL_EXPORTER_OTLP_HEADERS\"] = headers_str\n\n        if not self.export_traces:\n            env_vars[\"OTEL_TRACES_EXPORTER\"] = \"none\"\n        else:\n            env_vars[\"OTEL_TRACES_EXPORTER\"] = self.trace_exporter.format.value\n\n        if not self.export_metrics:\n            env_vars[\"OTEL_METRICS_EXPORTER\"] = \"none\"\n        else:\n            env_vars[\"OTEL_METRICS_EXPORTER\"] = self.metric_exporter.format.value\n\n        return env_vars\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.TelemetryConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create configuration from environment variables.</p> <p>Supports standard OpenTelemetry environment variables: - OTEL_SERVICE_NAME - OTEL_EXPORTER_OTLP_ENDPOINT - OTEL_TRACES_EXPORTER - OTEL_METRICS_EXPORTER - OTEL_TRACES_SAMPLER_ARG</p> <p>Returns:</p> Type Description <code>TelemetryConfig</code> <p>Configured TelemetryConfig instance</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; \"TelemetryConfig\":\n    \"\"\"Create configuration from environment variables.\n\n    Supports standard OpenTelemetry environment variables:\n    - OTEL_SERVICE_NAME\n    - OTEL_EXPORTER_OTLP_ENDPOINT\n    - OTEL_TRACES_EXPORTER\n    - OTEL_METRICS_EXPORTER\n    - OTEL_TRACES_SAMPLER_ARG\n\n    Returns:\n        Configured TelemetryConfig instance\n    \"\"\"\n    config = cls()\n\n    # Service configuration\n    if service_name := os.getenv(\"OTEL_SERVICE_NAME\"):\n        config.resource.service_name = service_name\n\n    if service_version := os.getenv(\"OTEL_SERVICE_VERSION\"):\n        config.resource.service_version = service_version\n\n    # Endpoint configuration\n    if endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_ENDPOINT\"):\n        config.trace_exporter.endpoint = endpoint\n        config.metric_exporter.endpoint = endpoint\n\n    # Trace-specific endpoint\n    if trace_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_TRACES_ENDPOINT\"):\n        config.trace_exporter.endpoint = trace_endpoint\n\n    # Metric-specific endpoint\n    if metric_endpoint := os.getenv(\"OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\"):\n        config.metric_exporter.endpoint = metric_endpoint\n\n    # Headers\n    if headers := os.getenv(\"OTEL_EXPORTER_OTLP_HEADERS\"):\n        parsed_headers = {}\n        for header in headers.split(\",\"):\n            if \"=\" in header:\n                key, value = header.split(\"=\", 1)\n                parsed_headers[key.strip()] = value.strip()\n        config.trace_exporter.headers = parsed_headers\n        config.metric_exporter.headers = parsed_headers\n\n    # Sampling\n    if sample_rate := os.getenv(\"OTEL_TRACES_SAMPLER_ARG\"):\n        try:\n            config.sampling.sample_rate = float(sample_rate)\n        except ValueError:\n            pass\n\n    # Exporters\n    if traces_exporter := os.getenv(\"OTEL_TRACES_EXPORTER\"):\n        if traces_exporter == \"none\":\n            config.export_traces = False\n        elif traces_exporter in ExportFormat.__members__.values():\n            config.trace_exporter.format = ExportFormat(traces_exporter)\n\n    if metrics_exporter := os.getenv(\"OTEL_METRICS_EXPORTER\"):\n        if metrics_exporter == \"none\":\n            config.export_metrics = False\n        elif metrics_exporter in ExportFormat.__members__.values():\n            config.metric_exporter.format = ExportFormat(metrics_exporter)\n\n    return config\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.TelemetryConfig.to_env_dict","title":"<code>to_env_dict()</code>","text":"<p>Convert configuration to environment variables.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dictionary of environment variables</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def to_env_dict(self) -&gt; Dict[str, str]:\n    \"\"\"Convert configuration to environment variables.\n\n    Returns:\n        Dictionary of environment variables\n    \"\"\"\n    env_vars = {\n        \"OTEL_SERVICE_NAME\": self.resource.service_name,\n        \"OTEL_SERVICE_VERSION\": self.resource.service_version,\n        \"OTEL_TRACES_SAMPLER_ARG\": str(self.sampling.sample_rate),\n    }\n\n    if self.trace_exporter.endpoint:\n        env_vars[\"OTEL_EXPORTER_OTLP_ENDPOINT\"] = self.trace_exporter.endpoint\n\n    if self.trace_exporter.headers:\n        headers_str = \",\".join(\n            f\"{k}={v}\" for k, v in self.trace_exporter.headers.items()\n        )\n        env_vars[\"OTEL_EXPORTER_OTLP_HEADERS\"] = headers_str\n\n    if not self.export_traces:\n        env_vars[\"OTEL_TRACES_EXPORTER\"] = \"none\"\n    else:\n        env_vars[\"OTEL_TRACES_EXPORTER\"] = self.trace_exporter.format.value\n\n    if not self.export_metrics:\n        env_vars[\"OTEL_METRICS_EXPORTER\"] = \"none\"\n    else:\n        env_vars[\"OTEL_METRICS_EXPORTER\"] = self.metric_exporter.format.value\n\n    return env_vars\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.development_config","title":"<code>development_config()</code>","text":"<p>Get development environment configuration.</p> <ul> <li>Console exporter for easy debugging</li> <li>Full sampling</li> <li>All instrumentation enabled</li> </ul> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def development_config() -&gt; TelemetryConfig:\n    \"\"\"Get development environment configuration.\n\n    - Console exporter for easy debugging\n    - Full sampling\n    - All instrumentation enabled\n    \"\"\"\n    return TelemetryConfig(\n        resource=ResourceConfig(\n            environment=TelemetryEnvironment.DEVELOPMENT\n        ),\n        trace_exporter=ExporterConfig(\n            format=ExportFormat.CONSOLE\n        ),\n        metric_exporter=ExporterConfig(\n            format=ExportFormat.CONSOLE\n        ),\n        sampling=SamplingConfig(\n            sample_rate=1.0\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.production_config","title":"<code>production_config(service_name, otlp_endpoint, sample_rate=0.1)</code>","text":"<p>Get production environment configuration.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>Name of your service</p> required <code>otlp_endpoint</code> <code>str</code> <p>OTLP collector endpoint</p> required <code>sample_rate</code> <code>float</code> <p>Sampling rate (default 10%)</p> <code>0.1</code> <p>Returns:</p> Type Description <code>TelemetryConfig</code> <p>Production-ready configuration</p> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def production_config(\n    service_name: str,\n    otlp_endpoint: str,\n    sample_rate: float = 0.1\n) -&gt; TelemetryConfig:\n    \"\"\"Get production environment configuration.\n\n    Args:\n        service_name: Name of your service\n        otlp_endpoint: OTLP collector endpoint\n        sample_rate: Sampling rate (default 10%)\n\n    Returns:\n        Production-ready configuration\n    \"\"\"\n    return TelemetryConfig(\n        resource=ResourceConfig(\n            service_name=service_name,\n            environment=TelemetryEnvironment.PRODUCTION\n        ),\n        trace_exporter=ExporterConfig(\n            format=ExportFormat.OTLP,\n            endpoint=otlp_endpoint,\n            insecure=False\n        ),\n        metric_exporter=ExporterConfig(\n            format=ExportFormat.OTLP,\n            endpoint=otlp_endpoint,\n            insecure=False\n        ),\n        sampling=SamplingConfig(\n            sample_rate=sample_rate\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/config/#agenticraft.telemetry.config.test_config","title":"<code>test_config()</code>","text":"<p>Get test environment configuration.</p> <ul> <li>Telemetry disabled by default</li> <li>No external dependencies</li> </ul> Source code in <code>agenticraft/telemetry/config.py</code> <pre><code>def test_config() -&gt; TelemetryConfig:\n    \"\"\"Get test environment configuration.\n\n    - Telemetry disabled by default\n    - No external dependencies\n    \"\"\"\n    return TelemetryConfig(\n        enabled=False,\n        resource=ResourceConfig(\n            environment=TelemetryEnvironment.TEST\n        )\n    )\n</code></pre>"},{"location":"reference/telemetry/decorators/","title":"Decorators","text":""},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators","title":"<code>decorators</code>","text":"<p>Telemetry decorators for AgentiCraft.</p> <p>This module provides decorators for adding telemetry to functions and methods, including automatic tracing, metrics collection, and error tracking.</p> Example <p>Using telemetry decorators::</p> <pre><code>from agenticraft.telemetry.decorators import track_metrics, trace\n\n@trace(name=\"api.process_request\")\n@track_metrics(\n    labels=[\"method\", \"endpoint\"],\n    track_duration=True,\n    track_errors=True\n)\nasync def process_request(method: str, endpoint: str):\n    # Automatically traced and measured\n    return await handle_api_call(method, endpoint)\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.track_metrics","title":"<code>track_metrics(name=None, labels=None, track_duration=True, track_errors=True, track_calls=True, custom_metrics=None)</code>","text":"<p>Decorator to track metrics for a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Metric name prefix (defaults to function name)</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>List of parameter names to use as metric labels</p> <code>None</code> <code>track_duration</code> <code>bool</code> <p>Whether to track execution duration</p> <code>True</code> <code>track_errors</code> <code>bool</code> <p>Whether to track error count</p> <code>True</code> <code>track_calls</code> <code>bool</code> <p>Whether to track call count</p> <code>True</code> <code>custom_metrics</code> <code>Optional[Dict[str, str]]</code> <p>Additional metrics to track</p> <code>None</code> Example <p>@track_metrics(     labels=[\"agent_name\", \"tool_name\"],     track_duration=True ) async def execute_tool(agent_name: str, tool_name: str, args: dict):     # Metrics will be tracked with agent_name and tool_name labels     return await tool.run(args)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def track_metrics(\n    name: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    track_duration: bool = True,\n    track_errors: bool = True,\n    track_calls: bool = True,\n    custom_metrics: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to track metrics for a function.\n\n    Args:\n        name: Metric name prefix (defaults to function name)\n        labels: List of parameter names to use as metric labels\n        track_duration: Whether to track execution duration\n        track_errors: Whether to track error count\n        track_calls: Whether to track call count\n        custom_metrics: Additional metrics to track\n\n    Example:\n        @track_metrics(\n            labels=[\"agent_name\", \"tool_name\"],\n            track_duration=True\n        )\n        async def execute_tool(agent_name: str, tool_name: str, args: dict):\n            # Metrics will be tracked with agent_name and tool_name labels\n            return await tool.run(args)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        # Determine metric name\n        metric_name = name or f\"{func.__module__}.{func.__name__}\"\n        metric_labels = labels or []\n\n        # Get telemetry instance\n        telemetry = get_global_telemetry()\n\n        # Create metrics if telemetry is available\n        call_counter = None\n        error_counter = None\n        duration_histogram = None\n\n        if telemetry and telemetry.meter:\n            meter = telemetry.meter\n\n            if track_calls:\n                call_counter = meter.create_counter(\n                    f\"{metric_name}.calls\",\n                    description=f\"Number of calls to {func.__name__}\"\n                )\n\n            if track_errors:\n                error_counter = meter.create_counter(\n                    f\"{metric_name}.errors\",\n                    description=f\"Number of errors in {func.__name__}\"\n                )\n\n            if track_duration:\n                duration_histogram = meter.create_histogram(\n                    f\"{metric_name}.duration\",\n                    description=f\"Execution duration of {func.__name__}\",\n                    unit=\"s\"\n                )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            start_time = time.time()\n\n            # Extract label values\n            label_values = _extract_label_values(\n                func, args, kwargs, metric_labels\n            )\n\n            # Track call\n            if call_counter:\n                call_counter.add(1, label_values)\n\n            try:\n                result = await func(*args, **kwargs)\n                return result\n            except Exception as e:\n                # Track error\n                if error_counter:\n                    error_label_values = {**label_values, \"error_type\": type(e).__name__}\n                    error_counter.add(1, error_label_values)\n                raise\n            finally:\n                # Track duration\n                if duration_histogram:\n                    duration = time.time() - start_time\n                    duration_histogram.record(duration, label_values)\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            start_time = time.time()\n\n            # Extract label values\n            label_values = _extract_label_values(\n                func, args, kwargs, metric_labels\n            )\n\n            # Track call\n            if call_counter:\n                call_counter.add(1, label_values)\n\n            try:\n                result = func(*args, **kwargs)\n                return result\n            except Exception as e:\n                # Track error\n                if error_counter:\n                    error_label_values = {**label_values, \"error_type\": type(e).__name__}\n                    error_counter.add(1, error_label_values)\n                raise\n            finally:\n                # Track duration\n                if duration_histogram:\n                    duration = time.time() - start_time\n                    duration_histogram.record(duration, label_values)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.trace","title":"<code>trace(name=None, attributes=None, kind=SpanKind.INTERNAL, record_exception=True, set_status_on_exception=True)</code>","text":"<p>Decorator to add tracing to a function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Span name (defaults to function name)</p> <code>None</code> <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Static span attributes</p> <code>None</code> <code>kind</code> <code>SpanKind</code> <p>Span kind (INTERNAL, SERVER, CLIENT, etc.)</p> <code>INTERNAL</code> <code>record_exception</code> <code>bool</code> <p>Whether to record exceptions</p> <code>True</code> <code>set_status_on_exception</code> <code>bool</code> <p>Whether to set error status on exception</p> <code>True</code> Example <p>@trace(     attributes={\"component\": \"agent\"},     kind=trace.SpanKind.SERVER ) async def handle_agent_request(request):     return await process(request)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace(\n    name: Optional[str] = None,\n    attributes: Optional[Dict[str, Any]] = None,\n    kind: SpanKind = SpanKind.INTERNAL,\n    record_exception: bool = True,\n    set_status_on_exception: bool = True\n) -&gt; Callable:\n    \"\"\"Decorator to add tracing to a function.\n\n    Args:\n        name: Span name (defaults to function name)\n        attributes: Static span attributes\n        kind: Span kind (INTERNAL, SERVER, CLIENT, etc.)\n        record_exception: Whether to record exceptions\n        set_status_on_exception: Whether to set error status on exception\n\n    Example:\n        @trace(\n            attributes={\"component\": \"agent\"},\n            kind=trace.SpanKind.SERVER\n        )\n        async def handle_agent_request(request):\n            return await process(request)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        span_name = name or f\"{func.__module__}.{func.__name__}\"\n        tracer = get_tracer(func.__module__)\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            with tracer.start_as_current_span(\n                span_name,\n                kind=kind,\n                attributes=attributes\n            ) as span:\n                try:\n                    # Add dynamic attributes from function parameters\n                    _add_span_attributes_from_params(span, func, args, kwargs)\n\n                    result = await func(*args, **kwargs)\n                    return result\n                except Exception as e:\n                    if record_exception:\n                        span.record_exception(e)\n                    if set_status_on_exception:\n                        span.set_status(Status(StatusCode.ERROR, str(e)))\n                    raise\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            with tracer.start_as_current_span(\n                span_name,\n                kind=kind,\n                attributes=attributes\n            ) as span:\n                try:\n                    # Add dynamic attributes from function parameters\n                    _add_span_attributes_from_params(span, func, args, kwargs)\n\n                    result = func(*args, **kwargs)\n                    return result\n                except Exception as e:\n                    if record_exception:\n                        span.record_exception(e)\n                    if set_status_on_exception:\n                        span.set_status(Status(StatusCode.ERROR, str(e)))\n                    raise\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.measure_time","title":"<code>measure_time(metric_name, labels=None)</code>","text":"<p>Simple decorator to measure execution time.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the duration metric</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@measure_time(\"database.query.duration\", {\"db\": \"postgres\"}) def query_database(sql: str):     return db.execute(sql)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def measure_time(\n    metric_name: str,\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Simple decorator to measure execution time.\n\n    Args:\n        metric_name: Name for the duration metric\n        labels: Static labels for the metric\n\n    Example:\n        @measure_time(\"database.query.duration\", {\"db\": \"postgres\"})\n        def query_database(sql: str):\n            return db.execute(sql)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create histogram metric\n        histogram = None\n        if telemetry and telemetry.meter:\n            histogram = telemetry.meter.create_histogram(\n                metric_name,\n                description=f\"Duration of {func.__name__}\",\n                unit=\"s\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            start = time.time()\n            try:\n                return await func(*args, **kwargs)\n            finally:\n                if histogram:\n                    duration = time.time() - start\n                    histogram.record(duration, labels or {})\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            start = time.time()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                if histogram:\n                    duration = time.time() - start\n                    histogram.record(duration, labels or {})\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.count_calls","title":"<code>count_calls(metric_name, labels=None)</code>","text":"<p>Decorator to count function calls.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the counter metric</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@count_calls(\"api.requests\", {\"version\": \"v1\"}) async def handle_api_request(request):     return process(request)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def count_calls(\n    metric_name: str,\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to count function calls.\n\n    Args:\n        metric_name: Name for the counter metric\n        labels: Static labels for the metric\n\n    Example:\n        @count_calls(\"api.requests\", {\"version\": \"v1\"})\n        async def handle_api_request(request):\n            return process(request)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create counter metric\n        counter = None\n        if telemetry and telemetry.meter:\n            counter = telemetry.meter.create_counter(\n                metric_name,\n                description=f\"Count of {func.__name__} calls\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            if counter:\n                counter.add(1, labels or {})\n            return await func(*args, **kwargs)\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            if counter:\n                counter.add(1, labels or {})\n            return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.observe_value","title":"<code>observe_value(metric_name, value_func, labels=None)</code>","text":"<p>Decorator to observe a value from function result.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>Name for the gauge metric</p> required <code>value_func</code> <code>Callable[..., Union[int, float]]</code> <p>Function to extract value from result</p> required <code>labels</code> <code>Optional[Dict[str, str]]</code> <p>Static labels for the metric</p> <code>None</code> Example <p>@observe_value(     \"cache.size\",     value_func=lambda result: len(result),     labels={\"cache\": \"memory\"} ) def get_cache_contents():     return cache.get_all()</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def observe_value(\n    metric_name: str,\n    value_func: Callable[..., Union[int, float]],\n    labels: Optional[Dict[str, str]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to observe a value from function result.\n\n    Args:\n        metric_name: Name for the gauge metric\n        value_func: Function to extract value from result\n        labels: Static labels for the metric\n\n    Example:\n        @observe_value(\n            \"cache.size\",\n            value_func=lambda result: len(result),\n            labels={\"cache\": \"memory\"}\n        )\n        def get_cache_contents():\n            return cache.get_all()\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        telemetry = get_global_telemetry()\n\n        # Create gauge metric\n        gauge = None\n        if telemetry and telemetry.meter:\n            gauge = telemetry.meter.create_gauge(\n                metric_name,\n                description=f\"Value observed from {func.__name__}\"\n            )\n\n        @functools.wraps(func)\n        async def async_wrapper(*args, **kwargs):\n            result = await func(*args, **kwargs)\n            if gauge:\n                try:\n                    value = value_func(result)\n                    gauge.set(value, labels or {})\n                except Exception:\n                    pass  # Don't fail if metric extraction fails\n            return result\n\n        @functools.wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            if gauge:\n                try:\n                    value = value_func(result)\n                    gauge.set(value, labels or {})\n                except Exception:\n                    pass  # Don't fail if metric extraction fails\n            return result\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.trace_agent_method","title":"<code>trace_agent_method(method_name=None)</code>","text":"<p>Specialized decorator for agent methods.</p> <p>Automatically adds agent-specific attributes and metrics.</p> Example <p>class MyAgent(Agent):     @trace_agent_method()     async def process(self, input: str) -&gt; str:         return await self._generate_response(input)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace_agent_method(method_name: Optional[str] = None) -&gt; Callable:\n    \"\"\"Specialized decorator for agent methods.\n\n    Automatically adds agent-specific attributes and metrics.\n\n    Example:\n        class MyAgent(Agent):\n            @trace_agent_method()\n            async def process(self, input: str) -&gt; str:\n                return await self._generate_response(input)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        name = method_name or func.__name__\n\n        @trace(\n            name=f\"agent.{name}\",\n            kind=SpanKind.INTERNAL\n        )\n        @track_metrics(\n            name=f\"agenticraft.agent.{name}\",\n            labels=[\"agent_name\"],\n            track_duration=True,\n            track_errors=True\n        )\n        @functools.wraps(func)\n        async def wrapper(self, *args, **kwargs):\n            # Add agent context to current span\n            span = otel_trace.get_current_span()\n            if span and hasattr(self, 'name'):\n                span.set_attribute(\"agent.name\", self.name)\n                span.set_attribute(\"agent.id\", getattr(self, 'id', 'unknown'))\n\n                # Add trace ID to span attributes instead of kwargs\n                trace_id = get_current_trace_id()\n                if trace_id:\n                    span.set_attribute(\"trace.id\", trace_id)\n\n            return await func(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/decorators/#agenticraft.telemetry.decorators.trace_tool_execution","title":"<code>trace_tool_execution(tool_name=None)</code>","text":"<p>Specialized decorator for tool execution.</p> Example <p>@trace_tool_execution(\"web_search\") async def search_web(query: str) -&gt; List[Dict]:     return await search_api.search(query)</p> Source code in <code>agenticraft/telemetry/decorators.py</code> <pre><code>def trace_tool_execution(tool_name: Optional[str] = None) -&gt; Callable:\n    \"\"\"Specialized decorator for tool execution.\n\n    Example:\n        @trace_tool_execution(\"web_search\")\n        async def search_web(query: str) -&gt; List[Dict]:\n            return await search_api.search(query)\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        name = tool_name or func.__name__\n\n        @trace(\n            name=f\"tool.{name}\",\n            kind=SpanKind.CLIENT,\n            attributes={\"tool.name\": name}\n        )\n        @track_metrics(\n            name=f\"agenticraft.tool.{name}\",\n            track_duration=True,\n            track_errors=True\n        )\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/tracer/","title":"Tracer","text":""},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer","title":"<code>tracer</code>","text":"<p>OpenTelemetry tracer setup for AgentiCraft.</p> <p>This module provides the tracer initialization and configuration for distributed tracing across AgentiCraft applications.</p> Example <p>Basic tracer setup::</p> <pre><code>from agenticraft.telemetry import setup_tracing, get_tracer\n\n# Initialize tracing\nsetup_tracing(\n    service_name=\"my-agent-service\",\n    endpoint=\"http://jaeger:4317\"\n)\n\n# Get a tracer\ntracer = get_tracer(__name__)\n\n# Create spans\nwith tracer.start_as_current_span(\"process_request\"):\n    # Your code here\n    pass\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.TracerManager","title":"<code>TracerManager</code>","text":"<p>Manages OpenTelemetry tracer setup and configuration.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>class TracerManager:\n    \"\"\"Manages OpenTelemetry tracer setup and configuration.\"\"\"\n\n    def __init__(self, config: TelemetryConfig):\n        \"\"\"Initialize tracer manager.\n\n        Args:\n            config: Telemetry configuration\n        \"\"\"\n        self.config = config\n        self._tracer_provider: Optional[TracerProvider] = None\n        self._instrumentors: List[Any] = []\n\n    def setup(self) -&gt; None:\n        \"\"\"Set up the tracer with configured exporters and processors.\"\"\"\n        if not self.config.enabled or not self.config.export_traces:\n            logger.info(\"Tracing is disabled\")\n            return\n\n        # Create resource\n        resource = self._create_resource()\n\n        # Create sampler\n        sampler = self._create_sampler()\n\n        # Create tracer provider\n        self._tracer_provider = TracerProvider(\n            resource=resource,\n            sampler=sampler\n        )\n\n        # Add span processors\n        processors = self._create_span_processors()\n        for processor in processors:\n            self._tracer_provider.add_span_processor(processor)\n\n        # Set as global tracer provider\n        trace.set_tracer_provider(self._tracer_provider)\n\n        # Set up instrumentation\n        self._setup_instrumentation()\n\n        logger.info(\n            f\"Tracing initialized with {self.config.trace_exporter.format} exporter\"\n        )\n\n    def _create_resource(self) -&gt; Resource:\n        \"\"\"Create OpenTelemetry resource from config.\"\"\"\n        attributes = {\n            \"service.name\": self.config.resource.service_name,\n            \"service.version\": self.config.resource.service_version,\n            \"deployment.environment\": self.config.resource.environment.value,\n        }\n\n        if self.config.resource.service_instance_id:\n            attributes[\"service.instance.id\"] = self.config.resource.service_instance_id\n\n        # Add custom attributes\n        attributes.update(self.config.resource.attributes)\n\n        return Resource.create(attributes)\n\n    def _create_sampler(self) -&gt; Sampler:\n        \"\"\"Create sampler from configuration.\"\"\"\n        base_sampler = TraceIdRatioBased(self.config.sampling.sample_rate)\n\n        if self.config.sampling.parent_based:\n            return ParentBased(root=base_sampler)\n\n        return base_sampler\n\n    def _create_span_processors(self) -&gt; List[SpanProcessor]:\n        \"\"\"Create span processors based on configuration.\"\"\"\n        processors = []\n\n        exporter = self._create_span_exporter()\n        if exporter:\n            if self.config.trace_exporter.format == ExportFormat.CONSOLE:\n                # Use simple processor for console output\n                processors.append(SimpleSpanProcessor(exporter))\n            else:\n                # Use batch processor for network exporters\n                processors.append(BatchSpanProcessor(\n                    exporter,\n                    max_queue_size=2048,\n                    max_export_batch_size=512,\n                    export_timeout_millis=self.config.trace_exporter.timeout_ms\n                ))\n\n        return processors\n\n    def _create_span_exporter(self):\n        \"\"\"Create appropriate span exporter based on format.\"\"\"\n        format_type = self.config.trace_exporter.format\n\n        if format_type == ExportFormat.NONE:\n            return None\n\n        if format_type == ExportFormat.CONSOLE:\n            return ConsoleSpanExporter()\n\n        if format_type == ExportFormat.OTLP:\n            if OTLPSpanExporter is None:\n                logger.warning(\"OTLP exporter not available. Install opentelemetry-exporter-otlp\")\n                return ConsoleSpanExporter()\n            return OTLPSpanExporter(\n                endpoint=self.config.trace_exporter.endpoint,\n                headers=self.config.trace_exporter.headers,\n                insecure=self.config.trace_exporter.insecure\n            )\n\n        if format_type == ExportFormat.JAEGER:\n            if JaegerExporter is None:\n                logger.warning(\"Jaeger exporter not available. Install opentelemetry-exporter-jaeger\")\n                return ConsoleSpanExporter()\n            # Parse Jaeger endpoint\n            if self.config.trace_exporter.endpoint:\n                parts = self.config.trace_exporter.endpoint.split(\":\")\n                agent_host = parts[0] if parts else \"localhost\"\n                agent_port = int(parts[1]) if len(parts) &gt; 1 else 6831\n            else:\n                agent_host = \"localhost\"\n                agent_port = 6831\n\n            return JaegerExporter(\n                agent_host_name=agent_host,\n                agent_port=agent_port,\n                udp_split_oversized_batches=True\n            )\n\n        if format_type == ExportFormat.ZIPKIN:\n            if ZipkinExporter is None:\n                logger.warning(\"Zipkin exporter not available. Install opentelemetry-exporter-zipkin\")\n                return ConsoleSpanExporter()\n            return ZipkinExporter(\n                endpoint=self.config.trace_exporter.endpoint\n            )\n\n        raise ValueError(f\"Unsupported trace exporter format: {format_type}\")\n\n    def _setup_instrumentation(self) -&gt; None:\n        \"\"\"Set up automatic instrumentation based on config.\"\"\"\n        instrumentation = self.config.instrumentation\n\n        if instrumentation.instrument_http:\n            if HTTPXClientInstrumentor is None:\n                logger.warning(\"HTTPX instrumentation not available\")\n            else:\n                instrumentor = HTTPXClientInstrumentor()\n                instrumentor.instrument(\n                    tracer_provider=self._tracer_provider,\n                    excluded_urls=instrumentation.excluded_urls\n                )\n                self._instrumentors.append(instrumentor)\n\n        if instrumentation.instrument_grpc:\n            if GrpcInstrumentorClient is None or GrpcInstrumentorServer is None:\n                logger.warning(\"gRPC instrumentation not available\")\n            else:\n                # Client instrumentation\n                client_instrumentor = GrpcInstrumentorClient()\n                client_instrumentor.instrument(tracer_provider=self._tracer_provider)\n                self._instrumentors.append(client_instrumentor)\n\n                # Server instrumentation\n                server_instrumentor = GrpcInstrumentorServer()\n                server_instrumentor.instrument(tracer_provider=self._tracer_provider)\n                self._instrumentors.append(server_instrumentor)\n\n    def shutdown(self) -&gt; None:\n        \"\"\"Shutdown tracer and exporters.\"\"\"\n        # Uninstrument all instrumentors\n        for instrumentor in self._instrumentors:\n            try:\n                instrumentor.uninstrument()\n            except Exception as e:\n                logger.warning(f\"Failed to uninstrument: {e}\")\n\n        # Shutdown tracer provider\n        if self._tracer_provider:\n            self._tracer_provider.shutdown()\n\n        logger.info(\"Tracing shutdown complete\")\n\n    def get_tracer(self, name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n        \"\"\"Get a tracer instance.\n\n        Args:\n            name: Name of the tracer (usually __name__)\n            version: Optional version string\n\n        Returns:\n            Tracer instance\n        \"\"\"\n        if self._tracer_provider:\n            return self._tracer_provider.get_tracer(name, version)\n        return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.TracerManager.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize tracer manager.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>TelemetryConfig</code> <p>Telemetry configuration</p> required Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def __init__(self, config: TelemetryConfig):\n    \"\"\"Initialize tracer manager.\n\n    Args:\n        config: Telemetry configuration\n    \"\"\"\n    self.config = config\n    self._tracer_provider: Optional[TracerProvider] = None\n    self._instrumentors: List[Any] = []\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.TracerManager.setup","title":"<code>setup()</code>","text":"<p>Set up the tracer with configured exporters and processors.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Set up the tracer with configured exporters and processors.\"\"\"\n    if not self.config.enabled or not self.config.export_traces:\n        logger.info(\"Tracing is disabled\")\n        return\n\n    # Create resource\n    resource = self._create_resource()\n\n    # Create sampler\n    sampler = self._create_sampler()\n\n    # Create tracer provider\n    self._tracer_provider = TracerProvider(\n        resource=resource,\n        sampler=sampler\n    )\n\n    # Add span processors\n    processors = self._create_span_processors()\n    for processor in processors:\n        self._tracer_provider.add_span_processor(processor)\n\n    # Set as global tracer provider\n    trace.set_tracer_provider(self._tracer_provider)\n\n    # Set up instrumentation\n    self._setup_instrumentation()\n\n    logger.info(\n        f\"Tracing initialized with {self.config.trace_exporter.format} exporter\"\n    )\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.TracerManager.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown tracer and exporters.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown tracer and exporters.\"\"\"\n    # Uninstrument all instrumentors\n    for instrumentor in self._instrumentors:\n        try:\n            instrumentor.uninstrument()\n        except Exception as e:\n            logger.warning(f\"Failed to uninstrument: {e}\")\n\n    # Shutdown tracer provider\n    if self._tracer_provider:\n        self._tracer_provider.shutdown()\n\n    logger.info(\"Tracing shutdown complete\")\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.TracerManager.get_tracer","title":"<code>get_tracer(name, version=None)</code>","text":"<p>Get a tracer instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tracer (usually name)</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version string</p> <code>None</code> <p>Returns:</p> Type Description <code>Tracer</code> <p>Tracer instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_tracer(self, name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n    \"\"\"Get a tracer instance.\n\n    Args:\n        name: Name of the tracer (usually __name__)\n        version: Optional version string\n\n    Returns:\n        Tracer instance\n    \"\"\"\n    if self._tracer_provider:\n        return self._tracer_provider.get_tracer(name, version)\n    return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.setup_tracing","title":"<code>setup_tracing(config=None, service_name=None, endpoint=None)</code>","text":"<p>Set up global tracing.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[TelemetryConfig]</code> <p>Full telemetry configuration</p> <code>None</code> <code>service_name</code> <code>Optional[str]</code> <p>Service name (if not using config)</p> <code>None</code> <code>endpoint</code> <code>Optional[str]</code> <p>Exporter endpoint (if not using config)</p> <code>None</code> <p>Returns:</p> Type Description <code>TracerManager</code> <p>TracerManager instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def setup_tracing(\n    config: Optional[TelemetryConfig] = None,\n    service_name: Optional[str] = None,\n    endpoint: Optional[str] = None\n) -&gt; TracerManager:\n    \"\"\"Set up global tracing.\n\n    Args:\n        config: Full telemetry configuration\n        service_name: Service name (if not using config)\n        endpoint: Exporter endpoint (if not using config)\n\n    Returns:\n        TracerManager instance\n    \"\"\"\n    global _tracer_manager\n\n    if config is None:\n        # Create config from environment or parameters\n        config = TelemetryConfig.from_env()\n\n        if service_name:\n            config.resource.service_name = service_name\n\n        if endpoint:\n            config.trace_exporter.endpoint = endpoint\n\n    _tracer_manager = TracerManager(config)\n    _tracer_manager.setup()\n\n    return _tracer_manager\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.get_tracer","title":"<code>get_tracer(name, version=None)</code>","text":"<p>Get a tracer instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the tracer (usually name)</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version string</p> <code>None</code> <p>Returns:</p> Type Description <code>Tracer</code> <p>Tracer instance</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_tracer(name: str, version: Optional[str] = None) -&gt; trace.Tracer:\n    \"\"\"Get a tracer instance.\n\n    Args:\n        name: Name of the tracer (usually __name__)\n        version: Optional version string\n\n    Returns:\n        Tracer instance\n    \"\"\"\n    if _tracer_manager:\n        return _tracer_manager.get_tracer(name, version)\n    return trace.get_tracer(name, version)\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.shutdown_tracing","title":"<code>shutdown_tracing()</code>","text":"<p>Shutdown global tracing.</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def shutdown_tracing() -&gt; None:\n    \"\"\"Shutdown global tracing.\"\"\"\n    global _tracer_manager\n\n    if _tracer_manager:\n        _tracer_manager.shutdown()\n        _tracer_manager = None\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.traced_operation","title":"<code>traced_operation(name, attributes=None, record_exception=True)</code>","text":"<p>Context manager for traced operations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Operation name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Span attributes</p> <code>None</code> <code>record_exception</code> <code>bool</code> <p>Whether to record exceptions</p> <code>True</code> Example <p>with traced_operation(\"database_query\", {\"query.type\": \"select\"}):     result = db.query(\"SELECT * FROM users\")</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>@contextmanager\ndef traced_operation(\n    name: str,\n    attributes: Optional[Dict[str, Any]] = None,\n    record_exception: bool = True\n):\n    \"\"\"Context manager for traced operations.\n\n    Args:\n        name: Operation name\n        attributes: Span attributes\n        record_exception: Whether to record exceptions\n\n    Example:\n        with traced_operation(\"database_query\", {\"query.type\": \"select\"}):\n            result = db.query(\"SELECT * FROM users\")\n    \"\"\"\n    tracer = get_tracer(__name__)\n\n    with tracer.start_as_current_span(name) as span:\n        if attributes:\n            for key, value in attributes.items():\n                span.set_attribute(key, value)\n\n        try:\n            yield span\n        except Exception as e:\n            if record_exception:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n            raise\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.trace_function","title":"<code>trace_function(name=None, attributes=None)</code>","text":"<p>Decorator to trace function execution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Span name (defaults to function name)</p> <code>None</code> <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Additional span attributes</p> <code>None</code> Example <p>@trace_function(attributes={\"handler.type\": \"api\"}) async def handle_request(request):     return {\"status\": \"ok\"}</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def trace_function(\n    name: Optional[str] = None,\n    attributes: Optional[Dict[str, Any]] = None\n) -&gt; Callable:\n    \"\"\"Decorator to trace function execution.\n\n    Args:\n        name: Span name (defaults to function name)\n        attributes: Additional span attributes\n\n    Example:\n        @trace_function(attributes={\"handler.type\": \"api\"})\n        async def handle_request(request):\n            return {\"status\": \"ok\"}\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        span_name = name or f\"{func.__module__}.{func.__name__}\"\n\n        async def async_wrapper(*args, **kwargs):\n            with traced_operation(span_name, attributes):\n                return await func(*args, **kwargs)\n\n        def sync_wrapper(*args, **kwargs):\n            with traced_operation(span_name, attributes):\n                return func(*args, **kwargs)\n\n        if asyncio.iscoroutinefunction(func):\n            return async_wrapper\n        return sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.add_event","title":"<code>add_event(name, attributes=None)</code>","text":"<p>Add an event to the current span.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Event attributes</p> <code>None</code> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def add_event(name: str, attributes: Optional[Dict[str, Any]] = None) -&gt; None:\n    \"\"\"Add an event to the current span.\n\n    Args:\n        name: Event name\n        attributes: Event attributes\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        span.add_event(name, attributes or {})\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.set_attribute","title":"<code>set_attribute(key, value)</code>","text":"<p>Set an attribute on the current span.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute key</p> required <code>value</code> <code>Any</code> <p>Attribute value</p> required Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def set_attribute(key: str, value: Any) -&gt; None:\n    \"\"\"Set an attribute on the current span.\n\n    Args:\n        key: Attribute key\n        value: Attribute value\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        span.set_attribute(key, value)\n</code></pre>"},{"location":"reference/telemetry/tracer/#agenticraft.telemetry.tracer.get_current_trace_id","title":"<code>get_current_trace_id()</code>","text":"<p>Get the current trace ID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Trace ID as hex string or None</p> Source code in <code>agenticraft/telemetry/tracer.py</code> <pre><code>def get_current_trace_id() -&gt; Optional[str]:\n    \"\"\"Get the current trace ID if available.\n\n    Returns:\n        Trace ID as hex string or None\n    \"\"\"\n    span = trace.get_current_span()\n    if span and span.is_recording():\n        context = span.get_span_context()\n        if context.trace_id:\n            return format(context.trace_id, \"032x\")\n    return None\n</code></pre>"},{"location":"reference/tools/__init__/","title":"init","text":""},{"location":"reference/tools/__init__/#agenticraft.tools","title":"<code>tools</code>","text":"<p>Built-in tools for AgentiCraft.</p> <p>This module provides a collection of ready-to-use tools that agents can leverage for various tasks.</p> <p>Available tool categories: - Calculator: Mathematical operations - File Operations: File reading, writing, and manipulation - Web: Search and web content extraction</p> Example <p>Using built-in tools with an agent::</p> <pre><code>from agenticraft import Agent\nfrom agenticraft.tools import simple_calculate, web_search, read_file\n\nagent = Agent(\n    name=\"researcher\",\n    tools=[simple_calculate, web_search, read_file]\n)\n\nresponse = await agent.arun(\n    \"Search for Python tutorials and calculate 15% of 1200\"\n)\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.simple_calculate","title":"<code>simple_calculate(expression)</code>","text":"<p>Evaluate a mathematical expression safely.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Mathematical expression to evaluate</p> required <p>Returns:</p> Type Description <code>float</code> <p>Result of the calculation</p> Example <p>simple_calculate(\"2 + 2\") 4.0 simple_calculate(\"sqrt(16) + sin(pi/2)\") 5.0 simple_calculate(\"max(10, 20, 30)\") 30.0</p> Source code in <code>agenticraft/tools/calculator.py</code> <pre><code>@tool(\n    name=\"simple_calculator\",\n    description=\"Evaluate mathematical expressions with functions. Supports basic arithmetic, trigonometry, and common math functions.\"\n)\ndef simple_calculate(expression: str) -&gt; float:\n    \"\"\"Evaluate a mathematical expression safely.\n\n    Args:\n        expression: Mathematical expression to evaluate\n\n    Returns:\n        Result of the calculation\n\n    Example:\n        &gt;&gt;&gt; simple_calculate(\"2 + 2\")\n        4.0\n        &gt;&gt;&gt; simple_calculate(\"sqrt(16) + sin(pi/2)\")\n        5.0\n        &gt;&gt;&gt; simple_calculate(\"max(10, 20, 30)\")\n        30.0\n    \"\"\"\n    return _calculate_expression(expression)\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.scientific_calculate","title":"<code>scientific_calculate(expression, explain=False, precision=4)</code>  <code>async</code>","text":"<p>Perform scientific calculation with optional explanation.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Mathematical expression</p> required <code>explain</code> <code>bool</code> <p>Whether to include step-by-step explanation</p> <code>False</code> <code>precision</code> <code>int</code> <p>Decimal places for rounding</p> <code>4</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with result and optional explanation</p> Example <p>await scientific_calculate(\"log(100, 10)\", explain=True) {     'result': 2.0,     'expression': 'log(100, 10)',     'explanation': 'Logarithm of 100 with base 10 equals 2.0' }</p> Source code in <code>agenticraft/tools/calculator.py</code> <pre><code>@tool(\n    name=\"scientific_calculator\",\n    description=\"Perform advanced scientific calculations with step-by-step explanation.\"\n)\nasync def scientific_calculate(\n    expression: str,\n    explain: bool = False,\n    precision: int = 4\n) -&gt; Dict[str, Any]:\n    \"\"\"Perform scientific calculation with optional explanation.\n\n    Args:\n        expression: Mathematical expression\n        explain: Whether to include step-by-step explanation\n        precision: Decimal places for rounding\n\n    Returns:\n        Dictionary with result and optional explanation\n\n    Example:\n        &gt;&gt;&gt; await scientific_calculate(\"log(100, 10)\", explain=True)\n        {\n            'result': 2.0,\n            'expression': 'log(100, 10)',\n            'explanation': 'Logarithm of 100 with base 10 equals 2.0'\n        }\n    \"\"\"\n    result = _calculate_expression(expression)\n    rounded_result = round(result, precision)\n\n    response = {\n        'result': rounded_result,\n        'expression': expression\n    }\n\n    if explain:\n        # Generate simple explanation\n        explanation = f\"Evaluating: {expression} = {rounded_result}\"\n\n        # Add specific explanations for common operations\n        if 'sqrt' in expression:\n            explanation += \" (square root calculation)\"\n        elif 'log' in expression:\n            explanation += \" (logarithmic calculation)\"\n        elif any(trig in expression for trig in ['sin', 'cos', 'tan']):\n            explanation += \" (trigonometric calculation)\"\n\n        response['explanation'] = explanation\n\n    return response\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.read_file","title":"<code>read_file(path, encoding='utf-8', max_size_mb=10.0)</code>  <code>async</code>","text":"<p>Read contents of a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file</p> required <code>encoding</code> <code>str</code> <p>File encoding (default: utf-8)</p> <code>'utf-8'</code> <code>max_size_mb</code> <code>float</code> <p>Maximum file size in MB to read</p> <code>10.0</code> <p>Returns:</p> Type Description <code>str</code> <p>File contents as string</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If file is too large</p> Example <p>await read_file(\"data.txt\") \"Hello, World!\"</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"read_file\",\n    description=\"Read contents of a text file. Supports various encodings.\"\n)\nasync def read_file(\n    path: str,\n    encoding: str = \"utf-8\",\n    max_size_mb: float = 10.0\n) -&gt; str:\n    \"\"\"Read contents of a file.\n\n    Args:\n        path: Path to the file\n        encoding: File encoding (default: utf-8)\n        max_size_mb: Maximum file size in MB to read\n\n    Returns:\n        File contents as string\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If file is too large\n\n    Example:\n        &gt;&gt;&gt; await read_file(\"data.txt\")\n        \"Hello, World!\"\n    \"\"\"\n    return await _read_file(path, encoding, max_size_mb)\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.write_file","title":"<code>write_file(path, content, encoding='utf-8', overwrite=False)</code>  <code>async</code>","text":"<p>Write content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to write to</p> required <code>content</code> <code>str</code> <p>Content to write</p> required <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with operation details</p> Example <p>await write_file(\"output.txt\", \"Hello!\", overwrite=True)</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"write_file\",\n    description=\"Write content to a file. Creates directories if needed.\"\n)\nasync def write_file(\n    path: str,\n    content: str,\n    encoding: str = \"utf-8\",\n    overwrite: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"Write content to a file.\n\n    Args:\n        path: Path to write to\n        content: Content to write\n        encoding: File encoding\n        overwrite: Whether to overwrite existing files\n\n    Returns:\n        Dictionary with operation details\n\n    Example:\n        &gt;&gt;&gt; await write_file(\"output.txt\", \"Hello!\", overwrite=True)\n        {'path': 'output.txt', 'size': 6, 'created': True}\n    \"\"\"\n    return await _write_file(path, content, encoding, overwrite)\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.list_files","title":"<code>list_files(directory='.', pattern='*', recursive=False, include_hidden=False)</code>  <code>async</code>","text":"<p>List files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Directory to list</p> <code>'.'</code> <code>pattern</code> <code>str</code> <p>Glob pattern for filtering</p> <code>'*'</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively</p> <code>False</code> <code>include_hidden</code> <code>bool</code> <p>Whether to include hidden files</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of file information dictionaries</p> Example <p>await list_files(\".\", pattern=\"*.py\") [{'name': 'main.py', 'size': 1024, 'is_dir': False}, ...]</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"list_files\",\n    description=\"List files in a directory with optional filtering.\"\n)\nasync def list_files(\n    directory: str = \".\",\n    pattern: str = \"*\",\n    recursive: bool = False,\n    include_hidden: bool = False\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List files in a directory.\n\n    Args:\n        directory: Directory to list\n        pattern: Glob pattern for filtering\n        recursive: Whether to search recursively\n        include_hidden: Whether to include hidden files\n\n    Returns:\n        List of file information dictionaries\n\n    Example:\n        &gt;&gt;&gt; await list_files(\".\", pattern=\"*.py\")\n        [{'name': 'main.py', 'size': 1024, 'is_dir': False}, ...]\n    \"\"\"\n    dir_path = Path(directory).expanduser().resolve()\n\n    if not dir_path.exists():\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n\n    if not dir_path.is_dir():\n        raise ValueError(f\"Path is not a directory: {directory}\")\n\n    # Get files\n    if recursive:\n        paths = dir_path.rglob(pattern)\n    else:\n        paths = dir_path.glob(pattern)\n\n    # Build file list\n    files = []\n    for path in paths:\n        # Skip hidden files if requested\n        if not include_hidden and path.name.startswith('.'):\n            continue\n\n        try:\n            stat = path.stat()\n            files.append({\n                'name': path.name,\n                'path': str(path.relative_to(dir_path)),\n                'size': stat.st_size,\n                'is_dir': path.is_dir(),\n                'modified': stat.st_mtime\n            })\n        except Exception:\n            # Skip files we can't stat\n            continue\n\n    # Sort by name\n    files.sort(key=lambda x: x['name'])\n\n    return files\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.read_json","title":"<code>read_json(path)</code>  <code>async</code>","text":"<p>Read and parse JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to JSON file</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Parsed JSON data</p> Example <p>await read_json(\"config.json\")</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"read_json\",\n    description=\"Read and parse a JSON file.\"\n)\nasync def read_json(path: str) -&gt; Any:\n    \"\"\"Read and parse JSON file.\n\n    Args:\n        path: Path to JSON file\n\n    Returns:\n        Parsed JSON data\n\n    Example:\n        &gt;&gt;&gt; await read_json(\"config.json\")\n        {'setting': 'value'}\n    \"\"\"\n    content = await _read_file(path)\n    try:\n        return json.loads(content)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON in {path}: {e}\")\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.write_json","title":"<code>write_json(path, data, indent=2, overwrite=False)</code>  <code>async</code>","text":"<p>Write data to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to write to</p> required <code>data</code> <code>Any</code> <p>Data to serialize as JSON</p> required <code>indent</code> <code>int</code> <p>Indentation level</p> <code>2</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Operation details</p> Example <p>await write_json(\"data.json\", {\"key\": \"value\"})</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"write_json\",\n    description=\"Write data to a JSON file with formatting.\"\n)\nasync def write_json(\n    path: str,\n    data: Any,\n    indent: int = 2,\n    overwrite: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"Write data to JSON file.\n\n    Args:\n        path: Path to write to\n        data: Data to serialize as JSON\n        indent: Indentation level\n        overwrite: Whether to overwrite existing file\n\n    Returns:\n        Operation details\n\n    Example:\n        &gt;&gt;&gt; await write_json(\"data.json\", {\"key\": \"value\"})\n        {'path': 'data.json', 'size': 18, 'created': True}\n    \"\"\"\n    content = json.dumps(data, indent=indent, ensure_ascii=False)\n    return await _write_file(path, content, overwrite=overwrite)\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.file_info","title":"<code>file_info(path)</code>  <code>async</code>","text":"<p>Get detailed file or directory information.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to inspect</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with file/directory details</p> Example <p>await file_info(\"document.txt\") {     'path': 'document.txt',     'exists': True,     'is_file': True,     'size': 1024,     'extension': '.txt' }</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"file_info\",\n    description=\"Get detailed information about a file or directory.\"\n)\nasync def file_info(path: str) -&gt; Dict[str, Any]:\n    \"\"\"Get detailed file or directory information.\n\n    Args:\n        path: Path to inspect\n\n    Returns:\n        Dictionary with file/directory details\n\n    Example:\n        &gt;&gt;&gt; await file_info(\"document.txt\")\n        {\n            'path': 'document.txt',\n            'exists': True,\n            'is_file': True,\n            'size': 1024,\n            'extension': '.txt'\n        }\n    \"\"\"\n    file_path = Path(path).expanduser().resolve()\n\n    info = {\n        'path': str(file_path),\n        'name': file_path.name,\n        'exists': file_path.exists()\n    }\n\n    if file_path.exists():\n        stat = file_path.stat()\n        info.update({\n            'is_file': file_path.is_file(),\n            'is_dir': file_path.is_dir(),\n            'size': stat.st_size,\n            'modified': stat.st_mtime,\n            'created': stat.st_ctime\n        })\n\n        if file_path.is_file():\n            info['extension'] = file_path.suffix\n            info['stem'] = file_path.stem\n\n    return info\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.web_search","title":"<code>web_search(query, num_results=5, search_type='general')</code>  <code>async</code>","text":"<p>Search the web for information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>num_results</code> <code>int</code> <p>Number of results to return (max 10)</p> <code>5</code> <code>search_type</code> <code>str</code> <p>Type of search (general, news, academic)</p> <code>'general'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of search results</p> Example <p>await web_search(\"python programming\", num_results=3) [     {         'title': 'Python Programming Language',         'snippet': 'Official Python website...',         'url': 'https://python.org',         'date': '2024-01-15'     },     ... ]</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"web_search\",\n    description=\"Search the web for information. Returns relevant results with titles, snippets, and URLs.\"\n)\nasync def web_search(\n    query: str,\n    num_results: int = 5,\n    search_type: str = \"general\"\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Search the web for information.\n\n    Args:\n        query: Search query\n        num_results: Number of results to return (max 10)\n        search_type: Type of search (general, news, academic)\n\n    Returns:\n        List of search results\n\n    Example:\n        &gt;&gt;&gt; await web_search(\"python programming\", num_results=3)\n        [\n            {\n                'title': 'Python Programming Language',\n                'snippet': 'Official Python website...',\n                'url': 'https://python.org',\n                'date': '2024-01-15'\n            },\n            ...\n        ]\n    \"\"\"\n    # Limit results\n    num_results = min(num_results, 10)\n\n    # Note: This is a mock implementation\n    # Real implementation would use APIs like:\n    # - Google Custom Search API\n    # - Bing Search API\n    # - DuckDuckGo API\n    # - SerpAPI\n\n    # For demo purposes, return mock results\n    mock_results = [\n        {\n            'title': f'Result {i+1} for: {query}',\n            'snippet': f'This is a relevant snippet about {query}. '\n                      f'It contains useful information that matches the search query...',\n            'url': f'https://example.com/result{i+1}',\n            'date': datetime.now().isoformat(),\n            'relevance_score': 0.95 - (i * 0.05)\n        }\n        for i in range(num_results)\n    ]\n\n    # Add search type specific results\n    if search_type == \"news\":\n        for result in mock_results:\n            result['source'] = 'Example News'\n            result['category'] = 'Technology'\n    elif search_type == \"academic\":\n        for result in mock_results:\n            result['authors'] = ['J. Doe', 'A. Smith']\n            result['citations'] = 42\n\n    return mock_results\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.extract_text","title":"<code>extract_text(url, include_links=False, max_length=None)</code>  <code>async</code>","text":"<p>Extract text content from a webpage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to extract text from</p> required <code>include_links</code> <code>bool</code> <p>Whether to include hyperlinks</p> <code>False</code> <code>max_length</code> <code>Optional[int]</code> <p>Maximum text length to return</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with extracted content</p> Example <p>await extract_text(\"https://example.com/article\") {     'url': 'https://example.com/article',     'title': 'Article Title',     'text': 'Article content...',     'links': [],     'word_count': 500 }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"extract_text\",\n    description=\"Extract clean text content from a webpage URL.\"\n)\nasync def extract_text(\n    url: str,\n    include_links: bool = False,\n    max_length: Optional[int] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Extract text content from a webpage.\n\n    Args:\n        url: URL to extract text from\n        include_links: Whether to include hyperlinks\n        max_length: Maximum text length to return\n\n    Returns:\n        Dictionary with extracted content\n\n    Example:\n        &gt;&gt;&gt; await extract_text(\"https://example.com/article\")\n        {\n            'url': 'https://example.com/article',\n            'title': 'Article Title',\n            'text': 'Article content...',\n            'links': [],\n            'word_count': 500\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Note: Real implementation would use:\n    # - aiohttp for async HTTP requests\n    # - BeautifulSoup or lxml for HTML parsing\n    # - Readability or newspaper3k for article extraction\n\n    # Mock implementation\n    mock_content = {\n        'url': url,\n        'title': f'Page Title from {parsed.netloc}',\n        'text': f'This is the extracted text content from {url}. '\n               f'It contains the main article or page content without '\n               f'navigation, ads, or other clutter. The extraction process '\n               f'identifies the primary content area and extracts clean text.',\n        'word_count': 42,\n        'language': 'en',\n        'published_date': None\n    }\n\n    if include_links:\n        mock_content['links'] = [\n            {'text': 'Related Article', 'url': f'{url}/related'},\n            {'text': 'More Information', 'url': f'{url}/more'}\n        ]\n\n    # Truncate if needed\n    if max_length and len(mock_content['text']) &gt; max_length:\n        mock_content['text'] = mock_content['text'][:max_length] + '...'\n        mock_content['truncated'] = True\n\n    return mock_content\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.get_page_metadata","title":"<code>get_page_metadata(url)</code>  <code>async</code>","text":"<p>Get metadata from a webpage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to analyze</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with page metadata</p> Example <p>await get_page_metadata(\"https://example.com\") {     'url': 'https://example.com',     'title': 'Example Domain',     'description': 'Example Domain for Documentation',     'image': 'https://example.com/image.jpg',     'type': 'website' }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"get_page_metadata\",\n    description=\"Extract metadata from a webpage including title, description, and Open Graph data.\"\n)\nasync def get_page_metadata(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Get metadata from a webpage.\n\n    Args:\n        url: URL to analyze\n\n    Returns:\n        Dictionary with page metadata\n\n    Example:\n        &gt;&gt;&gt; await get_page_metadata(\"https://example.com\")\n        {\n            'url': 'https://example.com',\n            'title': 'Example Domain',\n            'description': 'Example Domain for Documentation',\n            'image': 'https://example.com/image.jpg',\n            'type': 'website'\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Mock implementation\n    # Real implementation would parse meta tags, Open Graph, Twitter Cards, etc.\n    return {\n        'url': url,\n        'title': f'{parsed.netloc} - Home',\n        'description': f'Welcome to {parsed.netloc}',\n        'keywords': ['example', 'demo', 'website'],\n        'author': None,\n        'image': f'{parsed.scheme}://{parsed.netloc}/og-image.jpg',\n        'type': 'website',\n        'locale': 'en_US',\n        'site_name': parsed.netloc.replace('.', ' ').title()\n    }\n</code></pre>"},{"location":"reference/tools/__init__/#agenticraft.tools.check_url","title":"<code>check_url(url)</code>  <code>async</code>","text":"<p>Check URL accessibility and get basic info.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to check</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with URL status and info</p> Example <p>await check_url(\"https://example.com\") {     'url': 'https://example.com',     'accessible': True,     'status_code': 200,     'content_type': 'text/html',     'response_time_ms': 150 }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"check_url\",\n    description=\"Check if a URL is accessible and get basic information.\"\n)\nasync def check_url(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Check URL accessibility and get basic info.\n\n    Args:\n        url: URL to check\n\n    Returns:\n        Dictionary with URL status and info\n\n    Example:\n        &gt;&gt;&gt; await check_url(\"https://example.com\")\n        {\n            'url': 'https://example.com',\n            'accessible': True,\n            'status_code': 200,\n            'content_type': 'text/html',\n            'response_time_ms': 150\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Mock implementation\n    # Real implementation would make HEAD request\n    return {\n        'url': url,\n        'accessible': True,\n        'status_code': 200,\n        'content_type': 'text/html; charset=utf-8',\n        'content_length': 1024 * 10,  # 10KB\n        'response_time_ms': 150,\n        'ssl_valid': parsed.scheme == 'https',\n        'redirects': []\n    }\n</code></pre>"},{"location":"reference/tools/calculator/","title":"Calculator","text":""},{"location":"reference/tools/calculator/#agenticraft.tools.calculator","title":"<code>calculator</code>","text":"<p>Calculator tool for mathematical operations.</p> <p>Provides safe mathematical expression evaluation for agents.</p>"},{"location":"reference/tools/calculator/#agenticraft.tools.calculator.simple_calculate","title":"<code>simple_calculate(expression)</code>","text":"<p>Evaluate a mathematical expression safely.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Mathematical expression to evaluate</p> required <p>Returns:</p> Type Description <code>float</code> <p>Result of the calculation</p> Example <p>simple_calculate(\"2 + 2\") 4.0 simple_calculate(\"sqrt(16) + sin(pi/2)\") 5.0 simple_calculate(\"max(10, 20, 30)\") 30.0</p> Source code in <code>agenticraft/tools/calculator.py</code> <pre><code>@tool(\n    name=\"simple_calculator\",\n    description=\"Evaluate mathematical expressions with functions. Supports basic arithmetic, trigonometry, and common math functions.\"\n)\ndef simple_calculate(expression: str) -&gt; float:\n    \"\"\"Evaluate a mathematical expression safely.\n\n    Args:\n        expression: Mathematical expression to evaluate\n\n    Returns:\n        Result of the calculation\n\n    Example:\n        &gt;&gt;&gt; simple_calculate(\"2 + 2\")\n        4.0\n        &gt;&gt;&gt; simple_calculate(\"sqrt(16) + sin(pi/2)\")\n        5.0\n        &gt;&gt;&gt; simple_calculate(\"max(10, 20, 30)\")\n        30.0\n    \"\"\"\n    return _calculate_expression(expression)\n</code></pre>"},{"location":"reference/tools/calculator/#agenticraft.tools.calculator.scientific_calculate","title":"<code>scientific_calculate(expression, explain=False, precision=4)</code>  <code>async</code>","text":"<p>Perform scientific calculation with optional explanation.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>Mathematical expression</p> required <code>explain</code> <code>bool</code> <p>Whether to include step-by-step explanation</p> <code>False</code> <code>precision</code> <code>int</code> <p>Decimal places for rounding</p> <code>4</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with result and optional explanation</p> Example <p>await scientific_calculate(\"log(100, 10)\", explain=True) {     'result': 2.0,     'expression': 'log(100, 10)',     'explanation': 'Logarithm of 100 with base 10 equals 2.0' }</p> Source code in <code>agenticraft/tools/calculator.py</code> <pre><code>@tool(\n    name=\"scientific_calculator\",\n    description=\"Perform advanced scientific calculations with step-by-step explanation.\"\n)\nasync def scientific_calculate(\n    expression: str,\n    explain: bool = False,\n    precision: int = 4\n) -&gt; Dict[str, Any]:\n    \"\"\"Perform scientific calculation with optional explanation.\n\n    Args:\n        expression: Mathematical expression\n        explain: Whether to include step-by-step explanation\n        precision: Decimal places for rounding\n\n    Returns:\n        Dictionary with result and optional explanation\n\n    Example:\n        &gt;&gt;&gt; await scientific_calculate(\"log(100, 10)\", explain=True)\n        {\n            'result': 2.0,\n            'expression': 'log(100, 10)',\n            'explanation': 'Logarithm of 100 with base 10 equals 2.0'\n        }\n    \"\"\"\n    result = _calculate_expression(expression)\n    rounded_result = round(result, precision)\n\n    response = {\n        'result': rounded_result,\n        'expression': expression\n    }\n\n    if explain:\n        # Generate simple explanation\n        explanation = f\"Evaluating: {expression} = {rounded_result}\"\n\n        # Add specific explanations for common operations\n        if 'sqrt' in expression:\n            explanation += \" (square root calculation)\"\n        elif 'log' in expression:\n            explanation += \" (logarithmic calculation)\"\n        elif any(trig in expression for trig in ['sin', 'cos', 'tan']):\n            explanation += \" (trigonometric calculation)\"\n\n        response['explanation'] = explanation\n\n    return response\n</code></pre>"},{"location":"reference/tools/file_ops/","title":"File ops","text":""},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops","title":"<code>file_ops</code>","text":"<p>File operations tools for agents.</p> <p>Provides safe file reading, writing, and manipulation capabilities.</p>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.read_file","title":"<code>read_file(path, encoding='utf-8', max_size_mb=10.0)</code>  <code>async</code>","text":"<p>Read contents of a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the file</p> required <code>encoding</code> <code>str</code> <p>File encoding (default: utf-8)</p> <code>'utf-8'</code> <code>max_size_mb</code> <code>float</code> <p>Maximum file size in MB to read</p> <code>10.0</code> <p>Returns:</p> Type Description <code>str</code> <p>File contents as string</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If file is too large</p> Example <p>await read_file(\"data.txt\") \"Hello, World!\"</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"read_file\",\n    description=\"Read contents of a text file. Supports various encodings.\"\n)\nasync def read_file(\n    path: str,\n    encoding: str = \"utf-8\",\n    max_size_mb: float = 10.0\n) -&gt; str:\n    \"\"\"Read contents of a file.\n\n    Args:\n        path: Path to the file\n        encoding: File encoding (default: utf-8)\n        max_size_mb: Maximum file size in MB to read\n\n    Returns:\n        File contents as string\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If file is too large\n\n    Example:\n        &gt;&gt;&gt; await read_file(\"data.txt\")\n        \"Hello, World!\"\n    \"\"\"\n    return await _read_file(path, encoding, max_size_mb)\n</code></pre>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.write_file","title":"<code>write_file(path, content, encoding='utf-8', overwrite=False)</code>  <code>async</code>","text":"<p>Write content to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to write to</p> required <code>content</code> <code>str</code> <p>Content to write</p> required <code>encoding</code> <code>str</code> <p>File encoding</p> <code>'utf-8'</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with operation details</p> Example <p>await write_file(\"output.txt\", \"Hello!\", overwrite=True)</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"write_file\",\n    description=\"Write content to a file. Creates directories if needed.\"\n)\nasync def write_file(\n    path: str,\n    content: str,\n    encoding: str = \"utf-8\",\n    overwrite: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"Write content to a file.\n\n    Args:\n        path: Path to write to\n        content: Content to write\n        encoding: File encoding\n        overwrite: Whether to overwrite existing files\n\n    Returns:\n        Dictionary with operation details\n\n    Example:\n        &gt;&gt;&gt; await write_file(\"output.txt\", \"Hello!\", overwrite=True)\n        {'path': 'output.txt', 'size': 6, 'created': True}\n    \"\"\"\n    return await _write_file(path, content, encoding, overwrite)\n</code></pre>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.list_files","title":"<code>list_files(directory='.', pattern='*', recursive=False, include_hidden=False)</code>  <code>async</code>","text":"<p>List files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Directory to list</p> <code>'.'</code> <code>pattern</code> <code>str</code> <p>Glob pattern for filtering</p> <code>'*'</code> <code>recursive</code> <code>bool</code> <p>Whether to search recursively</p> <code>False</code> <code>include_hidden</code> <code>bool</code> <p>Whether to include hidden files</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of file information dictionaries</p> Example <p>await list_files(\".\", pattern=\"*.py\") [{'name': 'main.py', 'size': 1024, 'is_dir': False}, ...]</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"list_files\",\n    description=\"List files in a directory with optional filtering.\"\n)\nasync def list_files(\n    directory: str = \".\",\n    pattern: str = \"*\",\n    recursive: bool = False,\n    include_hidden: bool = False\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"List files in a directory.\n\n    Args:\n        directory: Directory to list\n        pattern: Glob pattern for filtering\n        recursive: Whether to search recursively\n        include_hidden: Whether to include hidden files\n\n    Returns:\n        List of file information dictionaries\n\n    Example:\n        &gt;&gt;&gt; await list_files(\".\", pattern=\"*.py\")\n        [{'name': 'main.py', 'size': 1024, 'is_dir': False}, ...]\n    \"\"\"\n    dir_path = Path(directory).expanduser().resolve()\n\n    if not dir_path.exists():\n        raise FileNotFoundError(f\"Directory not found: {directory}\")\n\n    if not dir_path.is_dir():\n        raise ValueError(f\"Path is not a directory: {directory}\")\n\n    # Get files\n    if recursive:\n        paths = dir_path.rglob(pattern)\n    else:\n        paths = dir_path.glob(pattern)\n\n    # Build file list\n    files = []\n    for path in paths:\n        # Skip hidden files if requested\n        if not include_hidden and path.name.startswith('.'):\n            continue\n\n        try:\n            stat = path.stat()\n            files.append({\n                'name': path.name,\n                'path': str(path.relative_to(dir_path)),\n                'size': stat.st_size,\n                'is_dir': path.is_dir(),\n                'modified': stat.st_mtime\n            })\n        except Exception:\n            # Skip files we can't stat\n            continue\n\n    # Sort by name\n    files.sort(key=lambda x: x['name'])\n\n    return files\n</code></pre>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.read_json","title":"<code>read_json(path)</code>  <code>async</code>","text":"<p>Read and parse JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to JSON file</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Parsed JSON data</p> Example <p>await read_json(\"config.json\")</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"read_json\",\n    description=\"Read and parse a JSON file.\"\n)\nasync def read_json(path: str) -&gt; Any:\n    \"\"\"Read and parse JSON file.\n\n    Args:\n        path: Path to JSON file\n\n    Returns:\n        Parsed JSON data\n\n    Example:\n        &gt;&gt;&gt; await read_json(\"config.json\")\n        {'setting': 'value'}\n    \"\"\"\n    content = await _read_file(path)\n    try:\n        return json.loads(content)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON in {path}: {e}\")\n</code></pre>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.write_json","title":"<code>write_json(path, data, indent=2, overwrite=False)</code>  <code>async</code>","text":"<p>Write data to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to write to</p> required <code>data</code> <code>Any</code> <p>Data to serialize as JSON</p> required <code>indent</code> <code>int</code> <p>Indentation level</p> <code>2</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing file</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Operation details</p> Example <p>await write_json(\"data.json\", {\"key\": \"value\"})</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"write_json\",\n    description=\"Write data to a JSON file with formatting.\"\n)\nasync def write_json(\n    path: str,\n    data: Any,\n    indent: int = 2,\n    overwrite: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"Write data to JSON file.\n\n    Args:\n        path: Path to write to\n        data: Data to serialize as JSON\n        indent: Indentation level\n        overwrite: Whether to overwrite existing file\n\n    Returns:\n        Operation details\n\n    Example:\n        &gt;&gt;&gt; await write_json(\"data.json\", {\"key\": \"value\"})\n        {'path': 'data.json', 'size': 18, 'created': True}\n    \"\"\"\n    content = json.dumps(data, indent=indent, ensure_ascii=False)\n    return await _write_file(path, content, overwrite=overwrite)\n</code></pre>"},{"location":"reference/tools/file_ops/#agenticraft.tools.file_ops.file_info","title":"<code>file_info(path)</code>  <code>async</code>","text":"<p>Get detailed file or directory information.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to inspect</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with file/directory details</p> Example <p>await file_info(\"document.txt\") {     'path': 'document.txt',     'exists': True,     'is_file': True,     'size': 1024,     'extension': '.txt' }</p> Source code in <code>agenticraft/tools/file_ops.py</code> <pre><code>@tool(\n    name=\"file_info\",\n    description=\"Get detailed information about a file or directory.\"\n)\nasync def file_info(path: str) -&gt; Dict[str, Any]:\n    \"\"\"Get detailed file or directory information.\n\n    Args:\n        path: Path to inspect\n\n    Returns:\n        Dictionary with file/directory details\n\n    Example:\n        &gt;&gt;&gt; await file_info(\"document.txt\")\n        {\n            'path': 'document.txt',\n            'exists': True,\n            'is_file': True,\n            'size': 1024,\n            'extension': '.txt'\n        }\n    \"\"\"\n    file_path = Path(path).expanduser().resolve()\n\n    info = {\n        'path': str(file_path),\n        'name': file_path.name,\n        'exists': file_path.exists()\n    }\n\n    if file_path.exists():\n        stat = file_path.stat()\n        info.update({\n            'is_file': file_path.is_file(),\n            'is_dir': file_path.is_dir(),\n            'size': stat.st_size,\n            'modified': stat.st_mtime,\n            'created': stat.st_ctime\n        })\n\n        if file_path.is_file():\n            info['extension'] = file_path.suffix\n            info['stem'] = file_path.stem\n\n    return info\n</code></pre>"},{"location":"reference/tools/web/","title":"Web","text":""},{"location":"reference/tools/web/#agenticraft.tools.web","title":"<code>web</code>","text":"<p>Web search and scraping tools for agents.</p> <p>Provides web search and basic web scraping capabilities. Note: Real implementation requires API keys for search providers.</p>"},{"location":"reference/tools/web/#agenticraft.tools.web.web_search","title":"<code>web_search(query, num_results=5, search_type='general')</code>  <code>async</code>","text":"<p>Search the web for information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query</p> required <code>num_results</code> <code>int</code> <p>Number of results to return (max 10)</p> <code>5</code> <code>search_type</code> <code>str</code> <p>Type of search (general, news, academic)</p> <code>'general'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of search results</p> Example <p>await web_search(\"python programming\", num_results=3) [     {         'title': 'Python Programming Language',         'snippet': 'Official Python website...',         'url': 'https://python.org',         'date': '2024-01-15'     },     ... ]</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"web_search\",\n    description=\"Search the web for information. Returns relevant results with titles, snippets, and URLs.\"\n)\nasync def web_search(\n    query: str,\n    num_results: int = 5,\n    search_type: str = \"general\"\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Search the web for information.\n\n    Args:\n        query: Search query\n        num_results: Number of results to return (max 10)\n        search_type: Type of search (general, news, academic)\n\n    Returns:\n        List of search results\n\n    Example:\n        &gt;&gt;&gt; await web_search(\"python programming\", num_results=3)\n        [\n            {\n                'title': 'Python Programming Language',\n                'snippet': 'Official Python website...',\n                'url': 'https://python.org',\n                'date': '2024-01-15'\n            },\n            ...\n        ]\n    \"\"\"\n    # Limit results\n    num_results = min(num_results, 10)\n\n    # Note: This is a mock implementation\n    # Real implementation would use APIs like:\n    # - Google Custom Search API\n    # - Bing Search API\n    # - DuckDuckGo API\n    # - SerpAPI\n\n    # For demo purposes, return mock results\n    mock_results = [\n        {\n            'title': f'Result {i+1} for: {query}',\n            'snippet': f'This is a relevant snippet about {query}. '\n                      f'It contains useful information that matches the search query...',\n            'url': f'https://example.com/result{i+1}',\n            'date': datetime.now().isoformat(),\n            'relevance_score': 0.95 - (i * 0.05)\n        }\n        for i in range(num_results)\n    ]\n\n    # Add search type specific results\n    if search_type == \"news\":\n        for result in mock_results:\n            result['source'] = 'Example News'\n            result['category'] = 'Technology'\n    elif search_type == \"academic\":\n        for result in mock_results:\n            result['authors'] = ['J. Doe', 'A. Smith']\n            result['citations'] = 42\n\n    return mock_results\n</code></pre>"},{"location":"reference/tools/web/#agenticraft.tools.web.extract_text","title":"<code>extract_text(url, include_links=False, max_length=None)</code>  <code>async</code>","text":"<p>Extract text content from a webpage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to extract text from</p> required <code>include_links</code> <code>bool</code> <p>Whether to include hyperlinks</p> <code>False</code> <code>max_length</code> <code>Optional[int]</code> <p>Maximum text length to return</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with extracted content</p> Example <p>await extract_text(\"https://example.com/article\") {     'url': 'https://example.com/article',     'title': 'Article Title',     'text': 'Article content...',     'links': [],     'word_count': 500 }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"extract_text\",\n    description=\"Extract clean text content from a webpage URL.\"\n)\nasync def extract_text(\n    url: str,\n    include_links: bool = False,\n    max_length: Optional[int] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"Extract text content from a webpage.\n\n    Args:\n        url: URL to extract text from\n        include_links: Whether to include hyperlinks\n        max_length: Maximum text length to return\n\n    Returns:\n        Dictionary with extracted content\n\n    Example:\n        &gt;&gt;&gt; await extract_text(\"https://example.com/article\")\n        {\n            'url': 'https://example.com/article',\n            'title': 'Article Title',\n            'text': 'Article content...',\n            'links': [],\n            'word_count': 500\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Note: Real implementation would use:\n    # - aiohttp for async HTTP requests\n    # - BeautifulSoup or lxml for HTML parsing\n    # - Readability or newspaper3k for article extraction\n\n    # Mock implementation\n    mock_content = {\n        'url': url,\n        'title': f'Page Title from {parsed.netloc}',\n        'text': f'This is the extracted text content from {url}. '\n               f'It contains the main article or page content without '\n               f'navigation, ads, or other clutter. The extraction process '\n               f'identifies the primary content area and extracts clean text.',\n        'word_count': 42,\n        'language': 'en',\n        'published_date': None\n    }\n\n    if include_links:\n        mock_content['links'] = [\n            {'text': 'Related Article', 'url': f'{url}/related'},\n            {'text': 'More Information', 'url': f'{url}/more'}\n        ]\n\n    # Truncate if needed\n    if max_length and len(mock_content['text']) &gt; max_length:\n        mock_content['text'] = mock_content['text'][:max_length] + '...'\n        mock_content['truncated'] = True\n\n    return mock_content\n</code></pre>"},{"location":"reference/tools/web/#agenticraft.tools.web.get_page_metadata","title":"<code>get_page_metadata(url)</code>  <code>async</code>","text":"<p>Get metadata from a webpage.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to analyze</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with page metadata</p> Example <p>await get_page_metadata(\"https://example.com\") {     'url': 'https://example.com',     'title': 'Example Domain',     'description': 'Example Domain for Documentation',     'image': 'https://example.com/image.jpg',     'type': 'website' }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"get_page_metadata\",\n    description=\"Extract metadata from a webpage including title, description, and Open Graph data.\"\n)\nasync def get_page_metadata(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Get metadata from a webpage.\n\n    Args:\n        url: URL to analyze\n\n    Returns:\n        Dictionary with page metadata\n\n    Example:\n        &gt;&gt;&gt; await get_page_metadata(\"https://example.com\")\n        {\n            'url': 'https://example.com',\n            'title': 'Example Domain',\n            'description': 'Example Domain for Documentation',\n            'image': 'https://example.com/image.jpg',\n            'type': 'website'\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Mock implementation\n    # Real implementation would parse meta tags, Open Graph, Twitter Cards, etc.\n    return {\n        'url': url,\n        'title': f'{parsed.netloc} - Home',\n        'description': f'Welcome to {parsed.netloc}',\n        'keywords': ['example', 'demo', 'website'],\n        'author': None,\n        'image': f'{parsed.scheme}://{parsed.netloc}/og-image.jpg',\n        'type': 'website',\n        'locale': 'en_US',\n        'site_name': parsed.netloc.replace('.', ' ').title()\n    }\n</code></pre>"},{"location":"reference/tools/web/#agenticraft.tools.web.check_url","title":"<code>check_url(url)</code>  <code>async</code>","text":"<p>Check URL accessibility and get basic info.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to check</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with URL status and info</p> Example <p>await check_url(\"https://example.com\") {     'url': 'https://example.com',     'accessible': True,     'status_code': 200,     'content_type': 'text/html',     'response_time_ms': 150 }</p> Source code in <code>agenticraft/tools/web.py</code> <pre><code>@tool(\n    name=\"check_url\",\n    description=\"Check if a URL is accessible and get basic information.\"\n)\nasync def check_url(url: str) -&gt; Dict[str, Any]:\n    \"\"\"Check URL accessibility and get basic info.\n\n    Args:\n        url: URL to check\n\n    Returns:\n        Dictionary with URL status and info\n\n    Example:\n        &gt;&gt;&gt; await check_url(\"https://example.com\")\n        {\n            'url': 'https://example.com',\n            'accessible': True,\n            'status_code': 200,\n            'content_type': 'text/html',\n            'response_time_ms': 150\n        }\n    \"\"\"\n    # Validate URL\n    parsed = urlparse(url)\n    if not parsed.scheme or not parsed.netloc:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    # Check for supported protocols\n    if parsed.scheme not in ['http', 'https']:\n        raise ValueError(f\"Invalid URL: {url}\")  # Only HTTP/HTTPS supported\n\n    # Mock implementation\n    # Real implementation would make HEAD request\n    return {\n        'url': url,\n        'accessible': True,\n        'status_code': 200,\n        'content_type': 'text/html; charset=utf-8',\n        'content_length': 1024 * 10,  # 10KB\n        'response_time_ms': 150,\n        'ssl_valid': parsed.scheme == 'https',\n        'redirects': []\n    }\n</code></pre>"},{"location":"reference/utils/config/","title":"Config","text":""},{"location":"reference/utils/config/#agenticraft.utils.config","title":"<code>config</code>","text":"<p>Utilities for managing AgentiCraft configuration.</p> <p>This module provides helper functions for configuration management, including environment setup, validation, and initialization.</p> Example <p>Setting up configuration::</p> <pre><code>from agenticraft.utils.config import setup_environment, validate_config\n\n# Set up from .env file\nsetup_environment()\n\n# Validate configuration\nvalidate_config(providers=[\"openai\"])\n</code></pre>"},{"location":"reference/utils/config/#agenticraft.utils.config.setup_environment","title":"<code>setup_environment(env_file=None, override=True)</code>","text":"<p>Load environment variables from .env file.</p> <p>Parameters:</p> Name Type Description Default <code>env_file</code> <code>Optional[str]</code> <p>Path to .env file (defaults to searching for .env)</p> <code>None</code> <code>override</code> <code>bool</code> <p>Whether to override existing environment variables</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if a .env file was loaded</p> Example <p>setup_environment(\".env.production\")</p> Source code in <code>agenticraft/utils/config.py</code> <pre><code>def setup_environment(\n    env_file: Optional[str] = None,\n    override: bool = True\n) -&gt; bool:\n    \"\"\"Load environment variables from .env file.\n\n    Args:\n        env_file: Path to .env file (defaults to searching for .env)\n        override: Whether to override existing environment variables\n\n    Returns:\n        True if a .env file was loaded\n\n    Example:\n        setup_environment(\".env.production\")\n    \"\"\"\n    if env_file:\n        return load_dotenv(env_file, override=override)\n    else:\n        # Search for .env file in current and parent directories\n        current = Path.cwd()\n        while current != current.parent:\n            env_path = current / \".env\"\n            if env_path.exists():\n                return load_dotenv(env_path, override=override)\n            current = current.parent\n\n        # Try default location\n        return load_dotenv(override=override)\n</code></pre>"},{"location":"reference/utils/config/#agenticraft.utils.config.validate_config","title":"<code>validate_config(providers=None, require_telemetry=False)</code>","text":"<p>Validate that configuration is properly set up.</p> <p>Parameters:</p> Name Type Description Default <code>providers</code> <code>Optional[List[str]]</code> <p>List of providers that need API keys</p> <code>None</code> <code>require_telemetry</code> <code>bool</code> <p>Whether telemetry configuration is required</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If configuration is invalid</p> Example <p>validate_config(providers=[\"openai\", \"anthropic\"])</p> Source code in <code>agenticraft/utils/config.py</code> <pre><code>def validate_config(\n    providers: Optional[List[str]] = None,\n    require_telemetry: bool = False\n) -&gt; None:\n    \"\"\"Validate that configuration is properly set up.\n\n    Args:\n        providers: List of providers that need API keys\n        require_telemetry: Whether telemetry configuration is required\n\n    Raises:\n        ValueError: If configuration is invalid\n\n    Example:\n        validate_config(providers=[\"openai\", \"anthropic\"])\n    \"\"\"\n    errors = []\n\n    # Check API keys for requested providers\n    if providers:\n        for provider in providers:\n            if not settings.get_api_key(provider):\n                errors.append(f\"Missing API key for {provider}\")\n\n    # Check telemetry if required\n    if require_telemetry and settings.telemetry_enabled:\n        if not settings.telemetry_export_endpoint:\n            errors.append(\"Telemetry enabled but no export endpoint configured\")\n\n    # Check memory path exists\n    if not settings.memory_path.exists():\n        try:\n            settings.memory_path.mkdir(parents=True, exist_ok=True)\n        except Exception as e:\n            errors.append(f\"Cannot create memory path: {e}\")\n\n    # Check plugin directories\n    for plugin_dir in settings.plugin_dirs:\n        if not plugin_dir.exists():\n            try:\n                plugin_dir.mkdir(parents=True, exist_ok=True)\n            except Exception as e:\n                errors.append(f\"Cannot create plugin directory {plugin_dir}: {e}\")\n\n    if errors:\n        raise ValueError(\n            \"Configuration validation failed:\\n\" + \n            \"\\n\".join(f\"  - {error}\" for error in errors)\n        )\n</code></pre>"},{"location":"reference/utils/config/#agenticraft.utils.config.init_from_env","title":"<code>init_from_env(env_file=None, providers=None)</code>","text":"<p>Initialize AgentiCraft from environment variables.</p> <p>This is a convenience function that: 1. Loads environment variables from .env file 2. Reloads settings 3. Validates configuration</p> <p>Parameters:</p> Name Type Description Default <code>env_file</code> <code>Optional[str]</code> <p>Path to .env file</p> <code>None</code> <code>providers</code> <code>Optional[List[str]]</code> <p>Providers that need API keys</p> <code>None</code> Example <p>init_from_env(providers=[\"openai\"])</p> Source code in <code>agenticraft/utils/config.py</code> <pre><code>def init_from_env(\n    env_file: Optional[str] = None,\n    providers: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"Initialize AgentiCraft from environment variables.\n\n    This is a convenience function that:\n    1. Loads environment variables from .env file\n    2. Reloads settings\n    3. Validates configuration\n\n    Args:\n        env_file: Path to .env file\n        providers: Providers that need API keys\n\n    Example:\n        init_from_env(providers=[\"openai\"])\n    \"\"\"\n    # Load environment\n    setup_environment(env_file)\n\n    # Reload settings to pick up new environment variables\n    reload_settings()\n\n    # Validate\n    validate_config(providers=providers)\n</code></pre>"},{"location":"reference/utils/config/#agenticraft.utils.config.get_config_info","title":"<code>get_config_info()</code>","text":"<p>Get information about current configuration.</p> <p>Returns:</p> Type Description <code>Dict[str, any]</code> <p>Dictionary with configuration information</p> Source code in <code>agenticraft/utils/config.py</code> <pre><code>def get_config_info() -&gt; Dict[str, any]:\n    \"\"\"Get information about current configuration.\n\n    Returns:\n        Dictionary with configuration information\n    \"\"\"\n    return {\n        \"environment\": settings.environment,\n        \"debug\": settings.debug,\n        \"providers_configured\": {\n            \"openai\": bool(settings.openai_api_key),\n            \"anthropic\": bool(settings.anthropic_api_key),\n            \"google\": bool(settings.google_api_key),\n        },\n        \"default_model\": settings.default_model,\n        \"telemetry_enabled\": settings.telemetry_enabled,\n        \"memory_backend\": settings.memory_backend,\n        \"plugins_enabled\": settings.plugins_enabled,\n        \"mcp_enabled\": settings.mcp_enabled,\n    }\n</code></pre>"},{"location":"reference/utils/config/#agenticraft.utils.config.create_env_template","title":"<code>create_env_template(path='.env.example')</code>","text":"<p>Create a template .env file with all available settings.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to create the template file</p> <code>'.env.example'</code> Source code in <code>agenticraft/utils/config.py</code> <pre><code>def create_env_template(path: str = \".env.example\") -&gt; None:\n    \"\"\"Create a template .env file with all available settings.\n\n    Args:\n        path: Path to create the template file\n    \"\"\"\n    template = \"\"\"# AgentiCraft Configuration\n# Copy this file to .env and update with your values\n\n# Environment\nAGENTICRAFT_ENVIRONMENT=development\nAGENTICRAFT_DEBUG=false\nAGENTICRAFT_LOG_LEVEL=INFO\n\n# API Keys\nAGENTICRAFT_OPENAI_API_KEY=your-openai-key-here\nAGENTICRAFT_ANTHROPIC_API_KEY=your-anthropic-key-here\nAGENTICRAFT_GOOGLE_API_KEY=your-google-key-here\n\n# Model Defaults\nAGENTICRAFT_DEFAULT_MODEL=gpt-4\nAGENTICRAFT_DEFAULT_TEMPERATURE=0.7\nAGENTICRAFT_DEFAULT_MAX_TOKENS=\nAGENTICRAFT_DEFAULT_TIMEOUT=30\nAGENTICRAFT_DEFAULT_MAX_RETRIES=3\n\n# Provider URLs (optional)\nAGENTICRAFT_OPENAI_BASE_URL=https://api.openai.com/v1\nAGENTICRAFT_ANTHROPIC_BASE_URL=https://api.anthropic.com\nAGENTICRAFT_OLLAMA_BASE_URL=http://localhost:11434\n\n# Memory Settings\nAGENTICRAFT_MEMORY_BACKEND=sqlite\nAGENTICRAFT_MEMORY_PATH=./memory\nAGENTICRAFT_CONVERSATION_MEMORY_SIZE=10\n\n# Telemetry\nAGENTICRAFT_TELEMETRY_ENABLED=true\nAGENTICRAFT_TELEMETRY_SERVICE_NAME=agenticraft\nAGENTICRAFT_TELEMETRY_EXPORT_ENDPOINT=http://localhost:4317\nAGENTICRAFT_TELEMETRY_SAMPLE_RATE=1.0\n\n# Plugins\nAGENTICRAFT_PLUGINS_ENABLED=true\nAGENTICRAFT_PLUGIN_DIRS=[\"./plugins\"]\n\n# MCP (Model Context Protocol)\nAGENTICRAFT_MCP_ENABLED=true\nAGENTICRAFT_MCP_SERVERS=[]\n\n# Tool Settings\nAGENTICRAFT_TOOL_EXECUTION_TIMEOUT=10\nAGENTICRAFT_TOOL_RETRY_ATTEMPTS=2\n\n# Workflow Settings\nAGENTICRAFT_WORKFLOW_STEP_TIMEOUT=60\nAGENTICRAFT_WORKFLOW_MAX_PARALLEL_STEPS=5\n\n# Security\nAGENTICRAFT_ALLOW_CODE_EXECUTION=false\nAGENTICRAFT_ALLOWED_DOMAINS=[]\n\"\"\"\n\n    with open(path, 'w') as f:\n        f.write(template)\n\n    print(f\"Created environment template at {path}\")\n</code></pre>"},{"location":"releases/v0.1.1_summary/","title":"AgentiCraft v0.1.1 Release Summary","text":""},{"location":"releases/v0.1.1_summary/#overview","title":"Overview","text":"<p>AgentiCraft v0.1.1 is scheduled for release on June 11, 2025, bringing dynamic provider switching, new LLM providers, and enhanced agent capabilities while maintaining full backward compatibility.</p>"},{"location":"releases/v0.1.1_summary/#release-timeline","title":"Release Timeline","text":""},{"location":"releases/v0.1.1_summary/#week-2-schedule-june-5-11-2025","title":"Week 2 Schedule (June 5-11, 2025)","text":"<ul> <li>Day 1 (June 5): Anthropic provider implementation \u2713</li> <li>Day 2 (June 6): Ollama provider implementation</li> <li>Day 3 (June 7): PyPI package publishing</li> <li>Day 4 (June 8): Documentation website deployment</li> <li>Day 5 (June 9): ReasoningAgent and WorkflowAgent</li> <li>Day 6-7 (June 10-11): Testing, community feedback, and v0.1.1 release</li> </ul>"},{"location":"releases/v0.1.1_summary/#key-features","title":"Key Features","text":""},{"location":"releases/v0.1.1_summary/#1-dynamic-provider-switching","title":"1. Dynamic Provider Switching \u2705","text":"<pre><code># Auto-detection from model name\nagent = Agent(name=\"FlexibleAgent\", model=\"gpt-4\")\n\n# NEW: Explicit provider specification\nagent = Agent(name=\"FlexibleAgent\", provider=\"anthropic\", model=\"claude-3-opus-20240229\")\n\n# Runtime provider switching\nagent.set_provider(\"anthropic\", model=\"claude-3-opus-20240229\")\nagent.set_provider(\"ollama\", model=\"llama2\")\n</code></pre>"},{"location":"releases/v0.1.1_summary/#2-new-providers","title":"2. New Providers","text":"<ul> <li>Anthropic: Claude-3 models (Opus, Sonnet, Haiku)</li> <li>Ollama: Local models (Llama2, Mistral, CodeLlama, etc.)</li> </ul>"},{"location":"releases/v0.1.1_summary/#3-advanced-agents","title":"3. Advanced Agents","text":"<ul> <li>ReasoningAgent: Transparent thought process exposure</li> <li>WorkflowAgent: Optimized for multi-step workflows</li> </ul>"},{"location":"releases/v0.1.1_summary/#4-pypi-package","title":"4. PyPI Package","text":"<pre><code>pip install agenticraft\n</code></pre>"},{"location":"releases/v0.1.1_summary/#testing-status","title":"Testing Status","text":""},{"location":"releases/v0.1.1_summary/#completed","title":"Completed \u2705","text":"<ul> <li>Provider switching integration tests (19 test methods)</li> <li>Provider unit tests (Anthropic, Ollama)</li> <li>Mock implementation tests for set_provider</li> <li>Performance benchmarking framework</li> </ul>"},{"location":"releases/v0.1.1_summary/#files-created","title":"Files Created","text":"<ol> <li>Tests:</li> <li><code>/tests/integration/test_provider_switching.py</code> - Comprehensive integration tests</li> <li><code>/tests/unit/core/test_provider_switching.py</code> - Unit tests with mocks</li> <li> <p><code>/tests/unit/core/test_agent_config_provider.py</code> - Provider parameter tests</p> </li> <li> <p>Implementation:</p> </li> <li><code>/patches/agent_set_provider.patch</code> - No longer needed (implemented)</li> <li><code>/patches/agent_config_provider.patch</code> - No longer needed (implemented)</li> <li> <p>Core functionality fully integrated into <code>agent.py</code> and <code>provider.py</code></p> </li> <li> <p>Examples:</p> </li> <li><code>/examples/provider_switching/basic_switching.py</code> - Simple examples</li> <li><code>/examples/provider_switching/cost_optimization.py</code> - Smart provider selection</li> <li><code>/examples/provider_switching/provider_failover.py</code> - Resilient agents</li> <li> <p><code>/examples/provider_switching/provider_parameter_example.py</code> - Provider parameter usage</p> </li> <li> <p>Documentation:</p> </li> <li><code>/docs/features/provider_switching.md</code> - Complete feature guide with provider parameter</li> <li><code>/docs/migration/v0.1.0_to_v0.1.1.md</code> - Migration guide</li> <li><code>/docs/guides/provider_switching_performance.md</code> - Performance optimization</li> <li><code>/docs/implementation/provider_parameter_summary.md</code> - Provider parameter details</li> </ol>"},{"location":"releases/v0.1.1_summary/#implementation-checklist","title":"Implementation Checklist","text":""},{"location":"releases/v0.1.1_summary/#core-changes-required-all-complete","title":"Core Changes Required \u2705 ALL COMPLETE","text":"<ul> <li> Add <code>set_provider()</code> method to Agent class \u2705</li> <li> Add <code>get_provider_info()</code> method to Agent class \u2705</li> <li> Add <code>list_available_providers()</code> method to Agent class \u2705</li> <li> Update AgentConfig to support provider parameter \u2705</li> <li> Ensure ProviderFactory handles all provider types \u2705</li> </ul> <p>Status: All core provider switching functionality is fully implemented and ready for release.</p>"},{"location":"releases/v0.1.1_summary/#provider-implementations-all-complete","title":"Provider Implementations \u2705 ALL COMPLETE","text":"<ul> <li> OpenAI provider (existing) \u2705</li> <li> Anthropic provider tests ready \u2705</li> <li> Ollama provider tests ready \u2705</li> <li> Anthropic provider implementation (~250 LOC) \u2705</li> <li> Ollama provider implementation (~400 LOC) \u2705</li> </ul> <p>Status: All LLM providers are fully implemented with comprehensive test coverage.</p>"},{"location":"releases/v0.1.1_summary/#new-agent-types-complete","title":"New Agent Types \u2705 COMPLETE","text":"<ul> <li> ReasoningAgent implementation \u2705</li> <li> WorkflowAgent implementation \u2705</li> <li> Agent type tests \u2705</li> </ul> <p>Status: Both advanced agents are fully implemented with comprehensive tests and examples.</p>"},{"location":"releases/v0.1.1_summary/#documentation-examples","title":"Documentation &amp; Examples","text":"<ul> <li> Provider switching guide</li> <li> Migration guide</li> <li> Performance guide</li> <li> Example scripts</li> <li> Update main README</li> <li> Update API reference</li> </ul>"},{"location":"releases/v0.1.1_summary/#quality-assurance","title":"Quality Assurance","text":""},{"location":"releases/v0.1.1_summary/#test-coverage-goals","title":"Test Coverage Goals","text":"<ul> <li>Maintain &gt;95% coverage for all new code</li> <li>All examples must have corresponding tests</li> <li>Integration tests for cross-provider compatibility</li> </ul>"},{"location":"releases/v0.1.1_summary/#performance-targets","title":"Performance Targets","text":"<ul> <li>Provider switching: &lt;50ms overhead</li> <li>No memory leaks when switching providers</li> <li>Connection pooling for high-throughput scenarios</li> </ul>"},{"location":"releases/v0.1.1_summary/#community-release","title":"Community &amp; Release","text":""},{"location":"releases/v0.1.1_summary/#release-preparation","title":"Release Preparation","text":"<ol> <li>Run all tests: <code>pytest tests/ -v --cov=agenticraft</code></li> <li>Update CHANGELOG.md with v0.1.1 features</li> <li>Tag release: <code>git tag v0.1.1</code></li> <li>Build package: <code>python -m build</code></li> <li>Upload to PyPI: <code>twine upload dist/*</code></li> </ol>"},{"location":"releases/v0.1.1_summary/#community-engagement","title":"Community Engagement","text":"<ul> <li>Announce on Discord/Slack</li> <li>Post on social media with examples</li> <li>Create demo video showing provider switching</li> <li>Monitor GitHub issues for early feedback</li> </ul>"},{"location":"releases/v0.1.1_summary/#known-limitations","title":"Known Limitations","text":"<ol> <li>Streaming: Not yet unified across providers</li> <li>Tool Formats: Minor differences in tool calling between providers</li> <li>Model Names: Must use provider-specific model names</li> <li>Ollama Setup: Requires local installation</li> </ol>"},{"location":"releases/v0.1.1_summary/#future-enhancements-v020","title":"Future Enhancements (v0.2.0)","text":"<ol> <li>Provider Pooling: Reuse provider instances</li> <li>Auto Model Selection: Based on task analysis</li> <li>Cost Tracking: Built-in usage monitoring</li> <li>Streaming Interface: Unified streaming across providers</li> <li>Provider Profiles: Save/load configurations</li> </ol>"},{"location":"releases/v0.1.1_summary/#support-resources","title":"Support Resources","text":"<ul> <li>Documentation: https://docs.agenticraft.ai</li> <li>Examples: <code>/examples/provider_switching/</code></li> <li>Issues: https://github.com/agenticraft/agenticraft/issues</li> <li>Discord: https://discord.gg/agenticraft</li> </ul>"},{"location":"releases/v0.1.1_summary/#current-status-june-6-2025","title":"Current Status (June 6, 2025)","text":""},{"location":"releases/v0.1.1_summary/#completed_1","title":"\u2705 Completed","text":"<ul> <li>Provider Switching Core: All methods implemented and tested</li> <li>Provider Parameter: AgentConfig now supports explicit provider specification</li> <li>All Provider Implementations: OpenAI, Anthropic, and Ollama providers fully implemented</li> <li>Advanced Agents: ReasoningAgent and WorkflowAgent with full test coverage</li> <li>Tests: Comprehensive test coverage for all features</li> <li>Documentation: Feature guides, migration guide, and examples</li> <li>Examples: Multiple working examples for all features</li> </ul>"},{"location":"releases/v0.1.1_summary/#remaining-work","title":"\ud83d\udee0\ufe0f Remaining Work","text":"<ol> <li>Documentation:</li> <li>Update main README.md</li> <li> <p>Generate API reference</p> </li> <li> <p>Publishing:</p> </li> <li>PyPI package preparation</li> <li>Documentation website deployment</li> </ol>"},{"location":"releases/v0.1.1_summary/#next-steps-updated-way-ahead-of-schedule","title":"\ud83d\ude80 Next Steps (Updated - Way Ahead of Schedule!)","text":"<ul> <li>\u2705 Day 1 (June 5): Anthropic provider implementation - COMPLETE</li> <li>\u2705 Day 2 (June 6): Ollama provider implementation - COMPLETE (morning)</li> <li>\u2705 Day 2 (June 6): Advanced agents (ReasoningAgent, WorkflowAgent) - COMPLETE (afternoon)</li> <li>Day 3 (June 7): PyPI package preparation</li> <li>Day 4 (June 8): Documentation website deployment  </li> <li>Day 5-7 (June 9-11): Polish, community feedback, and v0.1.1 release</li> </ul> <p>Note: All major implementation work completed by Day 2! This gives us extra time for polish, documentation, and ensuring a high-quality release.</p>"},{"location":"releases/v0.1.1_summary/#final-notes","title":"Final Notes","text":"<p>v0.1.1 represents a significant step forward in making AgentiCraft a truly flexible, multi-provider framework with advanced agent capabilities. ALL major features are now complete:</p> <ul> <li>\u2705 Dynamic provider switching with rollback support</li> <li>\u2705 Explicit provider specification via provider parameter</li> <li>\u2705 Three fully functional providers (OpenAI, Anthropic, Ollama)</li> <li>\u2705 ReasoningAgent for transparent, explainable AI</li> <li>\u2705 WorkflowAgent for complex process orchestration</li> <li>\u2705 Comprehensive test coverage (&gt;95%)</li> <li>\u2705 Complete documentation and examples</li> </ul> <p>The remaining work is purely release preparation (documentation updates, PyPI packaging, and website deployment). The v0.1.1 release is significantly ahead of schedule and ready for final polish.</p> <p>Last Updated: June 6, 2025 Release Target: June 11, 2025</p>"}]}